<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"anyu10.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Materials:  concurrency is not parallelism rethinking classical concurrency patterns go sync package go concurrency patterns go advanced concurrency patterns">
<meta property="og:type" content="article">
<meta property="og:title" content="Go Concurrency">
<meta property="og:url" content="http://anyu10.github.io/2022/12/15/Go-Concurrency/index.html">
<meta property="og:site_name" content="Anyu">
<meta property="og:description" content="Materials:  concurrency is not parallelism rethinking classical concurrency patterns go sync package go concurrency patterns go advanced concurrency patterns">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:\Blog\source_images\image-20221216234927956.png">
<meta property="article:published_time" content="2022-12-15T08:09:36.000Z">
<meta property="article:modified_time" content="2022-12-17T13:37:53.127Z">
<meta property="article:author" content="Anyu Elin">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="Concurrency">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\Blog\source_images\image-20221216234927956.png">


<link rel="canonical" href="http://anyu10.github.io/2022/12/15/Go-Concurrency/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://anyu10.github.io/2022/12/15/Go-Concurrency/","path":"2022/12/15/Go-Concurrency/","title":"Go Concurrency"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Go Concurrency | Anyu</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Anyu</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Concurrency-Overview"><span class="nav-number">1.</span> <span class="nav-text">Concurrency Overview</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go-Concurrency-Features"><span class="nav-number">2.</span> <span class="nav-text">Go Concurrency Features</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Goroutines"><span class="nav-number">2.1.</span> <span class="nav-text">Goroutines</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channels"><span class="nav-number">2.2.</span> <span class="nav-text">Channels</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffered-Channels"><span class="nav-number">2.3.</span> <span class="nav-text">Buffered Channels</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Go-Approach"><span class="nav-number">2.4.</span> <span class="nav-text">The Go Approach</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go-Concurrency-Patterns"><span class="nav-number">3.</span> <span class="nav-text">Go Concurrency Patterns</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Generator-Function-Returns-a-Channel"><span class="nav-number">3.1.</span> <span class="nav-text">Generator : Function Returns a Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Normal-Generator-Model"><span class="nav-number">3.1.1.</span> <span class="nav-text">Normal Generator Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channels-as-a-Handle-on-a-Service"><span class="nav-number">3.1.2.</span> <span class="nav-text">Channels as a Handle on a Service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multiplexing-Fan-In"><span class="nav-number">3.1.3.</span> <span class="nav-text">Multiplexing (Fan-In)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Restoring-Sequencing"><span class="nav-number">3.1.4.</span> <span class="nav-text">Restoring Sequencing</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Select-Statement"><span class="nav-number">3.2.</span> <span class="nav-text">Select Statement</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fan-In-Using-Select"><span class="nav-number">3.2.1.</span> <span class="nav-text">Fan-In Using Select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timeout-Using-Select"><span class="nav-number">3.2.2.</span> <span class="nav-text">Timeout Using Select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timeout-for-Whole-Conversation-Using-Select"><span class="nav-number">3.2.3.</span> <span class="nav-text">Timeout for Whole Conversation Using Select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Receive-on-quit-channel"><span class="nav-number">3.2.4.</span> <span class="nav-text">Receive on quit channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daisy-Chain"><span class="nav-number">3.2.5.</span> <span class="nav-text">Daisy Chain</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Rethinking-Classical-Concurrent-Patterns"><span class="nav-number">4.</span> <span class="nav-text">Rethinking Classical Concurrent Patterns</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Asynchronous-API"><span class="nav-number">4.1.</span> <span class="nav-text">Asynchronous API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Asynchronous-Callback"><span class="nav-number">4.1.1.</span> <span class="nav-text">Asynchronous Callback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future"><span class="nav-number">4.1.2.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Producer%E2%80%93Consumer-Queue"><span class="nav-number">4.1.3.</span> <span class="nav-text">Producer–Consumer Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Analysis-of-Asynchronous-API"><span class="nav-number">4.1.4.</span> <span class="nav-text">Analysis of Asynchronous API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code"><span class="nav-number">4.1.5.</span> <span class="nav-text">Code</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition-Variable"><span class="nav-number">4.2.</span> <span class="nav-text">Condition Variable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition-Variable-Analysis"><span class="nav-number">4.2.1.</span> <span class="nav-text">Condition Variable Analysis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore-Sharing-by-Communicating"><span class="nav-number">4.2.2.</span> <span class="nav-text">Semaphore : Sharing by Communicating</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Worker-Pool"><span class="nav-number">4.3.</span> <span class="nav-text">Worker Pool</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go-Advanced-Concurrency-Patterns"><span class="nav-number">5.</span> <span class="nav-text">Go Advanced Concurrency Patterns</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Timeout-and-Multi-channels"><span class="nav-number">5.1.</span> <span class="nav-text">Timeout and Multi-channels</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Timed-Channel-Operations"><span class="nav-number">5.1.1.</span> <span class="nav-text">Timed Channel Operations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#First-in-First-Served"><span class="nav-number">5.1.2.</span> <span class="nav-text">First in First Served</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#First-in-First-Serve-with-Timeout"><span class="nav-number">5.1.3.</span> <span class="nav-text">First in First Serve with Timeout</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Timer"><span class="nav-number">5.2.</span> <span class="nav-text">Timer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#time-Ticker"><span class="nav-number">5.2.1.</span> <span class="nav-text">time.Ticker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#time-Tick"><span class="nav-number">5.2.2.</span> <span class="nav-text">time.Tick</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#time-Timer"><span class="nav-number">5.2.3.</span> <span class="nav-text">time.Timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#time-After"><span class="nav-number">5.2.4.</span> <span class="nav-text">time.After</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Some-Tricks"><span class="nav-number">5.3.</span> <span class="nav-text">Some Tricks</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Example-Search-Engine"><span class="nav-number">6.</span> <span class="nav-text">Example : Search Engine</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Example-Load-Balancer"><span class="nav-number">7.</span> <span class="nav-text">Example : Load Balancer</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Anyu Elin"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Anyu Elin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://anyu10.github.io/2022/12/15/Go-Concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Anyu Elin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Anyu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Go Concurrency | Anyu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go Concurrency
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-15 16:09:36" itemprop="dateCreated datePublished" datetime="2022-12-15T16:09:36+08:00">2022-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-12-17 21:37:53" itemprop="dateModified" datetime="2022-12-17T21:37:53+08:00">2022-12-17</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>13 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>Materials:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://vimeo.com/49718712">concurrency is not parallelism</a></li>
<li><a target="_blank" rel="noopener" href="https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view">rethinking classical concurrency patterns</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#pkg-overview">go sync package</a></li>
<li><a target="_blank" rel="noopener" href="https://go.dev/talks/2012/concurrency.slide#1">go concurrency patterns</a></li>
<li><a target="_blank" rel="noopener" href="https://blogtitle.github.io/categories/concurrency/">go advanced concurrency patterns</a></li>
</ul>
</blockquote>
<span id="more"></span>

<h1 id="Concurrency-Overview"><a href="#Concurrency-Overview" class="headerlink" title="Concurrency Overview"></a>Concurrency Overview</h1><p>Why concurrency?</p>
<ul>
<li>I&#x2F;O concurrency (network capacity, disk capacity)</li>
<li>Parallelism (multi-core machine)</li>
<li>Convenience (periodic work)</li>
</ul>
<p>Distinctions between concurrency and parallelism?</p>
<ul>
<li>Parallelism: simultaneous executing of programs, which may be correlated, or not be.</li>
<li>Concurrency:  composition of independent executing programs. <em>it’s not same as parallelism, although it enables parallelism</em>!</li>
</ul>
<p>Essence of concurrency:</p>
<ul>
<li>A complex problem can be broken down into several easy-to-understand components.</li>
<li>The pieces can be composed concurrently.</li>
<li>The result is <strong>scalable, correct and maybe parallel</strong>.</li>
</ul>
<h1 id="Go-Concurrency-Features"><a href="#Go-Concurrency-Features" class="headerlink" title="Go Concurrency Features"></a>Go Concurrency Features</h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>Goroutines</p>
<ul>
<li>It’s independently executing program with its own stack which can shrink and grow automatically</li>
<li>Goroutines are multiplexed dynamically onto threads as needed</li>
</ul>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>Communicating in go?</p>
<ul>
<li>Communicating in golang is through channels, it’s more like via file descriptor;</li>
<li>While in original CSP (Communicating Sequential Processing) is through process name, it’s more like via file</li>
</ul>
<p>Synchronization and Communication:</p>
<ul>
<li>Both send and receive are synchronous</li>
<li>A sender and receiver must both be ready to play their part in the communication. Otherwise we wait until they are.</li>
<li>Thus <strong>channels both communicate and synchronize</strong>.</li>
</ul>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>Buffered channels remove synchronization</p>
<p>It seems like Erlang’s mailbox</p>
<h2 id="The-Go-Approach"><a href="#The-Go-Approach" class="headerlink" title="The Go Approach"></a>The Go Approach</h2><p>Principle: <strong>Don’t communicate by sharing memory (i.e. mutex, locks), share memory by communicating.</strong></p>
<p>Low level concurrency: lock, mutex, condition, waitgroup, pool.</p>
<p>high level concurrency: goroutine, channel.</p>
<p><strong>garbage collector, closure, channel, goroutine, select</strong> – these features just stitch together to make concurrency in go powerful and expressive.</p>
<h1 id="Go-Concurrency-Patterns"><a href="#Go-Concurrency-Patterns" class="headerlink" title="Go Concurrency Patterns"></a>Go Concurrency Patterns</h1><h2 id="Generator-Function-Returns-a-Channel"><a href="#Generator-Function-Returns-a-Channel" class="headerlink" title="Generator : Function Returns a Channel"></a>Generator : Function Returns a Channel</h2><h3 id="Normal-Generator-Model"><a href="#Normal-Generator-Model" class="headerlink" title="Normal Generator Model"></a>Normal Generator Model</h3><p>Channels are first-class values (so as functions).</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := boring(<span class="string">&quot;boring!&quot;</span>) <span class="comment">// Function returning a channel.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;You say: %q\n&quot;</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;You&#x27;re boring; I&#x27;m leaving.&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span><span class="params">(msg <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123; <span class="comment">// Returns receive-only channel of strings.</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// We launch the goroutine from inside the function.</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">            c &lt;- fmt.Sprintf(<span class="string">&quot;%s %d&quot;</span>, msg, i)</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c <span class="comment">// Return the channel to the caller.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channels-as-a-Handle-on-a-Service"><a href="#Channels-as-a-Handle-on-a-Service" class="headerlink" title="Channels as a Handle on a Service"></a>Channels as a Handle on a Service</h3><p>Our boring function above returns a channel that lets us communicate with the boring service it provides.</p>
<p>We can have more instances of the service.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    joe := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    ann := boring(<span class="string">&quot;Ann&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(&lt;-joe)</span><br><span class="line">        fmt.Println(&lt;-ann)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Multiplexing-Fan-In"><a href="#Multiplexing-Fan-In" class="headerlink" title="Multiplexing (Fan-In)"></a>Multiplexing (Fan-In)</h3><p>These programs make Joe and Ann count in lockstep.  </p>
<p>We can instead use a fan-in function to let whosoever is ready talk.</p>
<p>It uses multi-channels as input and output a channel that receive multi channels’ output in different goroutines.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(input1, input2 &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; c &lt;- &lt;-input1 &#125; &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; c &lt;- &lt;-input2 &#125; &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := fanIn(boring(<span class="string">&quot;Joe&quot;</span>), boring(<span class="string">&quot;Ann&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(&lt;-c)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">input1 --&gt; channel1 --&gt; channel3</span><br><span class="line">input2 --&gt; channel2 --&gt; channel3</span><br><span class="line">channel3 --&gt; output</span><br></pre></td></tr></table></figure>

<h3 id="Restoring-Sequencing"><a href="#Restoring-Sequencing" class="headerlink" title="Restoring Sequencing"></a>Restoring Sequencing</h3><p>Fan-In is useful, but sometimes we want restoring the sequencing of two services.</p>
<p>Idea is <strong>sending a channel on a channel, making goroutines wait its turn</strong></p>
<p>So, first we define a struct that contains a channel for the reply</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    str <span class="type">string</span></span><br><span class="line">    wait <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For receiver who receives message:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    msg1 := &lt;-c</span><br><span class="line">    fmt.Println(msg1)</span><br><span class="line">    msg2 := &lt;-c</span><br><span class="line">    fmt.Println(msg2)</span><br><span class="line">    msg1.wait &lt;- <span class="literal">true</span>	<span class="comment">// unlock the sender which is stalled on &lt;-WaitForIt</span></span><br><span class="line">    msg2.wait &lt;- <span class="literal">true</span>	<span class="comment">// unlock the sender which is stalled on &lt;-WaitForIt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For Sender who sends message:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WaitForIt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> ExistUnsentMessage() &#123;</span><br><span class="line">    c &lt;- message&#123;<span class="string">&quot;message&quot;</span>, WaitForIt&#125;</span><br><span class="line">    time.Sleep(time.Duration(rand.Intn(<span class="number">2e3</span>)) * time.Millisecond)</span><br><span class="line">    &lt;-WaitForIt		<span class="comment">// get stalled when </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The technique above can restore the sequence of message: for the fact that Sender cannot send message twice to channel <code>c</code> because it will get stalled in <code>&lt;-WaitForIt</code> statement</p>
<blockquote>
<p>Assume sender1 sends on msg1, then it will get stalled on <code>&lt;-WaitForIt</code>, sender2 then can send on msg2, and also get stalled on <code>&lt;-WaitForIt</code>, and because sender1 sent first, so sender1 get stalled on <code>c &lt;- message&#123;...&#125;</code> first, so msg1 is still sender1</p>
</blockquote>
<blockquote>
<p> Assume sender1 sends on msg2, then sender2 sends on msg1, so the same situation as above  </p>
</blockquote>
<h2 id="Select-Statement"><a href="#Select-Statement" class="headerlink" title="Select Statement"></a>Select Statement</h2><h3 id="Fan-In-Using-Select"><a href="#Fan-In-Using-Select" class="headerlink" title="Fan-In Using Select"></a>Fan-In Using Select</h3><p>By using select statement, we only need to start one goroutine to fan-in channels.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(input1, input2 &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input1:  c &lt;- s</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input2:  c &lt;- s</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Timeout-Using-Select"><a href="#Timeout-Using-Select" class="headerlink" title="Timeout Using Select"></a>Timeout Using Select</h3><p>The time.After function returns a channel that blocks for the specified duration.<br>After the interval, the channel delivers the current time, once.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">            fmt.Println(<span class="string">&quot;You&#x27;re too slow.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Timeout-for-Whole-Conversation-Using-Select"><a href="#Timeout-for-Whole-Conversation-Using-Select" class="headerlink" title="Timeout for Whole Conversation Using Select"></a>Timeout for Whole Conversation Using Select</h3><p>Create the timer once, outside the loop, to time out the entire conversation.<br>While in the previous program, we had a timeout for each message.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    timeout := time.After(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">            fmt.Println(<span class="string">&quot;You talk too much.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Receive-on-quit-channel"><a href="#Receive-on-quit-channel" class="headerlink" title="Receive on quit channel"></a>Receive on quit channel</h3><p>When it want to quit a goroutine, send message on quit channel</p>
<p><code>case &lt;-quit</code> will do cleanup (like remove a temporary file), and tell back that it had quit (<strong>round-trip quit, in case that main goroutine quit before cleanup had been done</strong>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">c := boring(<span class="string">&quot;Joe&quot;</span>, quit)</span><br><span class="line"><span class="keyword">for</span> i := rand.Intn(<span class="number">10</span>); i &gt;= <span class="number">0</span>; i-- &#123; fmt.Println(&lt;-c) &#125;</span><br><span class="line">quit &lt;- <span class="string">&quot;Bye!&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Joe says: %q\n&quot;</span>, &lt;-quit)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- fmt.Sprintf(<span class="string">&quot;%s: %d&quot;</span>, msg, i):</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">    cleanup()</span><br><span class="line">    quit &lt;- <span class="string">&quot;See you!&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Daisy-Chain"><a href="#Daisy-Chain" class="headerlink" title="Daisy Chain"></a>Daisy Chain</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	routine1 --&gt; routine2 --left channel--&gt; routine3 --right channel--&gt; routine4 --&gt; routine5 --&gt; routine...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(left, right <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    left &lt;- <span class="number">1</span> + &lt;-right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="number">10000</span></span><br><span class="line">    leftmost := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    right := leftmost</span><br><span class="line">    left := leftmost</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        right = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> f(left, right)</span><br><span class="line">        left = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123; c &lt;- <span class="number">1</span> &#125;(right)</span><br><span class="line">    fmt.Println(&lt;-leftmost)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Rethinking-Classical-Concurrent-Patterns"><a href="#Rethinking-Classical-Concurrent-Patterns" class="headerlink" title="Rethinking Classical Concurrent Patterns"></a>Rethinking Classical Concurrent Patterns</h1><p>Two principles in go:</p>
<ol>
<li>Start goroutines when you have concurrent work</li>
<li>Share by communicating</li>
</ol>
<p>Other principles in go:</p>
<ol>
<li>Make concurrency internal detail.</li>
<li>Add concurrency on the caller side of the API.</li>
<li>Concurrency is not asynchronicity.</li>
</ol>
<h2 id="Asynchronous-API"><a href="#Asynchronous-API" class="headerlink" title="Asynchronous API"></a>Asynchronous API</h2><p>Concurrency is not asynchronicity.</p>
<p>An asynchronous API returns to the caller <strong>before its result is ready</strong>.</p>
<p>An asynchronous program is not necessarily concurrent: a program could call an asynchronous function and then sit idle waiting for the results.</p>
<p>There are several asynchronous patterns:</p>
<ul>
<li>asynchronous callback (deprecated)</li>
<li>future</li>
<li>producer-consumer queue</li>
</ul>
<h3 id="Asynchronous-Callback"><a href="#Asynchronous-Callback" class="headerlink" title="Asynchronous Callback"></a>Asynchronous Callback</h3><p>A callback is a simple function that’s passed as a value to another function, and will only be executed when the event happens.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch immediately returns, then fetches the item and </span></span><br><span class="line"><span class="comment">// invokes f in a goroutine when the item is available. </span></span><br><span class="line"><span class="comment">// If the item does not exist,</span></span><br><span class="line"><span class="comment">// Fetch invokes f on the zero Item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>, f <span class="keyword">func</span>(Item)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        […]</span><br><span class="line">        f(item)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>In the Future pattern, instead of returning the result, the function returns a proxy object that allows the caller to wait for the result at some later point.</p>
<p>The Go analogue to a <strong>Future</strong> is a <strong>single-element buffered channel</strong>.</p>
<p>To use Futures for concurrency, the caller must <strong>set up concurrent work before retrieving results</strong>.</p>
<p>If they retrieve the results too early, the program executes <em>sequentially instead of concurrently</em>.</p>
<p>the channel pattern seems to be more common than the function-based alternative</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: API, channel-based</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch immediately returns a channel, then fetches </span></span><br><span class="line"><span class="comment">// the requested item and sends it on the channel. </span></span><br><span class="line"><span class="comment">// If the item does not exist,</span></span><br><span class="line"><span class="comment">// Fetch closes the channel without sending.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        […]</span><br><span class="line">        c &lt;- item</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: The precise way, function-based</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">()</span></span> Item) &#123;</span><br><span class="line">    item := <span class="built_in">new</span>(Item)</span><br><span class="line">    ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    […]</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> Item &#123;</span><br><span class="line">        &lt;-ready</span><br><span class="line">        <span class="keyword">return</span> *item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: caller side</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Right</span></span><br><span class="line">a := Fetch(<span class="string">&quot;a&quot;</span>) </span><br><span class="line">b := Fetch(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">consume(&lt;-a, &lt;-b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// False</span></span><br><span class="line">a := &lt;-Fetch(<span class="string">&quot;a&quot;</span>) <span class="comment">// routine get stalled on this line, so will lose concurrency</span></span><br><span class="line">b := &lt;-Fetch(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">consume(a, b)</span><br></pre></td></tr></table></figure>

<h3 id="Producer–Consumer-Queue"><a href="#Producer–Consumer-Queue" class="headerlink" title="Producer–Consumer Queue"></a>Producer–Consumer Queue</h3><p>A producer–consumer queue also returns a channel, but the <strong>channel receives any number of results and is typically unbuffered</strong>.</p>
<p>A channel fed by one goroutine and read by another <strong>acts as a queue</strong>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Glob finds all items with names matching pattern</span></span><br><span class="line"><span class="comment">// and sends them on the returned channel.</span></span><br><span class="line"><span class="comment">// It closes the channel when all items have been sent. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(pattern <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">        <span class="keyword">for</span> […] &#123;</span><br><span class="line">            […]</span><br><span class="line">            c &lt;- item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Producer-Consumer Queue: caller side</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> Glob(<span class="string">&quot;[ab]*&quot;</span>) &#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Analysis-of-Asynchronous-API"><a href="#Analysis-of-Asynchronous-API" class="headerlink" title="Analysis of Asynchronous API"></a>Analysis of Asynchronous API</h3><p>Classical Benefit:</p>
<ul>
<li>Responsiveness : Avoid blocking UI and network threads<ul>
<li>Most other languages don’t multiplex across OS threads, and kernel schedulers can be unpredictable. So some popular languages and frameworks keep all of the UI or network logic on a single thread. If that thread makes a call that blocks for too long, the UI becomes choppy, or network latency spikes.</li>
<li>Since calls to asynchronous APIs by definition don’t block, they help to keep single-threaded programs responsive.</li>
<li>For go, goroutines are managed by go-runtime, not by kernel scheduler, so the first benefit doesn’t apply to go.</li>
</ul>
</li>
<li>Efficiency : Reduce  idle threads<ul>
<li>Threads are expensive</li>
<li>Languages that don’t multiplex over threads can use asynchronous APIs to keep threads busy, reducing the total number of threads — and context-switches</li>
<li>For go, goroutine is lightweight, it doesn’t spend too much on context switch.</li>
</ul>
</li>
<li>Efficiency : Reclaim stack frames<ul>
<li>Save frame space for other purpose.</li>
<li>For go, runtime resize and reallocate stack as needed. Besides, <strong>the storage location chosen by implementation is irrelevant to the semantics of the language</strong>.</li>
</ul>
</li>
<li>Concurrency : Initiate concurrent work<ul>
<li>Can be important for network RPCs</li>
</ul>
</li>
</ul>
<p>Classical Problems:</p>
<ul>
<li>Caller-Side Ambiguity</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	kind <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = <span class="keyword">map</span>[<span class="type">string</span>]Item&#123;</span><br><span class="line">	<span class="string">&quot;a&quot;</span>: Item&#123;<span class="string">&quot;gopher&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;b&quot;</span>: Item&#123;<span class="string">&quot;rabbit&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSlowThing</span><span class="params">()</span></span> &#123; time.Sleep(<span class="number">10</span> * time.Millisecond) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(a, b Item)</span></span> &#123;</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		item := items[name]</span><br><span class="line">		c &lt;- item</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glob finds all items with names matching pattern</span></span><br><span class="line"><span class="comment">// and sends them on the returned channel.</span></span><br><span class="line"><span class="comment">// It closes the channel when all items have been sent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(pattern <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">		<span class="keyword">for</span> name, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">			<span class="keyword">if</span> ok, _ := filepath.Match(pattern, name); !ok &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			c &lt;- item</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> Glob(<span class="string">&quot;[ab]*&quot;</span>) &#123;</span><br><span class="line">		fmt.Println(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Condition-Variable"><a href="#Condition-Variable" class="headerlink" title="Condition Variable"></a>Condition Variable</h2><h3 id="Condition-Variable-Analysis"><a href="#Condition-Variable-Analysis" class="headerlink" title="Condition Variable Analysis"></a>Condition Variable Analysis</h3><p>Problems:</p>
<ul>
<li>Spurious wakeups: Signal some or the threads are hard.</li>
<li>Forgotten signals: Forget to signal some threads when programming.</li>
<li>Starvation: long-running threads will get starved.</li>
<li>Unresponsive cancellation: While waiting for a condition, it may miss other event.</li>
</ul>
<p>Fundamentally, <strong>condition variables rely on communicating by sharing memory</strong>: they signal that a change has occurred, but leave it up to the signalled goroutine to check other shared variables to figure out what. On the other hand, the <strong>Go approach is to share by communicating</strong>.</p>
<h3 id="Semaphore-Sharing-by-Communicating"><a href="#Semaphore-Sharing-by-Communicating" class="headerlink" title="Semaphore : Sharing by Communicating"></a>Semaphore : Sharing by Communicating</h3><p>Go Benefits:</p>
<ul>
<li>Indicate the existence of new data.</li>
<li>Share data by communicating data.</li>
<li>Share things by communicating things.</li>
<li>Metadata are data too!</li>
<li>Mark transitions: mark that a broadcast by close a channel.</li>
</ul>
<p>Buffered channels –&gt; Semaphore pattern</p>
<h2 id="Worker-Pool"><a href="#Worker-Pool" class="headerlink" title="Worker Pool"></a>Worker Pool</h2><p>Benefits:</p>
<ul>
<li>Distribute work across threads<ul>
<li>Threads are heavyweight, worker pool allow reusing threads</li>
<li>Goroutines are lightweight, so it doesn’t apply to go</li>
</ul>
</li>
<li>Limit work in flight</li>
</ul>
<p>Principles:</p>
<ul>
<li><p>Start your goroutine only when you have concurrent work to do now</p>
</li>
<li><p>WaitGroup is enough –&gt; semaphore patterns</p>
</li>
</ul>
<h1 id="Go-Advanced-Concurrency-Patterns"><a href="#Go-Advanced-Concurrency-Patterns" class="headerlink" title="Go Advanced Concurrency Patterns"></a>Go Advanced Concurrency Patterns</h1><h2 id="Timeout-and-Multi-channels"><a href="#Timeout-and-Multi-channels" class="headerlink" title="Timeout and Multi-channels"></a>Timeout and Multi-channels</h2><h3 id="Timed-Channel-Operations"><a href="#Timed-Channel-Operations" class="headerlink" title="Timed Channel Operations"></a>Timed Channel Operations</h3><p>Keep trying doing something, but drop the ball when timeout</p>
<ul>
<li><code>context</code> implementation (more idiomatic)</li>
<li><code>time</code> implementation</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// context impl.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChanTimedContext</span><span class="params">(ctx context.Context, d time.Duration, message Type, c <span class="keyword">chan</span>&lt;- Type)</span></span> (written <span class="type">bool</span>) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(ctx, d)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// time impl.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChanTimedTimer</span><span class="params">(d time.Duration, message Type, c <span class="keyword">chan</span>&lt;- Type)</span></span> (written <span class="type">bool</span>) &#123;</span><br><span class="line">	t := time.NewTimer(d)</span><br><span class="line">	<span class="keyword">defer</span> t.Stop()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="First-in-First-Served"><a href="#First-in-First-Served" class="headerlink" title="First in First Served"></a>First in First Served</h3><p>Sometimes you want to write the same message to many channels, writing to whichever is available first, but <strong>never writing the same message twice</strong> on the same channel.</p>
<ul>
<li>Use <code>select</code> statement to achieve so.</li>
<li>Use goroutines and waits</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// select statement</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServeSelect</span><span class="params">(message Type, a, b <span class="keyword">chan</span> Type)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> a &lt;- message:</span><br><span class="line">            a = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> b &lt;- message:</span><br><span class="line">            b = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// goroutine</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServeGoroutine</span><span class="params">(message Type, a, b <span class="keyword">chan</span> Type)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a &lt;- message; wg.Done() &#125; ()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; b &lt;- message; wg.Done() &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this case performance might matter, and at the time of writing the solution that spawns goroutines takes almost 4 times more than the one with <code>select</code>.</p>
<p>If the amount of channels is not known at compile time, the first solution becomes trickier, but it is still possible, while the second one stays basically unchanged.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServedGoroutinesVariadic</span><span class="params">(message Type, chs ...<span class="keyword">chan</span>&lt;- Type)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(chs))</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> chs &#123;</span><br><span class="line">		c := c</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- message; wg.Done() &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServedSelectVariadic</span><span class="params">(message Type, chs ...<span class="keyword">chan</span>&lt;- Type)</span></span> &#123;</span><br><span class="line">	cases := <span class="built_in">make</span>([]reflect.SelectCase, <span class="built_in">len</span>(chs))</span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> chs &#123;</span><br><span class="line">		cases[i] = reflect.SelectCase&#123;</span><br><span class="line">			Dir:  reflect.SelectSend,</span><br><span class="line">			Chan: reflect.ValueOf(ch),</span><br><span class="line">			Send: reflect.ValueOf(message),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(chs); i++ &#123;</span><br><span class="line">		chosen, _, _ := reflect.Select(cases)</span><br><span class="line">		cases[chosen].Chan = reflect.ValueOf(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The solution using reflection is almost two orders of magnitude slower than the one with goroutines and unreadable.</p>
<h3 id="First-in-First-Serve-with-Timeout"><a href="#First-in-First-Serve-with-Timeout" class="headerlink" title="First in First Serve with Timeout"></a>First in First Serve with Timeout</h3><p>There are two solutions in case you want to try a several sends and abort if it takes too long.</p>
<ul>
<li><code>time + select</code> : better if account of channels are known at compile time.</li>
<li><code>context + go</code> : channels are unknown at compile time.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// time + select</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChansTimedTimerSelect</span><span class="params">(d time.Duration, message Type, a, b <span class="keyword">chan</span> Type)</span></span> (written <span class="type">int</span>) &#123;</span><br><span class="line">	t := time.NewTimer(d)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> a &lt;- message:</span><br><span class="line">			a = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> b &lt;- message:</span><br><span class="line">			b = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t.Stop()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// context + go</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChansTimedContextGoroutines</span><span class="params">(ctx context.Context, d time.Duration, message Type, ch ...<span class="keyword">chan</span> Type)</span></span> (written <span class="type">int</span>) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(ctx, d)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		wr <span class="type">int32</span></span><br><span class="line">		wg sync.WaitGroup</span><br><span class="line">	)</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(ch))</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		c := c</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">				atomic.AddInt32(&amp;wr, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(wr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><h3 id="time-Ticker"><a href="#time-Ticker" class="headerlink" title="time.Ticker"></a>time.Ticker</h3><p>NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. </p>
<p>The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. </p>
<p>Stop the ticker to release associated resources.</p>
<p>Some caveats:</p>
<ul>
<li><strong>Sends will drop all unread values if <code>C</code> already has one message in it</strong>.</li>
<li>It <strong>must be stopped</strong>: the GC will not collect it otherwise.</li>
<li>Setting <code>C</code> is useless: <strong>messages will still be sent on the original channel</strong>.</li>
</ul>
<h3 id="time-Tick"><a href="#time-Tick" class="headerlink" title="time.Tick"></a>time.Tick</h3><p>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only.</p>
<p>But this is something that should never be used unless you plan to carry the returned <code>chan</code> around and keep using it for the <strong>entire lifetime of the program</strong>.</p>
<p><strong>Because the underlying Ticker cannot be recovered by the garbage collector; it “leaks”</strong>.</p>
<h3 id="time-Timer"><a href="#time-Timer" class="headerlink" title="time.Timer"></a>time.Timer</h3><p>The Timer type represents a single event. <em>When the Timer expires, the current time will be sent on C</em>, unless the Timer was created by AfterFunc. <em><strong>A Timer must be created with NewTimer or AfterFunc</strong></em>.</p>
<p><code>Reset</code> changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.</p>
<p><em><strong>For a Timer created with NewTimer, Reset should be invoked only on stopped or expired timers with drained channels</strong></em>.</p>
<p>Some caveat:</p>
<ul>
<li><code>C</code> cannot be set by user although it is exported.</li>
<li><code>Timer</code> returned by <code>AfterFunc</code> doesn’t use <code>C</code> at all.</li>
<li><code>C</code> will not be closed even after Stop the Timer</li>
<li><code>Stop</code> is safe only after <code>New</code> and <code>Reset</code>.</li>
<li><code>Reset</code> is only valid after <code>Stop</code>.</li>
<li>Received value is valid only if channel is drained after each <code>Stop</code>.</li>
<li>The channel should be drained if and only if the channel has not been read yet.</li>
</ul>
<p><code>time.Afterfunc</code>:</p>
<ul>
<li>AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that <strong>can be used to cancel the call using its Stop method</strong>.</li>
<li>when calling <code>Stop</code>, if <code>false</code> is returned, it means that stopping failed and the function was already started.</li>
</ul>
<p><code>time.NewTimer</code>:</p>
<ul>
<li><p>NewTimer creates a new Timer that will send the current time on its channel after at least duration d.</p>
</li>
<li><p>This means that there is no way to construct a valid <code>Timer</code> without starting it. If you need to construct one for future re-use, you either do it lazily or you have to create and stop it, which can be done with this code:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t := time.NewTimer(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> !t.Stop() &#123;</span><br><span class="line">	&lt;-t.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>time.Stop</code>:</p>
<ul>
<li><p>Stop prevents the Timer from firing. It returns <strong>true</strong> if the <strong>call stops the timer</strong>, <strong>false</strong> if the timer has <em><strong>already expired</strong></em> <strong>or</strong> <em><strong>been stopped</strong></em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//* not thread safe</span></span><br><span class="line"><span class="keyword">if</span> !t.Stop() &#123;</span><br><span class="line">	&lt;-t.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>time.Reset</code>:</p>
<ul>
<li>Note that it is not possible to use Reset’s return value correctly, as there is a race condition between draining the channel and the new timer expiring. <strong>Reset should always be invoked on stopped or expired channels</strong>.</li>
<li>You cannot use <code>Stop</code> nor <code>Reset</code> concurrently <em>with other receives from the channel</em>, and in order for the value sent on <code>C</code> to be valid, <strong><code>C</code> should be drained exactly once before each <code>Reset</code></strong>.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Timer API</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">	C &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span></span>) *Timer</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span></span> *Timer</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Timer)</span></span> Stop(<span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Timer)</span></span> Reset(d Duration) <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_images\image-20221216234927956.png" alt="image-20221216234927956"></p>
<h3 id="time-After"><a href="#time-After" class="headerlink" title="time.After"></a>time.After</h3><p>This is basically the same concept of <code>Tick</code> but instead of hiding a <code>Ticker</code>, hides a <code>Timer</code>. This is slightly better because once the timer will fire, it will be collected. Please note that timers use 1-buffered channels, so they can fire even if no one is receiving.</p>
<p>But if you care about performance and you want to be able to cancel the call, you should not use <code>After</code>.</p>
<h2 id="Some-Tricks"><a href="#Some-Tricks" class="headerlink" title="Some Tricks"></a>Some Tricks</h2><ul>
<li>For-select loop</li>
<li>Service channel, reply channels (channel of channel)</li>
<li><code>nil</code> channel for select cases</li>
</ul>
<h1 id="Example-Search-Engine"><a href="#Example-Search-Engine" class="headerlink" title="Example : Search Engine"></a>Example : Search Engine</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	res <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Search <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FakeSearch</span><span class="params">(kind <span class="type">string</span>)</span></span> Search &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line">		<span class="keyword">return</span> Result&#123;fmt.Sprintf(<span class="string">&quot;%v returns %v&quot;</span>, kind, query)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	Web    = FakeSearch(<span class="string">&quot;Web&quot;</span>)</span><br><span class="line">	Image  = FakeSearch(<span class="string">&quot;Image&quot;</span>)</span><br><span class="line">	Video  = FakeSearch(<span class="string">&quot;Video&quot;</span>)</span><br><span class="line">	Web1   = FakeSearch(<span class="string">&quot;Web&quot;</span>)</span><br><span class="line">	Image1 = FakeSearch(<span class="string">&quot;Image&quot;</span>)</span><br><span class="line">	Video1 = FakeSearch(<span class="string">&quot;Video&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Generator</span><span class="params">(query <span class="type">string</span>)</span></span> <span class="keyword">chan</span> Result &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Web(query) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Image(query) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Video(query) &#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">timeout edition of google search engine</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoogleTimeout</span><span class="params">(query <span class="type">string</span>)</span></span> []Result &#123;</span><br><span class="line">	results := <span class="built_in">make</span>([]Result, <span class="number">0</span>)</span><br><span class="line">	ch := Generator(query)</span><br><span class="line">	timeout := time.After(<span class="number">80</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">			results = <span class="built_in">append</span>(results, res)</span><br><span class="line">			fmt.Println(res)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">			<span class="keyword">return</span> results</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchWithReplicas</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">for</span> _, search := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(search <span class="keyword">func</span>(query <span class="type">string</span>)</span></span> Result) &#123;</span><br><span class="line">			ch &lt;- search(query)</span><br><span class="line">		&#125;(search)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Google</span><span class="params">(query <span class="type">string</span>)</span></span> []Result &#123;</span><br><span class="line">	<span class="keyword">var</span> results []Result</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Web, Web1) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Image, Image1) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Video, Video1) &#125;()</span><br><span class="line">	timeout := time.After(time.Duration(<span class="number">80</span>) * time.Millisecond)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">			results = <span class="built_in">append</span>(results, res)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">			<span class="comment">// return results</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	start := time.Now()</span><br><span class="line">	results := Google(<span class="string">&quot;who are you?&quot;</span>)</span><br><span class="line">	elapsed := time.Since(start)</span><br><span class="line">	fmt.Println(elapsed)</span><br><span class="line">	fmt.Println(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Example-Load-Balancer"><a href="#Example-Load-Balancer" class="headerlink" title="Example : Load Balancer"></a>Example : Load Balancer</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">this is a pseudo code for load balancer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Requester</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> <span class="comment">// the operation to perform</span></span><br><span class="line">	c  <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// the channel to return results</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requester</span><span class="params">(works <span class="keyword">chan</span> Request)</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(<span class="number">80</span>)) * time.Millisecond) <span class="comment">//* to emulate load time</span></span><br><span class="line">		works &lt;- Request&#123;workFn, c&#125;</span><br><span class="line">		result := &lt;-c</span><br><span class="line">		futherProcess(result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Worker</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	requests <span class="keyword">chan</span> Request</span><br><span class="line">	pending  <span class="type">int</span></span><br><span class="line">	index    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> work(done <span class="keyword">chan</span> *Worker) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		req := &lt;-w.requests</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(req Request)</span></span> &#123;</span><br><span class="line">			req.c &lt;- req.fn()</span><br><span class="line">			done &lt;- w</span><br><span class="line">		&#125;(req)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Balacer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool []*Worker</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Balancer <span class="keyword">struct</span> &#123;</span><br><span class="line">	pool Pool</span><br><span class="line">	done <span class="keyword">chan</span> *Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> balancer(work <span class="keyword">chan</span> Request) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> req := &lt;-work:</span><br><span class="line">			b.dispatch(req)</span><br><span class="line">		<span class="keyword">case</span> w := &lt;-b.done:</span><br><span class="line">			b.complete(w)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> dispatch(req Request) &#123;</span><br><span class="line">	w := heap.Pop(&amp;b.pool).(*Worker)</span><br><span class="line">	w.requests &lt;- req</span><br><span class="line">	w.pending++</span><br><span class="line">	heap.Push(&amp;b.pool, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> complete(w *Worker) &#123;</span><br><span class="line">	w.pending--</span><br><span class="line">	heap.Remove(&amp;b.pool, w.index)</span><br><span class="line">	heap.Push(&amp;b.pool, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> poolSize = <span class="number">30</span></span><br><span class="line">	<span class="keyword">var</span> requests <span class="keyword">chan</span> Request = <span class="built_in">make</span>(<span class="keyword">chan</span> Request)</span><br><span class="line">	<span class="keyword">go</span> requester(requests) <span class="comment">//* load request and generate work</span></span><br><span class="line">	<span class="keyword">var</span> b Balancer = Balancer&#123;<span class="built_in">make</span>(Pool, <span class="number">0</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> *Worker)&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; poolSize; i++ &#123;</span><br><span class="line">		b.pool = <span class="built_in">append</span>(b.pool, &amp;Worker&#123;requests, <span class="number">0</span>, i&#125;)</span><br><span class="line">		<span class="keyword">go</span> b.pool[i].work(b.done)</span><br><span class="line">	&#125; <span class="comment">//* generate workers</span></span><br><span class="line"></span><br><span class="line">	b.balancer(requests) <span class="comment">//* do load balance things</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
              <a href="/tags/Concurrency/" rel="tag"><i class="fa fa-tag"></i> Concurrency</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/11/17/RISC-V/" rel="prev" title="RISC-V">
                  <i class="fa fa-chevron-left"></i> RISC-V
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/12/15/MapReduce/" rel="next" title="MapReduce">
                  MapReduce <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Anyu Elin</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Word count total: </span>
    <span title="Word count total">10k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">35 mins.</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
