<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"anyu10.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Slice扩容规则在Go 1.18以前: 当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的 1.25 倍。 Go 1.18及以后: 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的 2 倍；原 slice 容量大于 256，新slice 容量 newc">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang">
<meta property="og:url" content="http://anyu10.github.io/2023/03/02/Golang/index.html">
<meta property="og:site_name" content="Anyu">
<meta property="og:description" content="Slice扩容规则在Go 1.18以前: 当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的 1.25 倍。 Go 1.18及以后: 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的 2 倍；原 slice 容量大于 256，新slice 容量 newc">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://golang.design/go-questions/map/assets/2.png">
<meta property="og:image" content="https://golang.design/go-questions/map/assets/6.png">
<meta property="og:image" content="https://golang.design/go-questions/interface/assets/0.png">
<meta property="og:image" content="https://golang.design/go-questions/stdlib/context/assets/0.png">
<meta property="og:image" content="https://golang.design/go-questions/stdlib/context/assets/2.png">
<meta property="og:image" content="https://golang.design/go-questions/stdlib/context/assets/4.png">
<meta property="og:image" content="https://golang.design/go-questions/stdlib/reflect/assets/6.png">
<meta property="og:image" content="https://golang.design/go-questions/stdlib/reflect/assets/7.png">
<meta property="og:image" content="https://golang.design/go-questions/stdlib/unsafe/assets/0.png">
<meta property="article:published_time" content="2023-03-02T07:10:03.000Z">
<meta property="article:modified_time" content="2023-03-07T15:41:48.024Z">
<meta property="article:author" content="Anyu Elin">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://golang.design/go-questions/map/assets/2.png">


<link rel="canonical" href="http://anyu10.github.io/2023/03/02/Golang/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://anyu10.github.io/2023/03/02/Golang/","path":"2023/03/02/Golang/","title":"Golang"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Golang | Anyu</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Anyu</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Slice"><span class="nav-number">1.</span> <span class="nav-text">Slice</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99"><span class="nav-number">1.1.</span> <span class="nav-text">扩容规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map"><span class="nav-number">2.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.1.</span> <span class="nav-text">Map 的数据结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.1.</span> <span class="nav-text">一般方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-hmap-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.2.</span> <span class="nav-text">Go hmap 数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.3.</span> <span class="nav-text">Map 的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash-%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">2.1.4.</span> <span class="nav-text">Hash 函数的选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.2.</span> <span class="nav-text">Map 的操作设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Key-%E7%9A%84%E5%AF%BB%E6%89%BE"><span class="nav-number">2.2.1.</span> <span class="nav-text">Key 的寻找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Get-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">Get 的两种实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.3.</span> <span class="nav-text">遍历过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.4.</span> <span class="nav-text">赋值过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.5.</span> <span class="nav-text">删除过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.6.</span> <span class="nav-text">扩容过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-number">2.3.</span> <span class="nav-text">Map 的特殊情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#float%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BAmap%E7%9A%84key"><span class="nav-number">2.3.1.</span> <span class="nav-text">float类型作为map的key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E9%81%8D%E5%8E%86%E8%BE%B9%E5%88%A0%E9%99%A4"><span class="nav-number">2.3.2.</span> <span class="nav-text">边遍历边删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%B3%95%E5%AF%B9map%E5%85%83%E7%B4%A0%E5%8F%96%E5%9C%B0%E5%9D%80"><span class="nav-number">2.3.3.</span> <span class="nav-text">无法对map元素取地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAmap%E7%9B%B8%E7%AD%89"><span class="nav-number">2.3.4.</span> <span class="nav-text">比较两个map相等</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Interface"><span class="nav-number">3.</span> <span class="nav-text">Interface</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Duck-Typing"><span class="nav-number">3.1.</span> <span class="nav-text">Duck Typing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%BC-x2F-%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%AC%E8%B4%A8"><span class="nav-number">3.2.</span> <span class="nav-text">值&#x2F;指针接收者和类型本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iface-%E5%92%8C-eface"><span class="nav-number">3.3.</span> <span class="nav-text">iface 和 eface</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#iface"><span class="nav-number">3.3.1.</span> <span class="nav-text">iface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eface"><span class="nav-number">3.3.2.</span> <span class="nav-text">eface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iface-x2F-eface-%E7%9A%84%E7%BB%84%E8%A3%85"><span class="nav-number">3.3.3.</span> <span class="nav-text">iface&#x2F;eface 的组装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.3.4.</span> <span class="nav-text">_type 结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E5%80%BC"><span class="nav-number">3.4.</span> <span class="nav-text">接口的动态类型和动态值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%A3%80%E6%9F%A5%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.5.</span> <span class="nav-text">编译器检查类型是否实现接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-number">3.6.</span> <span class="nav-text">类型转换和类型断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.6.1.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-number">3.6.2.</span> <span class="nav-text">类型断言</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">3.7.</span> <span class="nav-text">接口转换的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">3.8.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Channel"><span class="nav-number">4.</span> <span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CSP"><span class="nav-number">4.1.</span> <span class="nav-text">CSP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.</span> <span class="nav-text">Channel 数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel-%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.</span> <span class="nav-text">Channel 的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">4.3.1.</span> <span class="nav-text">Channel 的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E7%9A%84%E5%8F%91%E9%80%81"><span class="nav-number">4.3.2.</span> <span class="nav-text">Channel 的发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E7%9A%84%E6%8E%A5%E6%94%B6"><span class="nav-number">4.3.3.</span> <span class="nav-text">Channel 的接收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%8E%A5%E6%94%B6%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95-%E5%A6%82%E6%9E%9C%E4%BB%8E%E4%B8%80%E4%B8%AA-nil-channel-%E4%B8%AD%E6%8E%A5%E5%8F%97-%E4%B8%8D%E9%98%BB%E5%A1%9E%E6%83%85%E5%86%B5%E8%BF%94%E5%9B%9E-false-false-%E5%A6%82%E6%9E%9C%E9%98%BB%E5%A1%9E-%E5%88%99%E8%B0%83%E7%94%A8-gopark-%E5%87%BD%E6%95%B0%E5%B0%86%E5%BD%93%E5%89%8D%E7%9A%84-goroutine-%E6%8C%82%E8%B5%B7-%E5%9C%A8%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%83%85%E5%86%B5%E4%B8%8B-%E5%BF%AB%E9%80%9F%E6%A3%80%E6%B5%8B%E5%88%B0%E5%A4%B1%E8%B4%A5-%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E-false-false-%E5%A4%B1%E8%B4%A5%E6%83%85%E5%86%B5%E5%8C%85%E5%90%AB"><span class="nav-number">4.4.</span> <span class="nav-text">检查接收是否合法- 如果从一个 nil channel 中接受, 不阻塞情况返回(false, false), 如果阻塞, 则调用 gopark 函数将当前的 goroutine 挂起.- 在非阻塞情况下, 快速检测到失败, 直接返回(false, false)  - 失败情况包含: </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E7%9A%84%E5%85%B3%E9%97%AD"><span class="nav-number">4.4.1.</span> <span class="nav-text">Channel 的关闭</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">4.5.</span> <span class="nav-text">Channel 的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E7%9A%84%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD"><span class="nav-number">4.5.1.</span> <span class="nav-text">Channel 的优雅关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">4.5.2.</span> <span class="nav-text">Channel 传递数据的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E5%BC%95%E5%8F%91-Goroutine-%E6%B3%84%E9%9C%B2"><span class="nav-number">4.5.3.</span> <span class="nav-text">Channel 引发 Goroutine 泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E4%B8%AD%E7%9A%84-happen-before"><span class="nav-number">4.5.4.</span> <span class="nav-text">Channel 中的 happen-before</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.6.</span> <span class="nav-text">Channel 的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="nav-number">4.6.1.</span> <span class="nav-text">停止信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%AE%9A%E6%97%B6"><span class="nav-number">4.6.2.</span> <span class="nav-text">任务定时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E8%80%A6%E7%94%9F%E4%BA%A7%E6%96%B9%E5%92%8C%E6%B6%88%E8%B4%B9%E6%96%B9"><span class="nav-number">4.6.3.</span> <span class="nav-text">解耦生产方和消费方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0"><span class="nav-number">4.6.4.</span> <span class="nav-text">控制并发数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">5.</span> <span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Context"><span class="nav-number">5.1.</span> <span class="nav-text">Context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">Context 的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.3.</span> <span class="nav-text">Context 的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="nav-number">5.3.1.</span> <span class="nav-text">使用建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E5%85%B1%E4%BA%AB%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">5.3.2.</span> <span class="nav-text">传递共享的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E6%B6%88-goroutine"><span class="nav-number">5.3.3.</span> <span class="nav-text">取消 goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2-goroutine-%E6%B3%84%E9%9C%B2"><span class="nav-number">5.3.4.</span> <span class="nav-text">防止 goroutine 泄露</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#context-Value-%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="nav-number">5.4.</span> <span class="nav-text">context.Value 查找过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#valueCtx-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.1.</span> <span class="nav-text">valueCtx 的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#valueCtx-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">5.4.2.</span> <span class="nav-text">valueCtx 的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#value-%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">5.4.3.</span> <span class="nav-text">value 的查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E5%8C%85%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.5.</span> <span class="nav-text">Context 包设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Context-%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.5.1.</span> <span class="nav-text">Context 中的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context-%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.5.2.</span> <span class="nav-text">Context 中的结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reflect"><span class="nav-number">5.6.</span> <span class="nav-text">Reflect</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect-%E7%AE%80%E4%BB%8B"><span class="nav-number">5.6.1.</span> <span class="nav-text">Reflect 简介</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.7.</span> <span class="nav-text">Go 语言反射实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type-%E5%92%8C-interface"><span class="nav-number">5.7.1.</span> <span class="nav-text">type 和 interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reflect-Type"><span class="nav-number">5.7.2.</span> <span class="nav-text">reflect.Type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reflect-Value"><span class="nav-number">5.7.3.</span> <span class="nav-text">reflect.Value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%89%E5%AE%9A%E5%BE%8B"><span class="nav-number">5.7.4.</span> <span class="nav-text">反射三定律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reflect-DeepEqual"><span class="nav-number">5.7.5.</span> <span class="nav-text">reflect.DeepEqual()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsafe"><span class="nav-number">5.8.</span> <span class="nav-text">unsafe</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E6%8C%87%E9%92%88%E5%92%8C-unsafe"><span class="nav-number">5.8.1.</span> <span class="nav-text">Go 指针和 unsafe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unsafe-%E4%BF%AE%E6%94%B9%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="nav-number">5.8.2.</span> <span class="nav-text">unsafe 修改私有成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C-byte-%E5%88%87%E7%89%87%E4%B9%8B%E9%97%B4%E7%9A%84%E6%97%A0%E6%8B%B7%E8%B4%9D%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.8.3.</span> <span class="nav-text">字符串和 byte 切片之间的无拷贝转换</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Anyu Elin"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Anyu Elin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://anyu10.github.io/2023/03/02/Golang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Anyu Elin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Anyu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Golang | Anyu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Golang
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-02 15:10:03" itemprop="dateCreated datePublished" datetime="2023-03-02T15:10:03+08:00">2023-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-03-07 23:41:48" itemprop="dateModified" datetime="2023-03-07T23:41:48+08:00">2023-03-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:06</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><h2 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h2><p>在Go 1.18以前: 当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的 <code>1.25</code> 倍。</p>
<p>Go 1.18及以后: 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的 <code>2</code> 倍；原 slice 容量大于 <code>256</code>，新slice 容量 <code>newcap = oldcap+(oldcap+3*256)/4</code> (threadhold &#x3D; 256)</p>
<p><strong>其中最后会对内存进行对齐操作</strong></p>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.18 src/runtime/slice.go:178</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                <span class="comment">// Transition from growing 2x for small slices</span></span><br><span class="line">				<span class="comment">// to growing 1.25x for large slices. This formula</span></span><br><span class="line">				<span class="comment">// gives a smooth-ish transition between the two.</span></span><br><span class="line">				newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">    </span><br><span class="line">	capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">	newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _MaxSmallSize = <span class="number">32768</span></span><br><span class="line"><span class="keyword">const</span> smallSizeMax = <span class="number">1024</span></span><br><span class="line"><span class="keyword">const</span> smallSizeDiv = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">roundupsize</span><span class="params">(size <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> size &lt; _MaxSmallSize &#123;</span><br><span class="line">		<span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">uintptr</span>(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">uintptr</span>(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> size+_PageSize &lt; size &#123;</span><br><span class="line">		<span class="keyword">return</span> size</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> alignUp(size, _PageSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Map-的数据结构设计"><a href="#Map-的数据结构设计" class="headerlink" title="Map 的数据结构设计"></a>Map 的数据结构设计</h2><h3 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h3><p>map 设计的关键点: map 是由 <code>key-value</code> 对组成的；<code>key</code> 只会出现一次。</p>
<ul>
<li>Hash Table 实现<ul>
<li>Chaining Scheme 或 Open Addressing Scheme 实现 Hash Table</li>
<li>平均操作时间 O(1), 最差时间复杂度 O(n)</li>
</ul>
</li>
<li>Search Tree 实现<ul>
<li>AVL tree 或 Red-Black Tree 实现 Search Tree</li>
<li>平均操作时间&#x2F;最差时间复杂度均为 O(log n)</li>
</ul>
</li>
</ul>
<h3 id="Go-hmap-数据结构"><a href="#Go-hmap-数据结构" class="headerlink" title="Go hmap 数据结构"></a>Go hmap 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 元素个数，调用 len(map) 时，直接返回此值</span></span><br><span class="line">	count     <span class="type">int</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// buckets 的对数 log_2</span></span><br><span class="line">	B         <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// overflow 的 bucket 近似数</span></span><br><span class="line">	noverflow <span class="type">uint16</span></span><br><span class="line">	<span class="comment">// 计算 key 的哈希的时候会传入哈希函数</span></span><br><span class="line">	hash0     <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 指向 buckets 数组，大小为 2^B</span></span><br><span class="line">    <span class="comment">// 如果元素个数为0，就为 nil</span></span><br><span class="line">	buckets    unsafe.Pointer</span><br><span class="line">	<span class="comment">// 等量扩容的时候，buckets 长度和 oldbuckets 相等</span></span><br><span class="line">	<span class="comment">// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍</span></span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line">	<span class="comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buckets长度为 $2^B$, 因此 B 每增加 1 表示 buckets 扩容一倍, buckets 指向的是一个结构体, 结构体的结构如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示一个桶</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    <span class="comment">// 以下成员经过编译器扩充才有</span></span><br><span class="line">    keys 	 [<span class="number">8</span>]keytype</span><br><span class="line">    values 	 [<span class="number">8</span>]valuetype</span><br><span class="line">    pad   	 <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>keytype 放在一起, valuetype 也放在一起, 这样减少了不必要的 padding.</li>
<li>HOB Hash 表示 top hash, hash值的前八位.</li>
</ul>
<p><strong>当 map 的 key 和 value 都不是指针，并且 size 都小于 128 字节的情况下，会把 bmap 标记为不含指针，这样可以避免 gc 时扫描整个 hmap, 但是，我们看 bmap 其实有一个 overflow 的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把 overflow 移动到 extra 字段来。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// overflow contains overflow buckets for hmap.buckets.</span></span><br><span class="line">	<span class="comment">// oldoverflow contains overflow buckets for hmap.oldbuckets.</span></span><br><span class="line">	overflow    *[]*bmap</span><br><span class="line">	oldoverflow *[]*bmap</span><br><span class="line"></span><br><span class="line">	<span class="comment">// nextOverflow 包含空闲的 overflow bucket，这是预分配的 bucket</span></span><br><span class="line">	nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map-的创建"><a href="#Map-的创建" class="headerlink" title="Map 的创建"></a>Map 的创建</h3><p>map的创建底层调用的 <code>makemap</code> 函数, 主要工作包含</p>
<ul>
<li>初始化 hmap 结构的字段, 例如计算B的大小, 设置哈希种子 hash0 等</li>
<li>B 的计算: 负载因子不能超过 6.5 </li>
<li><strong>最后返回的结果为</strong> <code>*hmap</code><ul>
<li>因此map作为函数参数的时候, 对map的修改会影响到map自身,</li>
<li>而slice是一个结构体, 修改与自身无关</li>
</ul>
</li>
</ul>
<p>	</p>
<h3 id="Hash-函数的选择"><a href="#Hash-函数的选择" class="headerlink" title="Hash 函数的选择"></a>Hash 函数的选择</h3><p>Hash函数通常分为加密型(md5, sha1, sha256, aes256等)和非加密型(一般用于查找). 查找型(map)需要考虑的点为: 性能和碰撞率</p>
<p>在程序启动时，会检测 cpu 是否支持 <em>aes</em>，如果支持，则使用 <em>aes hash</em>，否则使用 <em>memhash</em>。</p>
<p>表示类型的结构体<code>_type</code>中会有一个<code>alg</code>字段, 其结构为<code>*typeAlg</code>, hash 用于计算类型的哈希值, 而 equal 函数计算两个类型是否哈希相等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line">   	<span class="comment">// (ptr to object, seed) -&gt; hash</span></span><br><span class="line">	hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span></span><br><span class="line">	<span class="comment">// (ptr to object A, ptr to object B) -&gt; ==?</span></span><br><span class="line">	equal <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map-的操作设计"><a href="#Map-的操作设计" class="headerlink" title="Map 的操作设计"></a>Map 的操作设计</h2><h3 id="Key-的寻找"><a href="#Key-的寻找" class="headerlink" title="Key 的寻找"></a>Key 的寻找</h3><p>一个hash函数得到的结果为64位数据, 其中低B位作为桶的索引(<strong>位运算比取余的开销要小得多</strong>). 高八位存储在tophash中.</p>
<p>通过key寻找的时候:</p>
<ul>
<li>首先需要判断是在 oldbuckets 里面找还是 buckets 里面找<ul>
<li>需要判断 oldbuckets 中的数据是否被迁移完毕. 判断的主要依据为根据tophash[0]的值标志的状态判断.</li>
<li><code>minTopHash=4</code>，用来表示状态的值有 <strong>0, 1, 2, 3</strong>. 因此为了区分正常计算出的hash值和表示状态的值, 正常计算出的小于 4 的 hash 值都会加上一个 minTopHash(4). 这样正常计算出来的hash值均大于等于4, 而小于4的表示迁移状态.</li>
</ul>
</li>
<li>通过低 B 位找到 bucket, 然后比较高8位和 bucket 中的 tophash 是否相同. 最后比较 key 是否相同, 相同则找到.</li>
<li>如果在一个 bucket 中没有找到, 且存在 overflow, 则需要再在 overflow 中比较.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空的 cell，也是初始时 bucket 的状态</span></span><br><span class="line">empty          = <span class="number">0</span></span><br><span class="line"><span class="comment">// 空的 cell，表示 cell 已经被迁移到新的 bucket</span></span><br><span class="line">evacuatedEmpty = <span class="number">1</span></span><br><span class="line"><span class="comment">// key,value 已经搬迁完毕，但是 key 都在新 bucket 前半部分，</span></span><br><span class="line"><span class="comment">// 后面扩容部分会再讲到。</span></span><br><span class="line">evacuatedX     = <span class="number">2</span></span><br><span class="line"><span class="comment">// 同上，key 在后半部分</span></span><br><span class="line">evacuatedY     = <span class="number">3</span></span><br><span class="line"><span class="comment">// tophash 的最小正常值</span></span><br><span class="line">minTopHash     = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><img src="https://golang.design/go-questions/map/assets/2.png" alt="mapacess"></p>
<h3 id="Get-的两种实现"><a href="#Get-的两种实现" class="headerlink" title="Get 的两种实现"></a>Get 的两种实现</h3><p>comma-ok模式和直接取变量的模式. 例如: <code>age1 := ageMap[&quot;stefno&quot;]</code>和<code>age2, ok := ageMap[&quot;stefno&quot;]</code>.</p>
<p>这其实是由编译器实现的: 分析代码后，将两种语法对应到底层两个不同的函数。</p>
<p>同时, 根据key的不同类型, 编译器还会将查找, 插入, 删除函数用更加具体的函数替换, 以优化效率</p>
<h3 id="遍历过程"><a href="#遍历过程" class="headerlink" title="遍历过程"></a>遍历过程</h3><p><em>Strawman Idea</em>: 直接遍历所有的bucket, 对每一个bucket及其overflow, 遍历每个cell即可</p>
<p>Problem: map的遍历中如果存在扩容过程, 就会涉及到遍历老的bucket的过程</p>
<p>真实遍历过程:</p>
<ul>
<li>map的遍历是随机的, 这是因为遍历的起始位置(起始bucket和起始cell)是通过随机数产生的</li>
<li>选定遍历位置之后, 如果当前不处于扩容状态, 则直接遍历即可. 如果处于扩容状态, 则需要考虑oldbucket中的元素.</li>
<li>对于新 buckets 中的每一个 bucket, 其都是由 oldbuckets 中的每一个 bucket 分裂而来(类似于 extendible hash table), 因此在遍历新 bucket 之前, 需要判断对应的 oldbucket 是否迁移完毕. <ul>
<li>如果迁移完毕, 则直接遍历新的 bucket 即可</li>
<li>如果还没有迁移完毕, <strong>则遍历 oldbucket 中迁移后属于当前 bucket 的元素</strong>.</li>
</ul>
</li>
</ul>
<p><img src="https://golang.design/go-questions/map/assets/6.png" alt="img"></p>
<h3 id="赋值过程"><a href="#赋值过程" class="headerlink" title="赋值过程"></a>赋值过程</h3><p>插入或修改 key 在汇编层面都是调用了函数 mapassign.</p>
<ul>
<li>首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行写操作，进而导致程序 panic</li>
<li>根据 key 计算 hash 值, 然后分别遍历所有的 overflow bucket, 以及 bucket 中的所有 cell</li>
<li>map 的扩容是渐进式的, 如果 map 正处于扩容过的过程中, 需要先确保该 bucket 对应的老 bucket 迁移完毕(分裂为两个bucket), 才能进行插入或更新的操作</li>
<li><code>inserti</code> 和 <code>insertk</code> 用于指定插入的位置. 在循环过程中, 首先指向第一个发现的空位. 若找到则跳出循环.</li>
<li>在正式放置 key 之前还需要检查是否达到扩容条件, 如果满足条件, 则触发一次扩容操作.</li>
</ul>
<h3 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h3><ul>
<li>计算 key 的哈希, 找到落入的 bucket. 检查此 map 如果正在扩容的过程中, 直接触发一次搬迁操作.</li>
<li>如果找到了, 就对 key 和 value 执行清零操作</li>
</ul>
<h3 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h3><p>扩容时机: 向 map 插入或删除 key 的时候, 会进行条件检查, 满足下面的条件的会触发一次扩容</p>
<ul>
<li>装载因子(loadFactor &#x3D; count &#x2F; 2^B)超过threshold, threshold等于6.5</li>
<li>overflow 的数量过多 <ul>
<li>B 小于 15 的时候, overflow 的数量大于 2^B</li>
<li>B 大于 15 的时候, overflow 的数量大于 2^15</li>
</ul>
</li>
</ul>
<p>扩容原因:</p>
<ul>
<li>第一种情况, 由于每个 bucket 有八个 cell, 装载因子大于 6.5 说明很多 bucket 快要装满了, 会降低查找效率和插入效率. 因此需要进行增量扩容, 使 bucket 不容纳那么多 key.</li>
<li>第二种情况, 负载因子没有超过 6.5 但是 overflow 的数量太多, 说明分配的 overflow bucket 数量太多, 而元素总数较少, 这样也会降低插入和查找效率, 因此可以进行等量扩容, 使 key 的排列更加紧密.<ul>
<li>第二种情况是对第一种情况的补充, 主要是在一直不停的插入和删除元素的时候可能发生.</li>
<li>也有可能数据是非常 skewed, 导致大部分的 key 的 hash 值一样, 这个时候等量扩容并没有解决这个问题.</li>
</ul>
</li>
</ul>
<p>扩容细节:</p>
<ol>
<li><p><code>hasGrow()</code> 函数和调用时机</p>
<ul>
<li><code>hashGrow()</code> 函数并没有真正的进行**搬迁(evacuate函数)**操作, 它只是分配了新的 buckets, 将老的 buckets 挂载到了 oldbuckets 字段上, 并设置了一些标志位. </li>
<li>注意, 如果当前的 iterator 位被设置, 则经过 <code>hasGrow</code> 操作, 标志位被转为 <code>oldIterator</code> </li>
<li><code>hashGrow()</code> 函数的调用发生在 <code>mapassign</code> 中, 是在即将插入之前, 检测到满足扩容条件后执行的. 并且在扩容之后, 需要重新进行一遍寻找 key 的操作, 因为此时进行了扩容, key 的插入操作发生了改变.</li>
</ul>
</li>
<li><p><code>growWork()</code> 函数和调用时机</p>
<ul>
<li><code>growWork()</code> 首先会调用 <code>evacuate()</code> 函数搬迁正在使用的 bucket 对应的老的 bucket.</li>
<li>在搬迁完第一个老 bucket 后, 检查搬迁进程, 如果没有搬迁完, 就会会为了搬迁进度而多搬迁一个 bucket</li>
<li><code>growWork()</code> 函数调用发生在 <code>mapassign</code> 和 <code>mapdelete</code> 中, 发生在进行 key 的查找之前</li>
</ul>
</li>
<li><p><code>evacuate()</code> 函数</p>
<ul>
<li>首先判断当前 bucket 是否被搬迁过, 如果已经被搬迁过, 则直接返回, 如果没有, 则执行下面的操作</li>
<li>定义搬迁的目标位置, 分为 x part 和 y part. x part 用于等量扩容, y part 用于增量扩容</li>
<li>遍历所有的 old bucket(包括overflow bucket), 然后遍历每一个 bucket 中的所有 cell, 将不为空的 cell 搬迁到新的 bucket 中去(<strong>根据是否为等容扩容决定是搬到 x part 或 y part</strong>).</li>
<li>如果 flag 中 oldIterator 字段没有设置, 则说明已经没有协程在访问老的 buckets, 则将 buckets 清除掉以帮助 gc</li>
<li>最后跳出循环之后, 需要更新搬迁进度. 如果所有的bucket都已经被搬迁完毕, 则将 oldbuckets 设置为 nil, 清除对应的标志位. 最后退出.</li>
</ul>
</li>
<li><p><code>evacuated()</code> 函数和 <code>growing()</code> 函数</p>
<ul>
<li><pre><code class="go">func (h *hmap) growing() bool &#123;
    return h.oldbuckets != nil
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 因为扩容完毕之后 oldbuckets 会被置为 nil</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  empty = 0</span><br><span class="line">  evacuatedEmpty = 1</span><br><span class="line">  evacuatedX = 2</span><br><span class="line">  evacuatedY = 3</span><br><span class="line">  minTopHash = 4</span><br><span class="line">  </span><br><span class="line">  func evacuated(b *bmap) bool &#123;</span><br><span class="line">  	h := b.tophash[0]</span><br><span class="line">  	return h &gt; empty &amp;&amp; h &lt; minTopHash</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>因为 <code>evacuate</code> 操作是以 bucket 为单位的, 所以如果某一个 bucket 的第 0 位被搬迁了, 则说明整个 bucket 都被搬迁了</p>
<ul>
<li>evacuatedEmpty 表示被搬迁之前的 cell 为空, evacuatedX 表示被搬到了 x part, evacuatedY 表示被搬到了 y part.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Map-的特殊情况"><a href="#Map-的特殊情况" class="headerlink" title="Map 的特殊情况"></a>Map 的特殊情况</h2><h3 id="float类型作为map的key"><a href="#float类型作为map的key" class="headerlink" title="float类型作为map的key"></a>float类型作为map的key</h3><p>float64 作为 key 的时候会被自动转换为 uint64 类型</p>
<p>NaN 的定义中: <code>NaN != NaN</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uvnan = <span class="number">0x7FF8000000000001</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NaN</span><span class="params">()</span></span> <span class="type">float64</span> &#123; <span class="keyword">return</span> Floats64frombits(uvnan)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f64hash</span><span class="params">(p unsafe.Pointer, h <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">	f := *(*<span class="type">float64</span>)(p)</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> c1 * (c0 ^ h) <span class="comment">// +0, -0</span></span><br><span class="line">    <span class="comment">// 针对 NaN</span></span><br><span class="line">	<span class="keyword">case</span> f != f:</span><br><span class="line">		<span class="keyword">return</span> c1 * (c0 ^ h ^ <span class="type">uintptr</span>(fastrand())) <span class="comment">// any kind of NaN</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> memhash(p, h, <span class="number">8</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此, 由于 NaN 的特性, 有 <code>NaN != NaN</code>, <code>hash(NaN) != hash(NaN)</code></p>
<h3 id="边遍历边删除"><a href="#边遍历边删除" class="headerlink" title="边遍历边删除"></a>边遍历边删除</h3><p>map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</p>
<p>如果在同一个协程内边遍历边删除，并不会检测到同时读写。但是，遍历的结果就可能不会是相同的了，有可能结果遍历结果集中包含了删除的 key，也有可能不包含，这取决于删除 key 的时间：是在遍历到 key 所在的 bucket 时刻前或者后。</p>
<h3 id="无法对map元素取地址"><a href="#无法对map元素取地址" class="headerlink" title="无法对map元素取地址"></a>无法对map元素取地址</h3><p>对 map 元素取地址会引发编译错误</p>
<p>且即使取出了地址, 也会因为扩容等因素而失效</p>
<h3 id="比较两个map相等"><a href="#比较两个map相等" class="headerlink" title="比较两个map相等"></a>比较两个map相等</h3><p><code>==</code> 只能用于比较 map 是否为 nil</p>
<p><code>m == n</code> 不能通过编译</p>
<h1 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h1><h2 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h2><p><code>Duck Typing</code>, 鸭子类型, 是动态编程语言的一种对象推断策略, 它更关注对象能如何被使用, 而不是对象的类型本身. Go 语言作为一门静态语言, 它通过通过接口的方式完美支持鸭子类型。</p>
<p>鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它<strong>当前方法和属性的集合</strong>决定。Go 作为一种静态语言，通过接口实现了<code>鸭子类型</code>，实际上是 Go 的编译器在其中作了隐匿的转换工作。</p>
<h2 id="值-x2F-指针接收者和类型本质"><a href="#值-x2F-指针接收者和类型本质" class="headerlink" title="值&#x2F;指针接收者和类型本质"></a>值&#x2F;指针接收者和类型本质</h2><p>实现了接收者是值类型的方法，相当于自动(隐含地)实现了接收者是指针类型的方法；</p>
<p>而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法</p>
<p>使用指针作为方法的接收者的理由：</p>
<ul>
<li>方法能够修改接收者指向的值。</li>
<li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li>
</ul>
<p><strong>使用指针方法还是值方法不应该由方法是否修改了被调用者来决定, 而是由被调用者的本质来决定</strong>: </p>
<ul>
<li>如果类型具备”原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</li>
<li>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体(struct File)就不应该被复制，应该只有一份<code>实体</code>。</li>
</ul>
<h2 id="iface-和-eface"><a href="#iface-和-eface" class="headerlink" title="iface 和 eface"></a>iface 和 eface</h2><p><code>iface</code> 描述带方法的接口, <code>eface</code> 描述空接口 <code>interface&#123;&#125;</code></p>
<h3 id="iface"><a href="#iface" class="headerlink" title="iface"></a>iface</h3><p>iface 维护两个指针, 分别指向 itab 和 data. </p>
<p>itab 中</p>
<ul>
<li>_type 描述了实体的类型(包含内存对齐方式, 大小等)</li>
<li>inter 字段则描述了接口的类型</li>
<li>fun 字段放置了和接口方法对应的具体数据类型的地址, 实现接口调用方法的动态分派. 一般在接口赋值的时候会更新这个表(如果有 itab 缓存则直接使用 itab 缓存).</li>
</ul>
<p>interfacetype 中</p>
<ul>
<li>typ 字段为 _type 类型, _type 描述了 go 语言中各种数据类型的结构体.</li>
<li>_mhdr 字段表示了接口定义的函数列表</li>
<li>pkgpath 记录了接口定义的包名</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter  *interfacetype</span><br><span class="line">	_type  *_type</span><br><span class="line">	link   *itab</span><br><span class="line">	hash   <span class="type">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">	bad    <span class="type">bool</span>   <span class="comment">// type does not implement interface</span></span><br><span class="line">	inhash <span class="type">bool</span>   <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">	unused [<span class="number">2</span>]<span class="type">byte</span></span><br><span class="line">	fun    [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgpath name</span><br><span class="line">	mhdr    []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://golang.design/go-questions/interface/assets/0.png" alt="iface 结构体全景"></p>
<h3 id="eface"><a href="#eface" class="headerlink" title="eface"></a>eface</h3><p>eface 中:</p>
<ul>
<li>_type 维护了空接口承载的实体类型</li>
<li>data 描述具体的值</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iface-x2F-eface-的组装"><a href="#iface-x2F-eface-的组装" class="headerlink" title="iface&#x2F;eface 的组装"></a>iface&#x2F;eface 的组装</h3><p>通过以下两个函数, 将实体的值和类型值组装成 interface</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2E64</span><span class="params">(t *_type, elem unsafe.Pointer)</span></span> (e eface)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span></span> (i iface)</span><br></pre></td></tr></table></figure>

<p>如下函数所示, 将 <code>tab</code> 赋值给了 <code>iface</code> 的 <code>tab</code> 字段, <code>data</code> 字段则是在堆上申请了内存, 然后将 <code>elem</code> 中的值拷贝过去. 这样就组装好了 <code>iface</code>.</p>
<p>动态生成的 itab 是通过一个全局的哈希表来缓存和查找的. 哈希表的键是一个包含接口类型和具体类型的结构体, 值是对应的 itab 指针。每次运行时需要创建一个新的 itab 时, 都会先在哈希表中查找是否已经存在相同的键, 如果存在就直接返回对应的值, 如果不存在就创建一个新的 itab 并插入到哈希表中. 这样可以避免重复创建相同的 itab, 提高性能。</p>
<p>需要在实现的时候动态组装 <code>itab</code> 的原因: 不可能在编译之前就确定完所有可能的 <code>itab</code> 并全部创建. 因此需要在运行的时候动态维护 <code>itab</code> 的 hash 表. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I64</span><span class="params">(tab *itab, elem unsafe.Pointer)</span></span> (i iface) &#123;</span><br><span class="line">	t := tab._type</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> *(*<span class="type">uint64</span>)(elem) == <span class="number">0</span> &#123;</span><br><span class="line">		x = unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x = mallocgc(<span class="number">8</span>, t, <span class="literal">false</span>)</span><br><span class="line">		*(*<span class="type">uint64</span>)(x) = *(*<span class="type">uint64</span>)(elem)</span><br><span class="line">	&#125;</span><br><span class="line">	i.tab = tab</span><br><span class="line">	i.data = x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-结构体"><a href="#type-结构体" class="headerlink" title="_type 结构体"></a>_type 结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 类型大小</span></span><br><span class="line">	size       <span class="type">uintptr</span></span><br><span class="line">    ptrdata    <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// 类型的 hash 值</span></span><br><span class="line">    hash       <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 类型的 flag，和反射相关</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    <span class="comment">// 内存对齐相关</span></span><br><span class="line">    align      <span class="type">uint8</span></span><br><span class="line">    fieldalign <span class="type">uint8</span></span><br><span class="line">    <span class="comment">// 类型的编号，有bool, slice, struct 等等等等</span></span><br><span class="line">	kind       <span class="type">uint8</span></span><br><span class="line">	alg        *typeAlg</span><br><span class="line">	<span class="comment">// gc 相关</span></span><br><span class="line">	gcdata    *<span class="type">byte</span></span><br><span class="line">	str       nameOff</span><br><span class="line">	ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上, 增加一些额外的字段来进行管理的, 且这些类型的实现是反射的基础</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arraytype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ   _type</span><br><span class="line">	elem  *_type</span><br><span class="line">	slice *_type</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  _type</span><br><span class="line">	elem *_type</span><br><span class="line">	dir  <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  _type</span><br><span class="line">	elem *_type</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> structtype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgPath name</span><br><span class="line">	fields  []structfield</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口的动态类型和动态值"><a href="#接口的动态类型和动态值" class="headerlink" title="接口的动态类型和动态值"></a>接口的动态类型和动态值</h2><p>从源码里可以看到: <code>iface</code>包含两个字段: <code>tab</code> 是接口表指针, 指向类型信息; <code>data</code> 是数据指针, 则指向具体的数据. 它们分别被称为<strong>动态类型</strong>和<strong>动态值</strong>. 而接口值包括<strong>动态类型</strong>和<strong>动态值</strong>.</p>
<p>接口值和 <code>nil</code> 的比较: 当接口值和接口类型都为 <code>nil</code> 的时候, 接口值才会被认为 <code>nil</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span></span> code() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s is coding\n&quot;</span>, g.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Coder</span><br><span class="line">	fmt.Println(c == <span class="literal">nil</span>)  			<span class="comment">// true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;c: %T, %v\n&quot;</span>, c, c) <span class="comment">// c: &lt;nil&gt;, &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> g *Gopher</span><br><span class="line">	fmt.Println(g == <span class="literal">nil</span>)			<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	c = g</span><br><span class="line">	fmt.Println(c == <span class="literal">nil</span>)			<span class="comment">// false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;c: %T, %v\n&quot;</span>, c, c) <span class="comment">// c: *main.Gopher, &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出接口的动态类型和值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	itab, data <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line">	x := <span class="number">5</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(&amp;x)</span><br><span class="line">	</span><br><span class="line">	ia := *(*iface)(unsafe.Pointer(&amp;a))</span><br><span class="line">	ib := *(*iface)(unsafe.Pointer(&amp;b))</span><br><span class="line">	ic := *(*iface)(unsafe.Pointer(&amp;c))</span><br><span class="line"></span><br><span class="line">	fmt.Println(ia, ib, ic)	<span class="comment">// &#123;0 0&#125; &#123;17426912 0&#125; &#123;17426912 842350714568&#125;</span></span><br><span class="line">	fmt.Println(*(*<span class="type">int</span>)(unsafe.Pointer(ic.data))) <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译器检查类型是否实现接口"><a href="#编译器检查类型是否实现接口" class="headerlink" title="编译器检查类型是否实现接口"></a>编译器检查类型是否实现接口</h2><p>通过下面的代码, 可以分别检查 <code>*myWriter</code> 和 <code>myWriter</code> 是否实现了接口 <code>io.Writer</code>. 因为这些赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换和类型断言"><a href="#类型转换和类型断言" class="headerlink" title="类型转换和类型断言"></a>类型转换和类型断言</h2><p><strong>类型转换</strong>、<strong>类型断言</strong>本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>对于<strong>类型转换</strong>而言，转换前后的两个类型要相互兼容才行</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>接口断言的时候会发生赋值操作</p>
<h2 id="接口转换的原理"><a href="#接口转换的原理" class="headerlink" title="接口转换的原理"></a>接口转换的原理</h2><p>生成一个 <code>itab</code> 同时需要接口的类型(inter *interface)和实体(typ _type)的类型.</p>
<p>当判定一种类型是否满足某个接口时, Go 使用类型的方法集和接口所需要的方法集进行匹配, 如果类型的方法集完全包含接口的方法集, 则可认为该类型实现了该接口.</p>
<p>例如某类型有 <code>m</code> 个方法, 某接口有 <code>n</code> 个方法, 则很容易知道这种判定的时间复杂度为 <code>O(mn)</code>, Go 会对方法集的函数按照函数名的字典序进行排序, 所以实际的时间复杂度为 <code>O(m+n)</code>.</p>
<p><code>convI2I</code> 函数真正要做的事: 找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口转换为接口的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convI2I</span><span class="params">(inter *interfacetype, i iface)</span></span> (r iface) &#123;</span><br><span class="line">	tab := i.tab</span><br><span class="line">	<span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tab.inter == inter &#123;</span><br><span class="line">		r.tab = tab</span><br><span class="line">		r.data = i.data</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.tab = getitab(inter, tab._type, <span class="literal">false</span>)</span><br><span class="line">	r.data = i.data</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中在以上的代码中, <code>r.tab</code> 是由转换后的 <code>inter</code> 以及实体的类型 <code>_type</code> 构成的, 通过 <code>getitab</code> 函数组装或从全局哈希表中查询得到的. 其中 <code>getitab</code> 函数如下所示: </p>
<ul>
<li>首先根据 <code>inter</code> 和 <code>typ</code> 计算出 hash 值</li>
<li>不上锁的遍历 hash 表(使用 atomic 保证原子性), 如果找到则直接返回</li>
<li>如果没找到, 则第二次需要上锁后再遍历一遍, 如果依然遍历没有遍历到, 则生成一个新的 itab 并将其加入 hash 表. 这样，其他协程在查找相同的 <code>itab</code> 并且也没有找到时, 第二次查找时, 会被挂住, 之后, 就会查到第一个协程写入哈希表的 <code>itab</code>.</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="type">bool</span>)</span></span> *itab &#123;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 inter, typ 计算出 hash 值</span></span><br><span class="line">	h := itabhash(inter, typ)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// look twice - once without lock, once with.</span></span><br><span class="line">	<span class="comment">// common case will be no lock contention.</span></span><br><span class="line">	<span class="keyword">var</span> m *itab</span><br><span class="line">	<span class="keyword">var</span> locked <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> locked = <span class="number">0</span>; locked &lt; <span class="number">2</span>; locked++ &#123;</span><br><span class="line">		<span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;ifaceLock)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历哈希表的一个 slot</span></span><br><span class="line">		<span class="keyword">for</span> m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != <span class="literal">nil</span>; m = m.link &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）</span></span><br><span class="line">			<span class="keyword">if</span> m.inter == inter &amp;&amp; m._type == typ &#123;</span><br><span class="line">                <span class="comment">// ……</span></span><br><span class="line">                </span><br><span class="line">				<span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">					unlock(&amp;ifaceLock)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> m</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 hash 表中没有找到 itab，那么新生成一个 itab</span></span><br><span class="line">	m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="type">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*sys.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</span><br><span class="line">	m.inter = inter</span><br><span class="line">    m._type = typ</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到全局的 hash 表中</span></span><br><span class="line">	additab(m, <span class="literal">true</span>, canfail)</span><br><span class="line">	unlock(&amp;ifaceLock)</span><br><span class="line">	<span class="keyword">if</span> m.bad &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>add_itab</code> 会检查 <code>itab</code> 中的 <code>interface</code> 和 <code>_type</code> 是否符合, 然后将其添加到 hash 表中</p>
<p><strong>同时会更新 <code>itab</code> 的 <code>fun</code> 数组</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">additab</span><span class="params">(m *itab, locked, canfail <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	inter := m.inter</span><br><span class="line">	typ := m._type</span><br><span class="line">	x := typ.uncommon()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inter 和 typ 的方法都按方法名称进行了排序</span></span><br><span class="line">    <span class="comment">// 并且方法名都是唯一的。所以循环的次数是固定的</span></span><br><span class="line">    <span class="comment">// 只用循环 O(ni+nt)，而非 O(ni*nt)</span></span><br><span class="line">	ni := <span class="built_in">len</span>(inter.mhdr)</span><br><span class="line">	nt := <span class="type">int</span>(x.mcount)</span><br><span class="line">	xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="type">uintptr</span>(x.moff)))[:nt:nt]</span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</span><br><span class="line">		i := &amp;inter.mhdr[k]</span><br><span class="line">		itype := inter.typ.typeOff(i.ityp)</span><br><span class="line">		name := inter.typ.nameOff(i.name)</span><br><span class="line">		iname := name.name()</span><br><span class="line">		ipkg := name.pkgPath()</span><br><span class="line">		<span class="keyword">if</span> ipkg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			ipkg = inter.pkgpath.name()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">			t := &amp;xmhdr[j]</span><br><span class="line">            tname := typ.nameOff(t.name)</span><br><span class="line">            <span class="comment">// 检查方法名字是否一致</span></span><br><span class="line">			<span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">				pkgPath := tname.pkgPath()</span><br><span class="line">				<span class="keyword">if</span> pkgPath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">					pkgPath = typ.nameOff(x.pkgpath).name()</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">					<span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取函数地址，并加入到itab.fun数组中</span></span><br><span class="line">						ifn := typ.textOff(t.ifn)</span><br><span class="line">						*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="type">uintptr</span>(k)*sys.PtrSize)) = ifn</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">goto</span> nextimethod</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        </span><br><span class="line">		m.bad = <span class="literal">true</span>	<span class="comment">// typ 不能包含 inter 中的所有方法</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	nextimethod:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !locked &#123;</span><br><span class="line">		throw(<span class="string">&quot;invalid itab locking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash 值</span></span><br><span class="line">    h := itabhash(inter, typ)</span><br><span class="line">    <span class="comment">// 加到Hash Slot链表中</span></span><br><span class="line">	m.link = hash[h]</span><br><span class="line">	m.inhash = <span class="literal">true</span></span><br><span class="line">	atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabhash</span><span class="params">(inter *interfacetype, typ *_type)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">	h := inter.typ.hash</span><br><span class="line">	h += <span class="number">17</span> * typ.hash</span><br><span class="line">	<span class="keyword">return</span> h % hashSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更一般的. 当把实体类型赋值给接口的时候, 会调用 <code>conv</code> 系列函数, 例如空接口调用 <code>convT2E</code> 系列, 非空接口调用 <code>convT2I</code> 系列. 这些函数比较相似:</p>
<ol>
<li>具体类型转空接口时, _type 字段直接复制源类型的 _type; 调用 mallocgc 获得一块新内存, 把值复制进去, data 再指向这块新内存.</li>
<li>具体类型转非空接口时, <strong>入参 tab 是编译器在编译阶段预先生成好的</strong>, 新接口 tab 字段直接指向入参 tab 指向的 itab; 调用 mallocgc 获得一块新内存, 把值复制进去, data 再指向这块新内存.</li>
<li>而对于接口转接口, <strong>itab 调用 getitab 函数获取. 只用生成一次, 之后直接从 hash 表中获取</strong>.</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol>
<li>一种类型具有多种类型的能力</li>
<li>允许不同的对象对同一消息做出灵活的反应</li>
<li>以一种通用的方式对待个使用的对象</li>
<li>非动态语言必须通过继承和接口的方式来实现</li>
</ol>
<p>go 通过 interface 实现多态</p>
<p>C++ 和 Go 在定义接口方式上的不同, 也导致了底层实现上的不同. </p>
<ul>
<li>C++ 通过虚函数表来实现基类调用派生类的函数; </li>
<li>而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数. </li>
<li>C++ 中的虚函数表是在编译期生成的; </li>
<li>而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在运行期间动态生成的. </li>
<li>原因在于, Go 中实体类型可能会无意中实现 N 多接口, 很多接口并不是本来需要的, 所以不能为类型实现的所有接口都生成一个 <code>itab</code>, 这也是”非侵入式”带来的影响; </li>
<li>但 C++ 是”侵入式”的, 派生需要显示声明它继承自哪个基类, 因此 C++ 可以编译时就生成虚函数表</li>
</ul>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>CSP 定义了输入输出语句, 用于 processes 间的通信(communication). processes 被认为是需要输入驱动, 并且产生输出, 供其他 processes 消费, processes 可以是进程, 线程, 甚至是代码块. 输入命令是: !, 用来向 processes 写入; 输出是: ?, 用来从 processes 读出.</p>
<h2 id="Channel-数据结构"><a href="#Channel-数据结构" class="headerlink" title="Channel 数据结构"></a>Channel 数据结构</h2><p><em>buf</em> 为底层循环数组, 只有缓冲型的 channel 才有; <em>sendx</em> 和 <em>recvx</em> 指向底层循环数组, 分别为数组的写端和读端.</p>
<p><em>sendq</em> 和 <em>recvq</em> 表示被阻塞的 goroutine, 这些 goroutine 分别因为发送和接收被阻塞.</p>
<p><em>qcount</em> 和 <em>dataqsiz</em> 分别表示 chan 里元素的数量和总数量.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// chan 里元素数量</span></span><br><span class="line">	qcount   <span class="type">uint</span></span><br><span class="line">	<span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">	dataqsiz <span class="type">uint</span></span><br><span class="line">	<span class="comment">// 指向底层循环数组的指针, 只针对有缓冲的 channel</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	<span class="comment">// chan 中元素大小</span></span><br><span class="line">	elemsize <span class="type">uint16</span></span><br><span class="line">	<span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">	<span class="comment">// chan 中元素类型</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	<span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	<span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	<span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	<span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">	<span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sudog 是对 goroutine 的封装</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Channel-的操作"><a href="#Channel-的操作" class="headerlink" title="Channel 的操作"></a>Channel 的操作</h2><h3 id="Channel-的创建"><a href="#Channel-的创建" class="headerlink" title="Channel 的创建"></a>Channel 的创建</h3><p>创建 channel 的函数为 <code>makechan</code>: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan</span><br></pre></td></tr></table></figure>

<p>创建的 channel 是一个指针, 因此可以在函数之间直接传递 channel, 而不需要传递 channel 的指针.</p>
<p>其中, 创建channel的时候:</p>
<ul>
<li>如果元素类型不含有指针或 size 大小为 0, 则只进行一次内存分配. 即展开 buf, 将buf所需的内存空间分配在 hchan 数据结构的末尾, 不另外分配 buf. 最后再让 buf 指向那个位置即可(类似于variable-sized array的思想)</li>
<li>其他情况下, 需要正常分配数据, 即先为 hchan 分配内存, 再为 hchan 中的 buf 分配内存.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="type">uintptr</span>(-<span class="type">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略了检查 channel size，align 的代码</span></span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="comment">// 如果元素类型不含指针, 或者 size 大小为 0(无缓冲类型), 则只进行一次内存分配</span></span><br><span class="line">	<span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素</span></span><br><span class="line">		<span class="comment">// 只分配 &quot;hchan 结构体大小 + 元素大小*个数&quot; 的内存</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+<span class="type">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct&#123;&#125;）</span></span><br><span class="line">		<span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">			c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// race detector uses this location for synchronization</span></span><br><span class="line">			<span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">			<span class="comment">// 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处</span></span><br><span class="line">			<span class="comment">// 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct&#123;&#125;，也无影响</span></span><br><span class="line">			<span class="comment">// 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）</span></span><br><span class="line">			c.buf = unsafe.Pointer(c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 进行两次内存分配操作</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = newarray(elem, <span class="type">int</span>(size))</span><br><span class="line">	&#125;</span><br><span class="line">	c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	<span class="comment">// 循环数组长度</span></span><br><span class="line">	c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 hchan 指针</span></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel-的发送"><a href="#Channel-的发送" class="headerlink" title="Channel 的发送"></a>Channel 的发送</h3><p>channel 发送的流程如下:</p>
<ol>
<li><p>检查发送是否合法操作</p>
<ul>
<li><p>如果 channel 为 nil, 直接返回 false</p>
</li>
<li><p>如果 channel 已关闭, 向关闭的 channel 发送消息会导致 panic</p>
</li>
<li><p>如果(没有关闭的) channel 的 send 操作处于<strong>非阻塞模式</strong>, 且发生了下面的情况, 则直接返回 false, 因为如果发生了下面的情况, 就需要阻塞才能完成发送, 这里直接判断并快速返回节省了时间.</p>
<ul>
<li>channel 是非缓冲型的, 但是等待接收队列里没有 goroutine</li>
<li>channel 是缓冲型的，但循环数组已经装满了元素</li>
</ul>
</li>
</ul>
</li>
<li><p>发送数据且没有阻塞</p>
<ul>
<li><p>接下来如果接收队列不为空的话, 就从接收队列取出一个 goroutine 并向其发送数据, 最后返回 true.</p>
</li>
<li><p>如果接收队列为空, 但是缓冲区还没有满, 则向缓冲区写入一个数据.</p>
</li>
</ul>
</li>
<li><p>如果需要阻塞时</p>
<ul>
<li>block 为 false 时, 表示不需要阻塞, 这个时候直接返回 false 表示发送失败.</li>
<li>构造一个 sudog 用来表示当前的 goroutine</li>
<li>将当前的 sudog 加入等待发送队列 sendq, 挂起当前的 goroutine</li>
</ul>
</li>
<li><p>挂起的 goroutine 被唤醒后</p>
<ul>
<li>发送元素</li>
<li>如果此时 channel 被关闭了则 panic</li>
</ul>
</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 如果 channel 是 nil</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 不能阻塞，直接返回 false，表示未发送成功</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">&quot;chan send (nil chan)&quot;</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略 debug 相关……</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于不阻塞的 send，快速检测失败场景</span></span><br><span class="line">	<span class="comment">// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：</span></span><br><span class="line">	<span class="comment">// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine</span></span><br><span class="line">	<span class="comment">// 2. channel 是缓冲型的，但循环数组已经装满了元素</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">		(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 锁住 channel，并发安全</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 channel 关闭了</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="comment">// 直接 panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于缓冲型的 channel，如果还有缓冲空间</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// qp 指向 buf 的 sendx 位置</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将数据从 ep 处拷贝到 qp</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		<span class="comment">// 发送游标值加 1</span></span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="comment">// 如果发送游标值等于容量值，游标值归 0</span></span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 缓冲区的元素数量加一</span></span><br><span class="line">		c.qcount++</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不需要阻塞，则直接返回错误</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// channel 满了，发送方会被阻塞。接下来会构造一个 sudog</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前 goroutine 的指针</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 goroutine 进入发送等待队列</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">&quot;chan send&quot;</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从这里开始被唤醒了（channel 有机会可以发送了）</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 被唤醒后，channel 关闭了。坑爹啊，panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 去掉 mysg 上绑定的 channel</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中, 下面的判断语句是为了在<strong>不阻塞发送</strong>的场景下<strong>快速检测到发送失败</strong>, 好<strong>快速返回</strong>.</p>
<p>这一句话不需要加锁. 这一个判断语句涉及到了 5 个变量: block, c.closed, c.datasiz, c.recv.first, c.qcount. 其中 block 不是共享变量, c.datasiz 是只读变量. 因此真正的共享变量有 c.closed, c.recv.first, c.qcount</p>
<p>这个 if 语句进行了两次 observation: 观测 channel 是否 closed, 以及观测是否 ready for sending. 即使在两次观测之间, channel 被 close 了, 也不会影响这个优化的正确性. 因为 close 一个 channel 不会影响 ready for sending 的性质. 如果我们观察到了 not ready for sending, 我们可以推断 channel 还没有被关闭.</p>
<p>目的: 少获取一次锁, 提升性能.</p>
<blockquote>
<p>这段代码是用来实现 golang channel 的非阻塞发送操作的。它的目的是在不获取锁的情况下，快速判断 channel 是否可以发送数据，如果不可以，就返回 false。这样可以避免频繁地竞争锁，提高性能。</p>
<p>这段代码的关键是利用了两个观察项：channel 是否关闭，和 channel 是否 ready for sending。这两个观察项都是通过读取 channel 的一些字段来判断的，比如 c.closed, c.recvq.first, c.qcount 等。这些字段可能会被其他 goroutine 修改，所以有可能出现观测前后不一致的情况。</p>
<p>但是，作者发现了一个重要的性质：一个 closed channel 不能将 channel 状态从 ‘ready for sending’ 变成 ‘not ready for sending’(<strong>因为不能向关闭的 channel 发送数据</strong>)。也就是说，如果我们先观测到 channel 是未关闭的，并且没有空间或者没有接收者来接收数据（即 not ready for sending），那么即使后来 channel 被关闭了，我们也可以安全地返回 false，因为我们没有错过任何发送数据的机会。</p>
<p>反之，如果我们先观测到 channel 是 ready for sending 的，并且未关闭的，那么即使后来 channel 被关闭了或者变成 not ready for sending 了，我们也可以安全地继续执行发送操作，因为我们已经拿到了发送数据的资格。</p>
<p>所以，在这种情况下，不加锁并不会影响正确性。当然，在其他情况下（比如阻塞发送或者接收操作），还是需要加锁来保证同步和原子性的。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) || (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>goroutine 之间互相发送数据的函数. 这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者, 提高了效率</p>
<p>然后，解锁、唤醒接收者，等待调度器的光临，可以继续执行接收操作之后的代码了。其中待发送的元素的地址位于 sudog 中(sudog.elem 指示了待发送元素的地址), 因此在 recv 函数中会被取出.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// send 函数处理向一个空的 channel 发送操作</span></span><br><span class="line"><span class="comment">// ep 指向被发送的元素，会被直接拷贝到接收的 goroutine</span></span><br><span class="line"><span class="comment">// 之后，接收的 goroutine 会被唤醒</span></span><br><span class="line"><span class="comment">// c 必须是空的（因为等待队列里有 goroutine，肯定是空的）</span></span><br><span class="line"><span class="comment">// c 必须被上锁，发送操作执行完后，会使用 unlockf 函数解锁</span></span><br><span class="line"><span class="comment">// sg 必须已经从等待队列里取出来了</span></span><br><span class="line"><span class="comment">// ep 必须是非空，并且它指向堆或调用者的栈</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 省略一些用不到的</span></span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// sg.elem 指向接收到的值存放的位置，如 val &lt;- ch，指的就是 &amp;val</span></span><br><span class="line">	<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 直接拷贝内存（从发送者到接收者）</span></span><br><span class="line">		sendDirect(c.elemtype, sg, ep)</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// sudog 上绑定的 goroutine</span></span><br><span class="line">	gp := sg.g</span><br><span class="line">	<span class="comment">// 解锁</span></span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">		sg.releasetime = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 唤醒接收的 goroutine. skip 和打印栈相关，暂时不理会</span></span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 向一个非缓冲型的 channel 发送数据、从一个无元素的（非缓冲型或缓冲型但空）的 channel</span></span><br><span class="line"><span class="comment">// 接收数据，都会导致一个 goroutine 直接操作另一个 goroutine 的栈</span></span><br><span class="line"><span class="comment">// 由于 GC 假设对栈的写操作只能发生在 goroutine 正在运行中并且由当前 goroutine 来写</span></span><br><span class="line"><span class="comment">// 所以这里实际上违反了这个假设。可能会造成一些问题，所以需要用到写屏障来规避</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接进行内存&quot;搬迁&quot;</span></span><br><span class="line">	<span class="comment">// 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后</span></span><br><span class="line">	<span class="comment">// 就不能修改真正的 dst 位置的值了</span></span><br><span class="line">	<span class="comment">// 因此需要在读和写之前加上一个屏障</span></span><br><span class="line">	dst := sg.elem</span><br><span class="line">	typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">	memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel-的接收"><a href="#Channel-的接收" class="headerlink" title="Channel 的接收"></a>Channel 的接收</h3><p>根据是否为 <code>comma-ok</code> 的写法, channel 的接收被分别编译为下面两个函数. 如果代码忽略了接受值, 那么 elem 参数为 nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry points for &lt;- c from compiled code</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">	_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>channel 的接收流程如下:</p>
<ol>
<li><h2 id="检查接收是否合法-如果从一个-nil-channel-中接受-不阻塞情况返回-false-false-如果阻塞-则调用-gopark-函数将当前的-goroutine-挂起-在非阻塞情况下-快速检测到失败-直接返回-false-false-失败情况包含"><a href="#检查接收是否合法-如果从一个-nil-channel-中接受-不阻塞情况返回-false-false-如果阻塞-则调用-gopark-函数将当前的-goroutine-挂起-在非阻塞情况下-快速检测到失败-直接返回-false-false-失败情况包含" class="headerlink" title="检查接收是否合法- 如果从一个 nil channel 中接受, 不阻塞情况返回(false, false), 如果阻塞, 则调用 gopark 函数将当前的 goroutine 挂起.- 在非阻塞情况下, 快速检测到失败, 直接返回(false, false)  - 失败情况包含: "></a>检查接收是否合法<br>- 如果从一个 nil channel 中接受, 不阻塞情况返回(false, false), 如果阻塞, 则调用 <code>gopark</code> 函数将当前的 goroutine 挂起.<br>- 在非阻塞情况下, 快速检测到失败, 直接返回(false, false)<br>  - 失败情况包含: </h2></li>
<li>获取锁并尝试获取数据<ul>
<li>如果当前的 channel 被关闭, 且 buf 中没有元素, 则返回(true, false)</li>
<li>sendq 队列中不为空, 则取出一个 goroutine 并从中接收数据最后返回(true, true)</li>
<li>若 buf 不为空, 则从 buf 中取出一个数据并返回(true, true)</li>
</ul>
</li>
<li>如果需要阻塞时<ul>
<li>block 为 false 的时候, 直接返回(false, false)</li>
<li>构造一个 sudog 用来表示当前的 goroutine</li>
<li>将当前的 sudog 加入等待发送队列 recvq, 挂起当前的 goroutine</li>
</ul>
</li>
<li>阻塞被解除时<ul>
<li>释放申请的 sudog</li>
<li>返回 (true, !closed)</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 src/runtime/chan.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。</span></span><br><span class="line"><span class="comment">// 如果 ep 是 nil，说明忽略了接收值。</span></span><br><span class="line"><span class="comment">// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)</span></span><br><span class="line"><span class="comment">// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)</span></span><br><span class="line"><span class="comment">// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)</span></span><br><span class="line"><span class="comment">// 如果 ep 非空，则应该指向堆或者函数调用者的栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 省略 debug 内容 …………</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是一个 nil 的 channel</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则，接收一个 nil 的 channel，goroutine 挂起</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">&quot;chan receive (nil chan)&quot;</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		<span class="comment">// 不会执行到这里</span></span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回</span></span><br><span class="line">	<span class="comment">// 当我们观察到 channel 没准备好接收：</span></span><br><span class="line">	<span class="comment">// 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待</span></span><br><span class="line">	<span class="comment">// 2. 缓冲型，但 buf 里没有元素</span></span><br><span class="line">	<span class="comment">// 之后，又观察到 closed == 0，即 channel 未关闭。</span></span><br><span class="line">	<span class="comment">// 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，</span></span><br><span class="line">	<span class="comment">// 因此在这种情况下可以直接宣布接收失败，返回 (false, false)</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">		c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// channel 已关闭，并且循环数组 buf 里没有元素</span></span><br><span class="line">	<span class="comment">// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况</span></span><br><span class="line">	<span class="comment">// 也就是说即使是关闭状态，但在缓冲型的 channel，</span></span><br><span class="line">	<span class="comment">// buf 里有元素的情况下还能接收到元素</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 从一个已关闭的 channel 执行接收操作，且未忽略返回值</span></span><br><span class="line">			<span class="comment">// 那么接收的值将是一个该类型的零值</span></span><br><span class="line">			<span class="comment">// typedmemclr 根据类型清理相应地址的内存</span></span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从一个已关闭的 channel 接收，selected 会返回true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待发送队列里有 goroutine 存在，说明 buf 是满的</span></span><br><span class="line">	<span class="comment">// 这有可能是：</span></span><br><span class="line">	<span class="comment">// 1. 非缓冲型的 channel</span></span><br><span class="line">	<span class="comment">// 2. 缓冲型的 channel，但 buf 满了</span></span><br><span class="line">	<span class="comment">// 针对 1，直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line">	<span class="comment">// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">		<span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">		<span class="comment">// and add sender&#x27;s value to the tail of the queue (both map to</span></span><br><span class="line">		<span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲型，buf 里有元素，可以正常接收</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 直接从循环数组里找到要接收的元素</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// …………</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 代码里，没有忽略要接收的值，不是 &quot;&lt;- ch&quot;，而是 &quot;val &lt;- ch&quot;，ep 指向 val</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		<span class="comment">// 接收游标向前移动</span></span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="comment">// 接收游标归零</span></span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// buf 数组里的元素个数减 1</span></span><br><span class="line">		c.qcount--</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		<span class="comment">// 非阻塞接收，解锁。selected 返回 false，因为没有接收到值</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来就是要被阻塞的情况了</span></span><br><span class="line">	<span class="comment">// 构造一个 sudog</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 待接收数据的地址保存下来</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="comment">// 进入channel 的等待接收队列</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	<span class="comment">// 将当前 goroutine 挂起</span></span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">&quot;chan receive&quot;</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 被唤醒了，接着从这里继续执行一些扫尾工作</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 recv 函数: 如果是非缓冲类型的 channel, 直接将 sender goroutine 中取出元素并赋值给接收变量</p>
<p>如果跟是缓冲类 channel, 则读出 buf 中的一个元素, 再将 sender goroutine 中的元素复制到 buf 中</p>
<p>最后唤醒 sender goroutine.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果是非缓冲型的 channel</span></span><br><span class="line">	<span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			racesync(c, sg)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 未忽略接收的数据</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 直接拷贝数据，从 sender goroutine -&gt; receiver goroutine</span></span><br><span class="line">			recvDirect(c.elemtype, sg, ep)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 缓冲型的 channel，但 buf 已满。</span></span><br><span class="line">		<span class="comment">// 将循环数组 buf 队首的元素拷贝到接收数据的地址</span></span><br><span class="line">		<span class="comment">// 将发送者的数据入队。实际上这时 revx 和 sendx 值相等</span></span><br><span class="line">		<span class="comment">// 找到接收游标</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="comment">// …………</span></span><br><span class="line">		<span class="comment">// 将接收游标处的数据拷贝给接收者</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将发送者数据拷贝到 buf</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">		<span class="comment">// 更新游标值</span></span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.sendx = c.recvx</span><br><span class="line">	&#125;</span><br><span class="line">	sg.elem = <span class="literal">nil</span></span><br><span class="line">	gp := sg.g</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解锁</span></span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">		sg.releasetime = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 唤醒发送的 goroutine。需要等到调度器的光临</span></span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// dst is on our stack or the heap, src is on another stack.</span></span><br><span class="line">	src := sg.elem</span><br><span class="line">	typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">	memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel-的关闭"><a href="#Channel-的关闭" class="headerlink" title="Channel 的关闭"></a>Channel 的关闭</h3><p><code>closechan</code> 函数的过程: </p>
<ul>
<li>如果 channel 是 nil 或 channel 已经被关闭, 则直接 panic</li>
<li>锁住 channel, 然后将 c.closed 设置成 1</li>
<li>将 channel 中的 sendq 和 recvq 队列中的 goroutine 全部取出并放到一个链表中, 之后解锁 channel</li>
<li>将链表中的 sudog 代表的 goroutine 全部唤醒, 其中 sender goroutine 会导致panic, receiver goroutine 则会释放sudog, 并返回(true, false).<ul>
<li>关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接 panic. 所以在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel.</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 关闭一个 nil channel，panic</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上锁</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="comment">// 如果 channel 已经关闭</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="comment">// panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// …………</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改关闭状态</span></span><br><span class="line">	c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> glist *g</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 channel 所有等待接收队列的里 sudog 释放</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 从接收队列里出队一个 sudog</span></span><br><span class="line">		sg := c.recvq.dequeue()</span><br><span class="line">		<span class="comment">// 出队完毕，跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果 elem 不为空，说明此 receiver 未忽略接收数据</span></span><br><span class="line">		<span class="comment">// 给它赋一个相应类型的零值</span></span><br><span class="line">		<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 取出 goroutine</span></span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 相连，形成链表</span></span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 channel 等待发送队列里的 sudog 释放</span></span><br><span class="line">	<span class="comment">// 如果存在，这些 goroutine 将会 panic</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 从发送队列里出队一个 sudog</span></span><br><span class="line">		sg := c.sendq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送者会 panic</span></span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 形成链表</span></span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解锁</span></span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line">	<span class="comment">// 遍历链表</span></span><br><span class="line">	<span class="keyword">for</span> glist != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 取最后一个</span></span><br><span class="line">		gp := glist</span><br><span class="line">		<span class="comment">// 向前走一步，下一个唤醒的 g</span></span><br><span class="line">		glist = glist.schedlink.ptr()</span><br><span class="line">		gp.schedlink = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 唤醒相应 goroutine</span></span><br><span class="line">		goready(gp, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Channel-的特性"><a href="#Channel-的特性" class="headerlink" title="Channel 的特性"></a>Channel 的特性</h2><h3 id="Channel-的优雅关闭"><a href="#Channel-的优雅关闭" class="headerlink" title="Channel 的优雅关闭"></a>Channel 的优雅关闭</h3><p>关于 channel 的使用，有几点不方便的地方:</p>
<ol>
<li>在不改变 channel 自身状态的情况下, <strong>无法获知一个 channel 是否关闭</strong>.</li>
<li>关闭一个 closed channel 会导致 panic. 所以, <strong>如果关闭 channel 的一方在不知道 channel 是否处于关闭状态时就去贸然关闭 channel 是很危险的事情</strong>.</li>
<li>向一个 closed channel 发送数据会导致 panic. 所以, <strong>如果向 channel 发送数据的一方不知道 channel 是否处于关闭状态时就去贸然向 channel 发送数据是很危险的事情</strong>.</li>
</ol>
<p><strong>关闭 channel 的原则</strong>: </p>
<ul>
<li>不要从一个 receiver 侧关闭 channel</li>
<li>不要在有多个 sender 时, 关闭 channel</li>
</ul>
<p>两个关闭 channel 的可行(但不优雅的)方法:</p>
<ul>
<li>使用 defer-recover 机制</li>
<li>使用 sync.Once 保证关闭一次</li>
</ul>
<hr>
<p>优雅的关闭 channel:</p>
<p>根据 sender 和 receiver 的数量可以分为以下四种情况</p>
<ol>
<li>1 sender, 1 receiver</li>
<li>1 sender, n receiver</li>
<li>n sender, 1 receiver</li>
<li>m sender, n receiver</li>
</ol>
<p>对于情况 1, 2: 直接在 sender 侧关闭即可.</p>
<p>对于情况 3: the only receiver says “please stop sending more” <strong>by closing an additional signal channel</strong>.</p>
<p>下面的代码并没有明确关闭 dataCh. 在 Go 语言中, 对于一个 channel, 如果最终没有任何 goroutine 引用它, 不管 channel 有没有被关闭, 最终都会被 gc 回收. 所以, 在这种情形下, 所谓的优雅地关闭 channel 就是不关闭 channel, 让 gc 代劳.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="number">0</span></span><br><span class="line">    numSenders := <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// n senders</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- data:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 receiver</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            fmt.Println(value)</span><br><span class="line">            <span class="keyword">if</span> value == <span class="number">10</span> &#123;</span><br><span class="line">                <span class="built_in">close</span>(stopCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;- time.After(time.Hour):</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于情况 4, 优雅关闭 channel 的方法是: any one of them says “let’s end the game” by notifying a moderator to close an additional signal channel.</p>
<p>和第 3 种情况不同, 这里有 M 个 receiver, 如果直接还是采取第 3 种解决方案, 由 receiver 直接关闭 stopCh 的话, 就会重复关闭一个 channel, 导致 panic. 因此需要增加一个中间人, M 个 receiver 都向它发送关闭 dataCh 的”请求”, 中间人收到第一个请求后, 就会直接下达关闭 dataCh 的指令(通过关闭 stopCh, 这时就不会发生重复关闭的情况, 因为 stopCh 的发送方只有中间人一个). 另外, 这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Max = <span class="number">100000</span></span><br><span class="line">	<span class="keyword">const</span> NumReceivers = <span class="number">10</span></span><br><span class="line">	<span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">	dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// It must be a buffered channel.</span></span><br><span class="line">	toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// if the capacity is set to NumSenders+NumReceivers, </span></span><br><span class="line">    <span class="comment">// then there is no need for select statement when sending message to toStop chanel</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">var</span> stoppedBy <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// moderator (stopCh can only closed by moderator)</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		stoppedBy = &lt;-toStop</span><br><span class="line">		<span class="built_in">close</span>(stopCh)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// senders</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				value := rand.Intn(Max)</span><br><span class="line">				<span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id:</span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// receivers</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">					<span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">						<span class="keyword">select</span> &#123;</span><br><span class="line">						<span class="keyword">case</span> toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id:</span><br><span class="line">						<span class="keyword">default</span>:</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					fmt.Println(value)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;- time.After(time.Hour):</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>principles: </p>
<ul>
<li>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.</li>
<li>don’t close (or send values to) closed channels.</li>
</ul>
<h3 id="Channel-传递数据的本质"><a href="#Channel-传递数据的本质" class="headerlink" title="Channel 传递数据的本质"></a>Channel 传递数据的本质</h3><p>Remember all transfer of value on the go channels happens with the copy of value.</p>
<h3 id="Channel-引发-Goroutine-泄露"><a href="#Channel-引发-Goroutine-泄露" class="headerlink" title="Channel 引发 Goroutine 泄露"></a>Channel 引发 Goroutine 泄露</h3><p>泄漏的原因是 goroutine 操作 channel 后, 处于发送或接收阻塞状态, 而 channel 处于满或空的状态, 一直得不到改变.</p>
<p>原因是 goroutine 被 channel 引用, 因此得不到释放, channel所在的 goroutine 也被阻塞, channel 也不会被释放.</p>
<h3 id="Channel-中的-happen-before"><a href="#Channel-中的-happen-before" class="headerlink" title="Channel 中的 happen-before"></a>Channel 中的 happen-before</h3><p>send, send-finished, receive, receive-finished 存在下面的关系:</p>
<ol>
<li>第 n 个 <code>send</code> 一定 <code>happened before</code> 第 n 个 <code>receive finished</code>, 无论是缓冲型还是非缓冲型的 channel.</li>
<li>对于容量为 m 的缓冲型 channel, 第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n+m 个 <code>send finished</code>.</li>
<li>对于非缓冲型的 channel, 第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n 个 <code>send finished</code>.</li>
<li>channel close 一定 <code>happened before</code> receiver 得到通知</li>
</ol>
<h2 id="Channel-的应用"><a href="#Channel-的应用" class="headerlink" title="Channel 的应用"></a>Channel 的应用</h2><h3 id="停止信号"><a href="#停止信号" class="headerlink" title="停止信号"></a>停止信号</h3><p>同 “Channel 的优雅关闭” 一节</p>
<h3 id="任务定时"><a href="#任务定时" class="headerlink" title="任务定时"></a>任务定时</h3><p>超时控制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">    <span class="keyword">case</span> &lt;-stopc:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时任务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.Ticker(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker:</span><br><span class="line">            fmt.Println(<span class="string">&quot;do work&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解耦生产方和消费方"><a href="#解耦生产方和消费方" class="headerlink" title="解耦生产方和消费方"></a>解耦生产方和消费方</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	taskCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(taskCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 塞任务</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		taskCh &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 1 小时 </span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Hour):</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(taskCh &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> N = <span class="number">5</span></span><br><span class="line">	<span class="comment">// 启动 5 个工作协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				task := &lt;- taskCh</span><br><span class="line">				fmt.Printf(<span class="string">&quot;finish task: %d by worker %d\n&quot;</span>, task, id)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h3><p>limit 放在函数内的原因:</p>
<ul>
<li>如果在外层, 就是控制系统 goroutine 的数量, 可能会阻塞 for 循环, 影响业务逻辑.</li>
<li>limit 与逻辑无关, 而只是性能调优, 放在外层和内层的语义不一样.</li>
</ul>
<p>注意: 如果 <code>w()</code> 发生 panic, 则 limit 则收不回去了, 需要通过defer来保证一定会收回去.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            limit &lt;- <span class="number">1</span></span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-limit &#125;() <span class="comment">// 防止 panic</span></span><br><span class="line">            w()</span><br><span class="line">            <span class="comment">// &lt;-limit</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><h2 id="Context-的作用"><a href="#Context-的作用" class="headerlink" title="Context 的作用"></a>Context 的作用</h2><p>context 主要用来在 goroutine 之间传递上下文信息, 包括取消信号, 超时时间, 截止时间, k-v 等</p>
<p>context.Context 类型的值可以协调多个 groutine 中的代码执行”取消”操作，并且可以存储键值对. 重要的是它是<strong>并发安全</strong>的。</p>
<p>Context的作用: 当<strong>请求被取消或是处理时间太长</strong>, 这有可能是使用者关闭了浏览器或是已经<strong>超过了请求方规定的超时时间</strong>, <strong>请求方直接放弃了这次请求结果</strong>. 这时, 所有正在为这个请求工作的 goroutine 需要快速退出, 因为它们的”工作成果”不再被需要了. 在相关联的 goroutine 都退出后, 系统就可以回收相关的资源.</p>
<p>总结: context 用来解决 goroutine 之间<code>退出通知</code>, <code>元数据传递</code>的功能</p>
<p><img src="https://golang.design/go-questions/stdlib/context/assets/0.png" alt="request"></p>
<h2 id="Context-的使用"><a href="#Context-的使用" class="headerlink" title="Context 的使用"></a>Context 的使用</h2><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><p>创建根节点的函数 <code>Background()</code>, background 是一个空的 context, 它不能被取消, 没有值, 没有超时时间.</p>
<p>创建子节点的函数有以下四个: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure>

<p>使用 Context 的四条建议: </p>
<ol>
<li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx.</li>
<li>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use.</li>
<li>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</li>
<li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</li>
</ol>
<h3 id="传递共享的数据"><a href="#传递共享的数据" class="headerlink" title="传递共享的数据"></a>传递共享的数据</h3><p>对于 Web 服务端开发, 往往希望将一个请求处理的整个过程串起来, 这就非常依赖于 Thread Local(对于 Go 可理解为单个协程所独有, 而不需要依赖全局变量或参数传递)的变量, 而在 Go 语言中并没有这个概念, 因此需要在函数调用的时候传递 context(将 context 用于传递协程内定义的局部变量).</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRequestID</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        reqID := r.Header().Get(<span class="string">&quot;X-Request-ID&quot;</span>)</span><br><span class="line">        ctx := context.WithValue(r.Context(), requestIDKey, reqID)</span><br><span class="line">        r := r.WithContext(ctx)</span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRequestID</span><span class="params">(ctx context.Context)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.Value(requestIDKey).(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    reqID := GetRequestID(r.Context())</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := WithRequestID(Handle)</span><br><span class="line">    http.ListenAndServer(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消-goroutine"><a href="#取消-goroutine" class="headerlink" title="取消 goroutine"></a>取消 goroutine</h3><p>WithTimeOut 函数返回的 context 和 cancelFun 是分开的. context 本身并没有取消函数, 这样做的原因是取消函数只能由外层函数调用, 防止子节点 context 调用取消函数, 从而严格控制信息的流向: <strong>由父节点 context 流向子节点 context</strong></p>
<h3 id="防止-goroutine-泄露"><a href="#防止-goroutine-泄露" class="headerlink" title="防止 goroutine 泄露"></a>防止 goroutine 泄露</h3><p>下面的程序会一直产生自然数. 如果我们只在取它产生的前 5 个数, 就会产生 goroutine 泄露.</p>
<p>当 n &#x3D;&#x3D; 5 的时候, 直接 break 掉. 那么 gen 函数的协程就会执行无限阻塞, 无法被 gc 回收. 发生了 goroutine 泄漏.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- n</span><br><span class="line">			n++</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> gen() &#123;</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止 goroutine 泄露, 就需要使用 context 改进, 用 context 传递取消信息.</p>
<p>注意: 重复调用 <code>cancel</code> 函数不影响, 因此可以用 <code>defer cancel()</code> 实现 defensive programming.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            	<span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> ch &lt;- n:</span><br><span class="line">                n++</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancel() <span class="comment">// 避免其他地方忘记 cancel，且重复调用不影响</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">			cancel()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="context-Value-查找过程"><a href="#context-Value-查找过程" class="headerlink" title="context.Value 查找过程"></a>context.Value 查找过程</h2><h3 id="valueCtx-的结构"><a href="#valueCtx-的结构" class="headerlink" title="valueCtx 的结构"></a>valueCtx 的结构</h3><p>valueCtx 只实现了 <code>Done()</code> 和 <code>String()</code> 两个函数, 但是它内嵌了一个 Context 结构体, 因此继承了 Context 的方法, 因此 valueCtx 也实现了 Context 接口.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    </span><br><span class="line">    key, value any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="valueCtx-的创建"><a href="#valueCtx-的创建" class="headerlink" title="valueCtx 的创建"></a>valueCtx 的创建</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="value-的查找"><a href="#value-的查找" class="headerlink" title="value 的查找"></a>value 的查找</h3><p>递归查找: 首先在本届点查找, 如果没有查找到, 则递归向父结点查找. 类似一个反向的链表的查找过程.</p>
<p><img src="https://golang.design/go-questions/stdlib/context/assets/2.png" alt="valueCtx"></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Context-包设计"><a href="#Context-包设计" class="headerlink" title="Context 包设计"></a>Context 包设计</h2><h3 id="Context-中的接口"><a href="#Context-中的接口" class="headerlink" title="Context 中的接口"></a>Context 中的接口</h3><p>Context 的类图如下所示:</p>
<ul>
<li>Context 是一个接口, 四个方法都是<code>幂等</code>的<ul>
<li><code>Done()</code> 返回一个 receive-only channel, channel 被关闭的时候, 说明这个 context 被取消了.</li>
<li><code>Err()</code> 返回一个error, 表示 channel 被关闭的原因, 如超时, 被取消等等.</li>
<li><code>Deadline()</code> 返回 context 的截止时间, 通过此时间, 函数就可以决定是否进行接下来的操作, 如果时间太短, 就可以不往下做了, 否则浪费系统资源. 当然, 也可以用这个 deadline 来设置一个 I&#x2F;O 操作的超时时间.</li>
<li><code>Value()</code> 获取之前设置的 key 对应的 value.</li>
</ul>
</li>
<li>canceler 是一个接口, 实现它的数据类型是可取消的. <code>*cancelCtx</code> 和 <code>*timerCtx</code> 实现了 canceler.</li>
</ul>
<p><img src="https://golang.design/go-questions/stdlib/context/assets/4.png" alt="classes"></p>
<p>设计的原因:</p>
<ul>
<li>“取消”操作应该是建议性，而非强制性<ul>
<li>caller 只向 callee 传递取消的信息, 而不强制性取消 callee</li>
</ul>
</li>
<li>“取消”操作应该可传递<ul>
<li>使用关闭 channel 的方式进行广播消息.</li>
</ul>
</li>
</ul>
<h3 id="Context-中的结构体"><a href="#Context-中的结构体" class="headerlink" title="Context 中的结构体"></a>Context 中的结构体</h3><p><strong>emptyCtx</strong>: 空的 context, 永远不会被 cancel, 不会超时, 也不存储值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)	<span class="comment">// returned by Background()</span></span><br><span class="line">    todo  	   = <span class="built_in">new</span>(emptyCtx)	<span class="comment">// returned by TODO()</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>cancelCtx</strong>: 可取消的 context, 实现了 canceler 接口, 且存在内嵌 Context.</p>
<p>Done 会返回一个 channel, 直接调用读这个 channel, 协程会被 block 住. 一般通过搭配 select 来使用. 一旦关闭, 就会立即读出零值.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex <span class="comment">// 保护之后的字段</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	err      <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazily initialize c.done channel </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    d := c.done</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来看, <code>cancel()</code> 方法的功能:</p>
<ul>
<li>关闭 channel, c.done;</li>
<li>递归地取消它的所有子节点;</li>
<li>从父节点从删除自己.</li>
</ul>
<p>达到的效果是通过关闭 channel, 将取消信号传递给了它的所有子节点. </p>
<p>goroutine 接收到取消信号的方式就是 select 语句中的 <code>&lt;-c.done</code> 被选中.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 必须要传 err</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 已经被其他协程取消</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 给 err 字段赋值</span></span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="comment">// 关闭 channel，通知其他协程</span></span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan	<span class="comment">// closedchan 是一个已经被关闭了的 channel</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历它的所有子节点</span></span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">	    <span class="comment">// 递归地取消所有子节点</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将子节点置空</span></span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">	    <span class="comment">// 从父节点中移除自己 </span></span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	p, ok := parentCancelCtx(parent)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(p.children, child)</span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建cancelCtx. 注意: WithCancel 中的 c.cancel 参数需要为 true, 但是在 cancel 函数中, 取消子节点的时候, 参数需要为false. 这是因为在 cancel 函数中, 直接将 c.children 设置为了 nil, 就不需要一个个从子节点中删除父结点中的子节点. 且边遍历边删除也可能会引发问题.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> cancelCtx &#123;</span><br><span class="line">	<span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到了可取消的父结点, 且父结点还没有取消, 将父结点的 children 集合中加上子节点.</span></span><br><span class="line"><span class="comment">// 如果没有找到可取消的父结点, 新启动一个协程监控父节点或子节点取消信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 父节点是个空节点</span></span><br><span class="line">	<span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到可以取消的父 context</span></span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 父节点已经被取消了，本节点（子节点）也要取消</span></span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 父节点未取消</span></span><br><span class="line">			<span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">				p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// &quot;挂到&quot;父节点上</span></span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果没有找到可取消的父 context。新启动一个协程监控父节点或子节点取消信号</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> c := parent.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *cancelCtx:</span><br><span class="line">			<span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> *timerCtx:</span><br><span class="line">			<span class="keyword">return</span> &amp;c.cancelCtx, <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> *valueCtx:</span><br><span class="line">			parent = c.Context</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>propagateCancel 方法的作用就是向上寻找可以”挂靠”的”可取消”的 context, 并且”挂靠”上去. 这样, 调用上层 cancel 方法的时候, 就可以层层传递, 将那些挂靠的子 context 同时”取消”.</p>
<p>propagateCancel 中如果没有找到可取消的父 context, 需要新启动一个协程监控父节点或子节点取消信号. 这是因为parentCancelCtx 函数只会识别 <code>*cancelCtx</code>, <code>*timerCtx</code> 和 <code>*valueCtx</code> 三种类型, 因此如果使用了一个结构体包装了 Context 类型, 则识别不出来. 因此如果把 ctx 强行塞进一个结构体, 并用它作为父节点, 调用 WithCancel 函数构建子节点 context 的时候, Go 会新启动一个协程来监控取消信号. 这样浪费了协程资源, 因此一般不建议把 Context 放到结构体中, 而是直接传递参数.</p>
<p><strong>timerCtx</strong>: 基于 cancelCtx, 仅仅多了 deadline 和 timer. timer 会在 deadline 到来的时候自动取消 context.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取消 timerCtx 的方法: 注意如果定时器不为 nil, 需要关闭定时器, 并将定时器设置为 nil.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 直接调用 cancelCtx 的取消方法</span></span><br><span class="line">	c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		<span class="comment">// 从父节点中删除子节点</span></span><br><span class="line">		removeChild(c.cancelCtx.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 关掉定时器，这样，在deadline 到来时，不会再次取消</span></span><br><span class="line">		c.timer.Stop()</span><br><span class="line">		c.timer = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 timerCtx 的方法:</p>
<ul>
<li>如果 deadline 晚于父结点的 deadline, 则直接返回 WithCancel(parent).</li>
<li>之后创建 timerCtx 并挂靠到父结点上.</li>
<li>如果已经超过 deadline, 则直接返回, 否则, 启动一个定时器 timer, 到达 deadline 后自动执行 cancel 函数.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(deadline) &#123;</span><br><span class="line">		<span class="comment">// 如果父节点 context 的 deadline 早于指定时间。直接构建一个可取消的 context。</span></span><br><span class="line">		<span class="comment">// 原因是一旦父节点超时，自动调用 cancel 函数，子节点也会随之取消。</span></span><br><span class="line">		<span class="comment">// 所以不用单独处理子节点的计时器时间到了之后，自动调用 cancel 函数</span></span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构建 timerCtx</span></span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  deadline,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 挂靠到父节点上</span></span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算当前距离 deadline 的时间</span></span><br><span class="line">	d := time.Until(deadline)</span><br><span class="line">	<span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 直接取消</span></span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// d 时间后，timer 会自动调用 cancel 函数。自动取消</span></span><br><span class="line">		c.timer = time.AfterFunc(d, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h3 id="Reflect-简介"><a href="#Reflect-简介" class="headerlink" title="Reflect 简介"></a>Reflect 简介</h3><p>反射是指计算机程序在运行时(Runtime)可以访问, 检测和修改它本身状态或行为的一种能力. 反射的本质是程序在运行期探知对象的类型信息和内存结构. 不用反射其实也可以实现: 使用汇编语言，直接和内层打交道，可以获取任何信息. 但是, 当编程迁移到高级语言上来之后, 就不行了, 只能通过<code>反射</code>来达到此项技能.</p>
<p>Go 语言提供了一种机制在运行时更新变量和检查它们的值, 调用它们的方法, 但是在编译时并不知道这些变量的具体类型, 这称为反射机制.</p>
<p>使用反射的场景:</p>
<ol>
<li>不能明确接口调用哪个函数, 需要根据传入的参数在运行时决定</li>
<li>不能明确传入函数的参数类型, 需要在运行时处理任意对象</li>
</ol>
<p>反射的缺点:</p>
<ul>
<li>与反射相关的代码, 经常是难以阅读的</li>
<li>Go 语言作为一门强类型静态语言, 编码过程中, 编译器能提前发现一些类型错误, 但是对于反射代码是无能为力的</li>
<li>反射对性能影响比较大, 比正常代码运行速度慢一到两个数量级</li>
</ul>
<h2 id="Go-语言反射实现"><a href="#Go-语言反射实现" class="headerlink" title="Go 语言反射实现"></a>Go 语言反射实现</h2><p>当向接口变量赋予一个实体类型的时候, 接口会存储实体的类型信息, 反射就是通过接口的类型信息实现的, 反射建立在类型的基础上.</p>
<h3 id="type-和-interface"><a href="#type-和-interface" class="headerlink" title="type 和 interface"></a>type 和 interface</h3><p>Go 语言中, 每个变量都有一个静态类型, 在编译阶段就确定了的, 比如 <code>int, float64, []int</code> 等等. 注意, 这个类型是声明时候的类型, 不是底层数据类型.</p>
<p>断言能否成功取决于动态类型是否满足.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/Users/qcrao/Desktop/test&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r = tty</span><br><span class="line"><span class="keyword">var</span> w io.Writer = r.(io.Writer)</span><br></pre></td></tr></table></figure>

<h3 id="reflect-Type"><a href="#reflect-Type" class="headerlink" title="reflect.Type"></a>reflect.Type</h3><p>reflect 包中: </p>
<ul>
<li><code>reflect.Type</code> 是一个接口, 主要提供类型相关的信息, 它和 <code>_type</code> 联系紧密</li>
<li><code>reflect.Value</code> 是一个结构体, 结合了 <code>_type</code> 和 <code>data</code> 两者, 可以通过它来修改值</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype	<span class="comment">// *rtype 实现了 Type 接口</span></span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// emptyInterface 基本上和 eface 相同.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// toType 仅仅做了类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span></span> Type &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Type 定义了很多方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 所有的类型都可以调用下面这些函数</span></span><br><span class="line">	<span class="comment">// 此类型的变量对齐后所占用的字节数</span></span><br><span class="line">	Align() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 如果是 struct 的字段，对齐后占用的字节数</span></span><br><span class="line">	FieldAlign() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回类型方法集里的第 `i` (传入的参数)个方法</span></span><br><span class="line">	Method(<span class="type">int</span>) Method</span><br><span class="line">	<span class="comment">// 通过名称获取方法</span></span><br><span class="line">	MethodByName(<span class="type">string</span>) (Method, <span class="type">bool</span>)</span><br><span class="line">	<span class="comment">// 获取类型方法集里导出的方法个数</span></span><br><span class="line">	NumMethod() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 类型名称</span></span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line">	<span class="comment">// 返回类型所在的路径，如：encoding/base64</span></span><br><span class="line">	PkgPath() <span class="type">string</span></span><br><span class="line">	<span class="comment">// 返回类型的大小，和 unsafe.Sizeof 功能类似</span></span><br><span class="line">	Size() <span class="type">uintptr</span></span><br><span class="line">	<span class="comment">// 返回类型的字符串表示形式</span></span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">	<span class="comment">// 返回类型的类型值</span></span><br><span class="line">	Kind() Kind</span><br><span class="line">	<span class="comment">// 类型是否实现了接口 u</span></span><br><span class="line">	Implements(u Type) <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 是否可以赋值给 u</span></span><br><span class="line">	AssignableTo(u Type) <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 是否可以类型转换成 u</span></span><br><span class="line">	ConvertibleTo(u Type) <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 类型是否可以比较</span></span><br><span class="line">	Comparable() <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 下面这些函数只有特定类型可以调用</span></span><br><span class="line">	<span class="comment">// 如：Key, Elem 两个方法就只能是 Map 类型才能调用</span></span><br><span class="line">	<span class="comment">// 类型所占据的位数</span></span><br><span class="line">	Bits() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回通道的方向，只能是 chan 类型调用</span></span><br><span class="line">	ChanDir() ChanDir</span><br><span class="line">	<span class="comment">// 返回类型是否是可变参数，只能是 func 类型调用</span></span><br><span class="line">	<span class="comment">// 比如 t 是类型 func(x int, y ... float64)</span></span><br><span class="line">	<span class="comment">// 那么 t.IsVariadic() == true</span></span><br><span class="line">	IsVariadic() <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用</span></span><br><span class="line">	Elem() Type</span><br><span class="line">	<span class="comment">// 返回结构体类型的第 i 个字段，只能是结构体类型调用</span></span><br><span class="line">	<span class="comment">// 如果 i 超过了总字段数，就会 panic</span></span><br><span class="line">	Field(i <span class="type">int</span>) StructField</span><br><span class="line">	<span class="comment">// 返回嵌套的结构体的字段</span></span><br><span class="line">	FieldByIndex(index []<span class="type">int</span>) StructField</span><br><span class="line">	<span class="comment">// 通过字段名称获取字段</span></span><br><span class="line">	FieldByName(name <span class="type">string</span>) (StructField, <span class="type">bool</span>)</span><br><span class="line">	<span class="comment">// FieldByNameFunc returns the struct field with a name</span></span><br><span class="line">	<span class="comment">// 返回名称符合 func 函数的字段</span></span><br><span class="line">	FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">bool</span>) (StructField, <span class="type">bool</span>)</span><br><span class="line">	<span class="comment">// 获取函数类型的第 i 个参数的类型</span></span><br><span class="line">	In(i <span class="type">int</span>) Type</span><br><span class="line">	<span class="comment">// 返回 map 的 key 类型，只能由类型 map 调用</span></span><br><span class="line">	Key() Type</span><br><span class="line">	<span class="comment">// 返回 Array 的长度，只能由类型 Array 调用</span></span><br><span class="line">	Len() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回类型字段的数量，只能由类型 Struct 调用</span></span><br><span class="line">	NumField() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回函数类型的输入参数个数</span></span><br><span class="line">	NumIn() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回函数类型的返回值个数</span></span><br><span class="line">	NumOut() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回函数类型的第 i 个值的类型</span></span><br><span class="line">	Out(i <span class="type">int</span>) Type</span><br><span class="line">    <span class="comment">// 返回类型结构体的相同部分</span></span><br><span class="line">	common() *rtype</span><br><span class="line">	<span class="comment">// 返回类型结构体的不同部分</span></span><br><span class="line">	uncommon() *uncommonType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>Type</code> 方法集的倒数第二个方法 <code>common</code> 返回的 <code>rtype</code> 类型, 它和上一篇文章讲到的 <code>_type</code> 是一回事, 而且源代码里也注释了, 两边要保持同步.</p>
<p><code>Type</code> 接口实现了 <code>String()</code> 函数, 满足 <code>fmt.Stringer</code> 接口, 因此使用 <code>fmt.Println</code> 打印的时候, 输出的是 <code>String()</code> 的结果. 另外, <code>fmt.Printf()</code> 函数, 如果使用 <code>%T</code> 来作为格式参数, 输出的是 <code>reflect.TypeOf</code> 的结果, 也就是动态类型.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rtype must be kept in sync with ../runtime/type.go:/^type._type.</span></span><br><span class="line"><span class="keyword">type</span> rtype <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="type">uintptr</span></span><br><span class="line">	ptrdata    <span class="type">uintptr</span></span><br><span class="line">	hash       <span class="type">uint32</span></span><br><span class="line">	tflag      tflag</span><br><span class="line">	align      <span class="type">uint8</span></span><br><span class="line">	fieldAlign <span class="type">uint8</span></span><br><span class="line">	kind       <span class="type">uint8</span></span><br><span class="line">	alg        *typeAlg</span><br><span class="line">	gcdata     *<span class="type">byte</span></span><br><span class="line">	str        nameOff</span><br><span class="line">	ptrToThis  typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arrayType represents a fixed array type.</span></span><br><span class="line"><span class="keyword">type</span> arrayType <span class="keyword">struct</span> &#123;</span><br><span class="line">	rtype <span class="string">`reflect:&quot;array&quot;`</span></span><br><span class="line">	elem  *rtype <span class="comment">// array element type</span></span><br><span class="line">	slice *rtype <span class="comment">// slice type</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chanType represents a channel type.</span></span><br><span class="line"><span class="keyword">type</span> chanType <span class="keyword">struct</span> &#123;</span><br><span class="line">	rtype <span class="string">`reflect:&quot;chan&quot;`</span></span><br><span class="line">	elem  *rtype  <span class="comment">// channel element type</span></span><br><span class="line">	dir   <span class="type">uintptr</span> <span class="comment">// channel direction (ChanDir)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reflect-Value"><a href="#reflect-Value" class="headerlink" title="reflect.Value"></a>reflect.Value</h3><p>通过 <code>reflect.ValueOf()</code> 函数获取 interface{} 里的实际变量, 返回结构体 <code>reflect.Value</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValueOf returns a new Value initialized to the concrete value</span></span><br><span class="line"><span class="comment">// stored in the interface i. ValueOf(nil) returns the zero Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i any)</span></span> Value &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Maybe allow contents of a Value to live on the stack.</span></span><br><span class="line">	<span class="comment">// For now we make the contents always escape to the heap. It</span></span><br><span class="line">	<span class="comment">// makes life easier in a few places (see chanrecv/mapassign</span></span><br><span class="line">	<span class="comment">// comment below).</span></span><br><span class="line">	escapes(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// emptyInterface is the header for an interface&#123;&#125; value.</span></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// typ holds the type of the value represented by a Value.</span></span><br><span class="line">	typ *rtype</span><br><span class="line">	<span class="comment">// Pointer-valued data or, if flagIndir is set, pointer to data.</span></span><br><span class="line">	ptr unsafe.Pointer</span><br><span class="line">	<span class="comment">// flag holds metadata about the value.</span></span><br><span class="line">	flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unpackEface converts a empty interface to Value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">	e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"></span><br><span class="line">	t := e.typ</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	f := flag(t.Kind())</span><br><span class="line">	<span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">		f |= flagIndir</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interface 和 Value 可以互相转换, Interface 和 Value 均可以获取 Type.</p>
<p><img src="https://golang.design/go-questions/stdlib/reflect/assets/6.png" alt="三者关系"></p>
<p>下图中, <code>rtype</code> 实现了 <code>Type</code> 接口, 是所有类型的公共部分. emptyface 结构体和 eface 其实是一个东西, 而 rtype 其实和 _type 是一个东西, 只是一些字段稍微有点差别, 比如 emptyface 的 word 字段和 eface 的 data 字段名称不同, 但是数据型是一样的.</p>
<p><img src="https://golang.design/go-questions/stdlib/reflect/assets/7.png" alt="value rtype"></p>
<h3 id="反射三定律"><a href="#反射三定律" class="headerlink" title="反射三定律"></a>反射三定律</h3><ol>
<li>Reflection goes from interface value to reflection object.</li>
<li>Reflection goes from reflection object to interface value.</li>
<li>To modify a reflection object, the value must be settable.<ul>
<li>反射变量可设置的本质是它存储了原变量本身, 这样对反射变量的操作, 就会反映到原变量本身;</li>
<li>反之, 如果反射变量不能代表原变量, 那么操作了反射变量 ,不会对原变量产生任何影响. 这种情况在语言层面不被允许</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure>

<p>执行上述代码会 panic 的原因是, ValueOf 中的参数 x 是一个拷贝, 反射变量 v 不能代表 x 本身.</p>
<p>因此需要操作引用变量或者传递指针才行. 或者对引用变量进行操作.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type of p:&quot;</span>, p.Type())			 <span class="comment">// type of p: *float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;settability of p:&quot;</span>, p.CanSet()) <span class="comment">// settability of p: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p 还不是代表 x, p.Elem() 才真正代表 x, 因此使用 p.Elem() 才能真正操作 x:</span></span><br><span class="line">v := p.Elem()	<span class="comment">// will panic if p is not pointer or interface</span></span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br><span class="line">fmt.Println(v.Interface()) <span class="comment">// 7.1</span></span><br><span class="line">fmt.Println(x) <span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure>

<p>反射的应用: IDE 代码补全功能, 对象序列化(encoding&#x2F;json), fmt相关函数, ORM…</p>
<h3 id="reflect-DeepEqual"><a href="#reflect-DeepEqual" class="headerlink" title="reflect.DeepEqual()"></a>reflect.DeepEqual()</h3><p>如果是不同的类型, 即使是底层类型相同, 相应的值也相同, 那么两者也不是”深度”相等. </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>深度相等情形</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>相同索引处的元素“深度”相等</td>
</tr>
<tr>
<td>Struct</td>
<td>相应字段，包含导出和不导出，“深度”相等</td>
</tr>
<tr>
<td>Func</td>
<td>只有两者都是 nil 时</td>
</tr>
<tr>
<td>Interface</td>
<td>两者存储的具体值“深度”相等</td>
</tr>
<tr>
<td>Map</td>
<td>1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等</td>
</tr>
<tr>
<td>Pointer</td>
<td>1、使用 &#x3D;&#x3D; 比较的结果相等；2、指向的实体“深度”相等</td>
</tr>
<tr>
<td>Slice</td>
<td>1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &amp;x[0] &#x3D;&#x3D; &amp;y[0] 或者 相同索引处的元素“深度”相等</td>
</tr>
<tr>
<td>numbers, bools, strings, and channels</td>
<td>使用 &#x3D;&#x3D; 比较的结果为真</td>
</tr>
</tbody></table>
<p>一般情况下, DeepEqual 的实现只需要递归地调用 &#x3D;&#x3D; 就可以比较两个变量是否是真的”深度”相等. </p>
<p>但是, 有一些异常情况, 比如: </p>
<ul>
<li>func 类型是不可比较的类型, 只有在两个 func 类型都是 nil 的情况下, 才是”深度”相等;</li>
<li>float 类型, 由于精度的原因, 也是不能使用 &#x3D;&#x3D; 比较的;</li>
<li>包含 func 类型或者 float 类型的 struct, interface, array 等;</li>
<li>对于指针而言, 当两个值相等的指针就是”深度”相等, 因为两者指向的内容是相等的, 即使两者指向的是 func 类型或者 float 类型, 这种情况下不关心指针所指向的内容.</li>
<li>对于指向相同 slice, map 的两个变量也是”深度”相等的, 不关心 slice, map 具体的内容.</li>
<li>对于”有环”的类型, 比如循环链表, 比较两者是否”深度”相等的过程中, 需要对已比较的内容作一个标记, 一旦发现两个指针之前比较过, 立即停止比较, 并判定二者是深度相等的. 以及时停止比较, 避免陷入无限循环.</li>
</ul>
<p>核心的比较代码在 <code>deepValueEqual</code> 中, 核心是一个 switch 语句, 识别输入参数的不同类型, 分别递归调用 deepValueEqual 函数, 一直递归到最基本的数据类型, 可以直接得出 true 或者 false, 再一层层地返回, 最终得到”深度”相等的比较结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> || y == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x == y</span><br><span class="line">	&#125;</span><br><span class="line">	v1 := ValueOf(x)</span><br><span class="line">	v2 := ValueOf(y)</span><br><span class="line">	<span class="keyword">if</span> v1.Type() != v2.Type() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> deepValueEqual(v1, v2, <span class="built_in">make</span>(<span class="keyword">map</span>[visit]<span class="type">bool</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h2><h3 id="Go-指针和-unsafe"><a href="#Go-指针和-unsafe" class="headerlink" title="Go 指针和 unsafe"></a>Go 指针和 unsafe</h3><p><strong>Go 语言的指针</strong>存在很多限制:</p>
<ol>
<li>Go 的指针不能进行数学运算</li>
<li>不同类型的指针不能互相转换</li>
<li>不同类型的指针不能通过 <code>==</code> 或 <code>!=</code> 进行比较<ul>
<li>只有在两个指针类型相同或者可以相互转换的情况下, 才可以对两者进行比较. </li>
<li>另外, 指针可以通过 <code>==</code> 和 <code>!=</code> 直接和 <code>nil</code> 作比较.</li>
</ul>
</li>
<li>不同类型的指针变量不能相互赋值</li>
</ol>
<p><strong>unsafe 中的 Pointer</strong>: Pointer 可以指向任何类型, 其类似于 C 语言中的 void*</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure>

<p>unsafe 包提供了两点重要的能力:</p>
<ol>
<li>任意类型的指针都可以和 unsafe.Pointer 互相转换</li>
<li>uintptr 类型和 unsafe.Pointer 可以互相转换</li>
</ol>
<p><img src="https://golang.design/go-questions/stdlib/unsafe/assets/0.png" alt="type pointer uintptr"></p>
<p><strong>unsafe.Pointer 并没有数学运算的能力, 但是可以将其转换为 uintptr 之后再进行数学运算, 再转换为 unsafe.Pointer类型.</strong></p>
<p><strong>uintptr 没有指针的语义, 因此 uintptr 指向的对象会被 gc 回收(这点在map 的 extra 字段和 overflow 字段中也有所体现)</strong></p>
<p><strong>unsafe 包中的几个函数都是在编译期间执行完毕</strong></p>
<h3 id="unsafe-修改私有成员"><a href="#unsafe-修改私有成员" class="headerlink" title="unsafe 修改私有成员"></a>unsafe 修改私有成员</h3><p>对于一个结构体, 通过 offset 函数可以获取结构体成员的偏移量, 进而获取成员的地址, 读写该地址的内存, 就可以达到改变成员值的目的. 这里有一个内存分配相关的事实: 结构体会被分配一块连续的内存, 结构体的地址也代表了第一个成员的地址.</p>
<h3 id="字符串和-byte-切片之间的无拷贝转换"><a href="#字符串和-byte-切片之间的无拷贝转换" class="headerlink" title="字符串和 byte 切片之间的无拷贝转换"></a>字符串和 byte 切片之间的无拷贝转换</h3><p>首先需要直到字符串和 byte 切片的数据结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">	Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要共享底层的 Data 和 Len 就可以实现 <em>zero-copy</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2string</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>














    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/02/21/Hashing/" rel="prev" title="Hashing">
                  <i class="fa fa-chevron-left"></i> Hashing
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/03/gin/" rel="next" title="gin">
                  gin <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Anyu Elin</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Word count total: </span>
    <span title="Word count total">61k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">3:43</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
