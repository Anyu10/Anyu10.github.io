<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis</title>
    <url>/2023/02/18/Redis/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2023/02/13/RPC/</url>
    <content><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC需要解决的问题:</p>
<ul>
<li>函数映射问题</li>
<li>数据转换为字节流</li>
<li>数据的网络传输</li>
</ul>
<span id="more"></span>

<h2 id="RPC-模型"><a href="#RPC-模型" class="headerlink" title="RPC 模型"></a>RPC 模型</h2><p>RPC 由五个模型组成</p>
<ol>
<li>User</li>
<li>User-Stub</li>
<li>RPC-Runtime</li>
<li>Server-Stub</li>
<li>Server</li>
</ol>
<p><img src="D:\Blog\source_images\image-20230218155944161.png" alt="image-20230218155944161"></p>
<h2 id="RPC-框架"><a href="#RPC-框架" class="headerlink" title="RPC 框架"></a>RPC 框架</h2><ol>
<li>IDL文件: 描述接口，可跨语言、跨平台</li>
<li>生成代码: 将IDL文件转换为对应语言的静态库</li>
<li>编解码: 内存中的表示和字节序列之间的转换为编解码</li>
<li>通信协议: 网络传输协议</li>
<li>网络传输: 通常基于成熟的网络库，如TCP&#x2F;UDP</li>
</ol>
<p><img src="C:\Users\Anyu\AppData\Roaming\Typora\typora-user-images\image-20230218160113958.png" alt="image-20230218160113958"></p>
<p>RPC优点:</p>
<ul>
<li>单一职责，有利于分工协作和运维开发</li>
<li>可扩展性强，资源使用率更优</li>
<li>故障隔离，服务的可靠性更高</li>
</ul>
<h2 id="RPC-分层设计"><a href="#RPC-分层设计" class="headerlink" title="RPC 分层设计"></a>RPC 分层设计</h2><h3 id="RPC框架架构"><a href="#RPC框架架构" class="headerlink" title="RPC框架架构"></a>RPC框架架构</h3><p>Apache Thrift架构如下: </p>
<p><img src="D:\Blog\source_images\image-20230218164643012.png" alt="image-20230218164643012"></p>
<h3 id="编解码层"><a href="#编解码层" class="headerlink" title="编解码层"></a>编解码层</h3><p>数据格式:</p>
<ul>
<li>语言特定的格式，通常与编程语言绑定</li>
<li>文本格式，如JSON，XML，CSV等格式</li>
<li>二进制编码，跨语言、高性能</li>
</ul>
<p>TLV编码: TLV :&#x3D; Tag | Length | Value (Value can also be TLV)</p>
<p>Varint编码</p>
<h3 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h3><p>常见的协议:</p>
<ul>
<li>特殊结束符: 通过一个特殊字符作为协议单元结束的标志</li>
<li>变长协议: 定长部分加变长部分，通常定长部分需要描述变长部分的长度</li>
</ul>
<h3 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h3><p>Socket API，连接管理和事件分发</p>
<p>性能: 高性能定时器、对象池等</p>
<h2 id="RPC-关键指标"><a href="#RPC-关键指标" class="headerlink" title="RPC 关键指标"></a>RPC 关键指标</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>降级措施:</p>
<ul>
<li>熔断: 保护调用方，防止被调用的服务出现问题而影响整个链路</li>
<li>限流: 保护被调用方，防止大流量把服务压垮</li>
<li>超时控制: 避免浪费资源在不可用节点上</li>
</ul>
<p>请求成功率:</p>
<ul>
<li>负载均衡</li>
<li>重试: 多次失败才表示真正的失败</li>
</ul>
<p>长尾请求:</p>
<ul>
<li>Backup Request: 未超时的时候就发送额外的请求</li>
</ul>
<p>框架通过<strong>注册中间件</strong>的方式来实现上述措施:</p>
<ul>
<li>WithCircuitBreaker: 熔断</li>
<li>WithRateLimiter: 限流</li>
<li>WithTimeout: 超时控制</li>
<li>WithLoadBalancer: 负载均衡</li>
<li>WithRetry: 重试</li>
<li>WithBackupRequest: Backup Request</li>
</ul>
<h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><p>开箱即用: 合理的默认参数选项(熔断、限流、降级等)，丰富的文档</p>
<p>生成代码工具，脚手架工具</p>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>Middleware</p>
<p>Option</p>
<p>编解码层</p>
<p>协议层</p>
<p>网络传输层</p>
<p>代码生成工具插件拓展</p>
<p><img src="D:\Blog\source_images\image-20230218172303486.png" alt="image-20230218172303486"></p>
<h3 id="观测性"><a href="#观测性" class="headerlink" title="观测性"></a>观测性</h3><p>RPC框架往往内置观测服务</p>
<ul>
<li>Log: Events</li>
<li>Metric: Aggregatable</li>
<li>Tracing: Request Scoped</li>
</ul>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>目标: </p>
<ul>
<li>高吞吐</li>
<li>低延迟</li>
</ul>
<p>手段:</p>
<ul>
<li>连接池</li>
<li>多路复用</li>
<li>高性能编解码协议</li>
<li>高性能网络库</li>
</ul>
<h2 id="RPC-框架实现"><a href="#RPC-框架实现" class="headerlink" title="RPC 框架实现"></a>RPC 框架实现</h2><h3 id="Netpoll"><a href="#Netpoll" class="headerlink" title="Netpoll"></a>Netpoll</h3><p>网络库Netpoll的背景:</p>
<ul>
<li>原生库net无法感知连接状态，可能存在无效连接</li>
<li>原生库存在goroutine暴涨的风险</li>
</ul>
<p>改进:</p>
<ul>
<li>引入epoll主动监听机制，感知连接状态</li>
<li>建立goroutine池，复用goroutine</li>
<li>引入Nocopy Buffer，编解码层实现零拷贝</li>
</ul>
<h3 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h3><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Interaction</td>
<td>Ping-Pong&#x2F;Streaming&#x2F;Oneway</td>
</tr>
<tr>
<td>Codec</td>
<td>Thrift&#x2F;Protobuf</td>
</tr>
<tr>
<td>Application Layer Protocol</td>
<td>TTheader&#x2F;Http2</td>
</tr>
<tr>
<td>Transport Layer</td>
<td>TCP&#x2F;UDP&#x2F;RDMA</td>
</tr>
</tbody></table>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>网络库优化:</p>
<ul>
<li>调度优化<ul>
<li>epoll_wait 在调度上的控制</li>
<li>gopool重用</li>
</ul>
</li>
<li>LinkBuffer<ul>
<li>读写并行无锁，支持nocopy进行流式读写</li>
<li>高效扩缩容</li>
<li>Nocopy Buffer池化，减少GC开销</li>
</ul>
</li>
<li>Pool<ul>
<li>引入内存池和对象池，减少GC开销</li>
</ul>
</li>
</ul>
<p>编解码优化: </p>
<ul>
<li>Codegen<ul>
<li>预计算并分配内存，减少内存操作次数</li>
<li>Inline减少函数调用次数和不必要的反射</li>
</ul>
</li>
<li>JIT (Just In Time)<ul>
<li>无生产代码，将编译过程移到了程序的加载（或首次解析）阶段，可以一次性编译生成对应的 codec 并高效执行</li>
</ul>
</li>
</ul>
<h2 id="部署优化"><a href="#部署优化" class="headerlink" title="部署优化"></a>部署优化</h2><p>问题: 微服务过微，传输和序列化开销增大</p>
<p>解决方案: 将依赖关系较强的服务尽可能地调度到一个物理机，RPC调用优化为本地IPC调用</p>
]]></content>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Message Queue</title>
    <url>/2023/02/13/Message-Queue/</url>
    <content><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>消息队列(MQ): 指保存消息的一个容器，本质上是一个队列，但需要支持<strong>高吞吐，高并发，高可用</strong></p>
<ul>
<li>解耦，例如替代存储业务</li>
<li>削峰，例如限制一个服务的请求量</li>
<li>异步，例如减少一条链路中的长尾效应</li>
<li>日志处理</li>
</ul>
<span id="more"></span>

<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>应用场景:</p>
<ul>
<li>日志信息</li>
<li>Metrics数据</li>
<li>用户行为数据</li>
</ul>
<p>如何使用:</p>
<ol>
<li>创建集群</li>
<li>新增Topic，设置分区数量</li>
<li>编写生产者逻辑</li>
<li>编写消费者逻辑</li>
</ol>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="D:\Blog\source_images\image-20230215151350639.png" alt="image-20230215151350639"></p>
<p>Topic: 逻辑队列，用于不同的业务场景</p>
<p>Cluster: 物理集群，每个集群中可以建立多个不同的Topic</p>
<p>Producer: 生产者，负责将消息发送到Topic之中</p>
<p>Consumer: 消费者，负责消费Topic中的信息</p>
<p>ConsumerGroup: 消费者组，不同的Consumer消费进度互不干涉</p>
<p>Partition: 一个Topic有多个Partition，不同的Partition的消息可以并发处理</p>
<p><img src="D:\Blog\source_images\image-20230215151451171.png" alt="image-20230215151451171"></p>
<p>Offset，消息在Partition中的相对位置信息，可以理解为唯一ID，在Partition内部严格递增</p>
<p>Replica: 每个Partition会有多个Replica，Leader Replica会从ISR(In-Sync Replicas)中选出</p>
<ul>
<li>Leader会从Producer中写数据，被Consumer读数据</li>
<li>Follower从Leader中拉取数据</li>
</ul>
<h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><p>batch发送，批量发送可以减少IO次数，进而增强发送能力</p>
<p>通过压缩，减少消息大小，支持Snappy, Gzip, LZ4, ZSTD压缩算法</p>
<h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>将消息存储到本地磁盘，文件系统如下</p>
<p>顺序写，末尾追加，提升了写入效率</p>
<p><img src="D:\Blog\source_images\image-20230215152320277.png" alt="image-20230215152320277"></p>
<p>Broker如何寻找消息？</p>
<p>Consumer发送FetchRequest请求消息数据，Broker会将指定的Offset处的消息，按照时间窗口和消息大小窗口发送给Consumer。</p>
<p>Broker寻找offset的日志:</p>
<ul>
<li>通过二分法寻找小于目标offset的最大文件</li>
<li>对于偏移量索引文件，先二分，再遍历</li>
<li>对于时间索引文件，先通过时间戳利用二分法在时间索引文件中找到offset，然后根据这个offset二次查询</li>
</ul>
<p>Broker的零拷贝优化:</p>
<p>原路径: file –&gt; Read Buffer –&gt; Application Buffer –&gt; Socket Buffer –&gt; NIC Buffer –&gt; Consumer</p>
<p>优化路径: file –&gt; Read Buffer –&gt; NIC Buffer –&gt; Consumer</p>
<p><img src="D:\Blog\source_images\image-20230215153828661.png" alt="image-20230215153828661"></p>
<h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>Partition在Consumer Group中的分配问题？</p>
<ul>
<li>手动分配，哪一个Consumer消费哪个Partition完全由业务决定<ul>
<li>不能自动容灾，例如某一个Consumer挂掉，则有Partition空闲</li>
<li>扩缩容复杂，如新增一个Consumer需要重新分配</li>
</ul>
</li>
<li>自动分配，在Broker集群中，对每个Consumer Group，选出一个Coordinator，进行Consumer集群的自动分配(Re-balance)</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Kafka用于提高吞吐和稳定性的功能？</p>
<ul>
<li>Producer: 批量发送，数据压缩</li>
<li>Broker: 顺序写，消息索引，零拷贝</li>
<li>Consumer: Rebalance</li>
</ul>
<p>Kafka的缺点</p>
<ul>
<li>重启，替换，扩容，缩容都很复杂</li>
<li>负载不均衡时，解决方案复杂</li>
<li>运维成本高</li>
<li>没有缓存，完全依赖文件系统的Page Cache</li>
<li>Controller 和 Coordinator 和 Broker 在同一进程中，大量IO会导致性能下降</li>
</ul>
<h1 id="BMQ"><a href="#BMQ" class="headerlink" title="BMQ"></a>BMQ</h1><h2 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h2><p>兼容Kafka协议，<strong>存算分离</strong>，云原生消息队列</p>
<p><img src="D:\Blog\source_images\image-20230215160210435.png" alt="image-20230215160210435"></p>
<p>解决了Kafka中的负载均衡的问题 –&gt; 存算分离，利用分布式存储系统让partition的读取负载均衡</p>
<p>解决了Kafka运维成本高和扩缩容复杂的问题 –&gt; Broker-Partition 状态机</p>
<h2 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h2><h3 id="Producer写"><a href="#Producer写" class="headerlink" title="Producer写"></a>Producer写</h3><p><img src="D:\Blog\source_images\image-20230216183002024.png" alt="image-20230216183002024"></p>
<p><img src="D:\Blog\source_images\image-20230216183435666.png" alt="image-20230216183435666"></p>
<p>Failover: DataNode节点挂了导致写文件失败</p>
<h3 id="Consumer读"><a href="#Consumer读" class="headerlink" title="Consumer读"></a>Consumer读</h3><p><img src="D:\Blog\source_images\image-20230216183924456.png" alt="image-20230216183924456"></p>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="泳道消息"><a href="#泳道消息" class="headerlink" title="泳道消息"></a>泳道消息</h3><p>解决了主干泳道流量问题以及用到资源重复创建的问题</p>
<p>主干Topic用于线上环境，另一个Topic用于测试环境，且只需要一个Topic</p>
<p><img src="C:\Users\Anyu\AppData\Roaming\Typora\typora-user-images\image-20230216184839487.png" alt="image-20230216184839487"></p>
<h3 id="Databus"><a href="#Databus" class="headerlink" title="Databus"></a>Databus</h3><p>可以动态配置</p>
<p>对高吞吐支持较好</p>
<h3 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h3><p>通过最终一致性的方式，解决跨 Region 读写问题</p>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>一般: 通过offset或timestamp查询</p>
<p>直接在BMQ中将数据结构化，配置索引DDL，异步建立索引，之后通过Index Query服务读出数据</p>
<h3 id="Parquet"><a href="#Parquet" class="headerlink" title="Parquet"></a>Parquet</h3><p>Apache Parquet 数据存储格式</p>
<p>直接在BMQ中将数据结构化，通过Parquet Engine，以不同的方式构建Parquet格式文件</p>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="架构模型-1"><a href="#架构模型-1" class="headerlink" title="架构模型"></a>架构模型</h2><p>用于低延时场景，和峰值场景</p>
<p><img src="D:\Blog\source_images\image-20230217161020936.png" alt="image-20230217161020936"></p>
<h2 id="高级特性-1"><a href="#高级特性-1" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="事务场景"><a href="#事务场景" class="headerlink" title="事务场景"></a>事务场景</h3><p>RocketMQ支持事务</p>
<p>通过2PC实现</p>
<p><img src="D:\Blog\source_images\image-20230217162544987.png" alt="image-20230217162544987"></p>
<h3 id="延迟发送"><a href="#延迟发送" class="headerlink" title="延迟发送"></a>延迟发送</h3><ol>
<li>通过一个ScheduleTopic的Consumer消费消息，然后将消息送往延迟服务</li>
<li>时间到之后，延迟服务再将消息送回消息队列，让别的Consumer正常消费</li>
</ol>
<p><img src="D:\Blog\source_images\image-20230217162038461.png" alt="image-20230217162038461"></p>
<h3 id="消费重试和死信队列"><a href="#消费重试和死信队列" class="headerlink" title="消费重试和死信队列"></a>消费重试和死信队列</h3><p>消费失败时:</p>
<ul>
<li>没有超过重试次数，发到延时服务，延时投递至Topic进行重试</li>
<li>超过重试次数，发送到死信队列，人工介入</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Distributed Timer</title>
    <url>/2023/02/09/Distributed-Timer/</url>
    <content><![CDATA[<h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><p>定时任务: 实时，延时，或周期性完成任务调度的过程</p>
<p>分布式定时任务: 将分散的、可靠性差的任务纳入一个统一的<strong>平台</strong>，实现集群管理调度和分布式部署的一种定时任务的管理方式</p>
<p>触发时机:</p>
<ul>
<li>定时任务</li>
<li>延时任务</li>
<li>周期任务</li>
</ul>
<p>分布式定时任务: 自动化 + 定时执行 + 海量数据 + 高效稳定</p>
<span id="more"></span>

<h2 id="单机定时任务"><a href="#单机定时任务" class="headerlink" title="单机定时任务"></a>单机定时任务</h2><p>Linux命令: cronjob</p>
<p>Golang: time.Ticker</p>
<p>任务调度: Quartz</p>
<h2 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h2><p>分布式定时任务的执行方式:</p>
<ul>
<li>单机任务: 随机触发一台机器执行任务，使用计算量小，并发度低的任务</li>
<li>广播任务: 广播到所有机器上执行同一个任务，如所有机器一起执行日志</li>
<li>Map任务: 一个任务分为很多个子任务，适用于计算量大，单机无法满足要求的任务</li>
<li>MapReduce任务: 在Map任务的基础上，对子任务的结果进行汇总计算</li>
</ul>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h3><p>分布式定时任务的核心要解决<strong>触发</strong>，<strong>调度</strong>，<strong>执行</strong>三个关键问题。</p>
<ul>
<li>触发器(Trigger): 解析任务，生成触发事件</li>
<li>调度器(Scheduler): 分配任务，管理任务的生命周期</li>
<li>执行器(Executor): 获取执行任务的单元，执行任务逻辑</li>
<li>控制台(Admin): 提供任务管理和干预功能</li>
</ul>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><img src="D:\Blog\source_images\image-20230213180406391.png" alt="image-20230213180406391"></p>
<h3 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h3><p><img src="D:\Blog\source_images\image-20230213180511744.png" alt="image-20230213180511744"></p>
<h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p><img src="D:\Blog\source_images\image-20230213180755438.png" alt="image-20230213180755438"></p>
<p>Job: 任务元数据，一个Job对应多个JobInstance</p>
<p>JobInstance: 任务运行的实例</p>
<p>JobResult: 任务实例运行的结果</p>
<p>JobHistory: 用户可以修改任务信息，JobHistory会记录用户的修改。</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job是用户对任务属性的定义:</p>
<ul>
<li>基础信息 Who</li>
<li>调度时机 When</li>
<li>执行行为 What</li>
<li>执行方式 How</li>
</ul>
<h3 id="JobInstance"><a href="#JobInstance" class="headerlink" title="JobInstance"></a>JobInstance</h3><p>JobInstance是一次确定的Job的一次运行实例:</p>
<ul>
<li>Job_id</li>
<li>触发时间</li>
<li>状态&amp;结果</li>
<li>过程信息</li>
</ul>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>核心职责: 给定一系列任务，解析触发规则，在规定的时间点触发任务的调度</p>
<p>设计约束:</p>
<ul>
<li>需要支持大量任务</li>
<li>需要支持秒级调度</li>
<li>周期任务需要多次执行</li>
<li>需要保证秒级扫描的高性能，并避免资源浪费</li>
</ul>
<h3 id="方案1-定时扫描-延时消息"><a href="#方案1-定时扫描-延时消息" class="headerlink" title="方案1 定时扫描+延时消息"></a>方案1 定时扫描+延时消息</h3><p><img src="D:\Blog\source_images\image-20230213181935384.png" alt="image-20230213181935384"></p>
<h3 id="方案2-时间轮"><a href="#方案2-时间轮" class="headerlink" title="方案2 时间轮"></a>方案2 时间轮</h3><p>链表 –&gt; 最小堆 –&gt; 时间轮 –&gt; 多级时间轮</p>
<p><img src="D:\Blog\source_images\image-20230213182055690.png" alt="image-20230213182055690"></p>
<p><img src="D:\Blog\source_images\image-20230213182441824.png" alt="image-20230213182441824"></p>
<p>时间轮的改进: </p>
<ol>
<li>给任务加上一个count属性，每遍历一次count减一，当count变为0的时候，执行该任务。</li>
<li>多级时间轮，时间复杂度优秀，且可以扩展到天轮，月轮等等</li>
</ol>
<p><img src="D:\Blog\source_images\image-20230213182640729.png" alt="image-20230213182640729"></p>
<h3 id="高可用触发器"><a href="#高可用触发器" class="headerlink" title="高可用触发器"></a>高可用触发器</h3><p>问题：</p>
<ul>
<li>不同业务之间，任务的调度互相影响怎么办</li>
<li>负责扫描和触发的机器挂了怎么办</li>
</ul>
<p>解决思路：</p>
<ul>
<li>存储上，不同国家、业务做资源隔离</li>
<li>运行时，不同国家、业务分开运行</li>
<li>部署时，集群化部署，避免单点故障，通过数据库锁或分布式锁保证任务只执行一次<ul>
<li>数据库行锁模式：触发调度之前，更新数据库JobInstance的状态，成功更新的才能出发调度</li>
<li>触发调度之前，抢占分布式锁，可用Redis锁或Zookeeper锁。性能更高</li>
</ul>
</li>
</ul>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><h3 id="资源来源"><a href="#资源来源" class="headerlink" title="资源来源"></a>资源来源</h3><p>业务系统提供机器资源</p>
<p>定时任务平台提供机器资源</p>
<h3 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h3><ol>
<li>随机节点执行：选择一个可用执行节点执行</li>
<li>广播执行：在集群中的所有执行节点分发调度任务并执行，可用于批量运维</li>
<li>分片执行：按照用户自定义的分片逻辑进行拆分，分发到集群中的不同节点并行执行。</li>
</ol>
<p><img src="D:\Blog\source_images\image-20230213184303603.png" alt="image-20230213184303603"></p>
<p>高级特性：</p>
<ul>
<li>任务编排</li>
<li>故障转移<ul>
<li>通常通过一致性hash策略来分配任务，当某个Executor异常，会将未执行的任务进行<em><strong>re-hash</strong></em>分发到别的Executor</li>
</ul>
</li>
</ul>
<h3 id="高可用调度器"><a href="#高可用调度器" class="headerlink" title="高可用调度器"></a>高可用调度器</h3><p>调度器可以集群部署，因为调度器无状态，靠消息队列的重试机制保证任务一定会被调度</p>
<p><img src="D:\Blog\source_images\image-20230213184809941.png" alt="image-20230213184809941"></p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>在调度中心进行机器注册 –&gt; 执行器的弹性扩缩容</p>
<p>状态检测 –&gt; 定期上报状态</p>
<p><img src="D:\Blog\source_images\image-20230213185010100.png" alt="image-20230213185010100"></p>
]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Distributed System</title>
    <url>/2023/01/31/Distributed-System/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>优势:</p>
<ol>
<li>去中心化</li>
<li>低成本</li>
<li>弹性资源</li>
<li>资源共享</li>
<li>可靠性高</li>
</ol>
<p>挑战:</p>
<ol>
<li>普遍的节点故障</li>
<li>不可靠的网络</li>
<li>异构的机器和环境</li>
<li>安全</li>
</ol>
<h1 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h1><h1 id="共识和一致性"><a href="#共识和一致性" class="headerlink" title="共识和一致性"></a>共识和一致性</h1><p>Eventually Consistent</p>
<p>Linearizable</p>
<h1 id="时间和时间顺序"><a href="#时间和时间顺序" class="headerlink" title="时间和时间顺序"></a>时间和时间顺序</h1><p>happen before</p>
<p>Lamport逻辑时钟</p>
<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>C: Consistence (Strong consistence)</p>
<p>A: Availability</p>
<p>P: Network Partitioning</p>
<p>CA: 放弃分区容错性，加强一致性和可用性，即传统单机数据库</p>
<p>AP: 放弃一致性，追求一致性和可用性，用于注重用户体验的系统</p>
<p>CP: 放弃可用性，追求一致性和分区容错性，用于数据很关键的系统，例如银行系统</p>
<h2 id="ACID理论"><a href="#ACID理论" class="headerlink" title="ACID理论"></a>ACID理论</h2><p>transaction: 保证一个事务中的所有操作要么所有执行，要么所有不执行</p>
<p>A: Atomic, 所有的操作要么全部成功，要么全部失败回滚。强调<strong>操作</strong>。一定要保证。</p>
<p>C: Consistent, 数据库必须从一致性状态变换到另一个一致性(事务的一致性)状态。强调<strong>状态</strong>。一定要保证。</p>
<p>I: Isolation, 多个用户并发访问的时候，</p>
<p>D: Duration</p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>AP系统: </p>
<p>Basically Available(基本可用):</p>
<p>Soft State(软状态):</p>
<p>Eventually Consistent(最终一致性):</p>
<h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><h2 id="Quorum-NWR"><a href="#Quorum-NWR" class="headerlink" title="Quorum NWR"></a>Quorum NWR</h2><p>N: 在分布式存储系统中有多少个备份 </p>
<p>W: 一次成功的更新有多少次写入成功</p>
<p>R: 一次成功的读操作至少要求有R份数据成功读取</p>
<p>通常用于Append Only系统</p>
<p>Quorum NWR 将CAP的选择交给用户</p>
<h2 id="RAFT协议"><a href="#RAFT协议" class="headerlink" title="RAFT协议"></a>RAFT协议</h2><p>通常一个系统是一个leader和多个follower</p>
<p>Leader:</p>
<p>Follower:</p>
<p>Candidate:</p>
<p>Log: 节点之间的信息同步，之追加写的方式进行同步，解决了数据被覆盖的问题</p>
<p>Term: 单调递增，每个term内只能有一个leader</p>
<p>Committed: 日志被复制到多个节点，即认为Committed</p>
<p>Applied: 日志应用到了本地状态机</p>
<p>Leader选举过程：</p>
<ul>
<li>初始全部为Follower</li>
<li>Current Term + 1</li>
<li>选举自己</li>
<li>向其它参与者发起RequestVote请求，retry直到<ul>
<li>收到多数派请求，成为Leader，并发送心跳</li>
<li>收到其它Leader的请求，转为Follower，更新自己的Term</li>
<li>收到部分，但未达到多数派，选举超时，随机timeout开始下一轮</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Memory Model</title>
    <url>/2023/01/31/Go-Memory-Model/</url>
    <content><![CDATA[<h1 id="Memory-Model"><a href="#Memory-Model" class="headerlink" title="Memory Model"></a>Memory Model</h1><p>One example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> done <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">42</span></span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> setup()</span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>The example above may have 3 possibilities:</p>
<ul>
<li>print 42</li>
<li>never return</li>
<li>print 0</li>
</ul>
<p>Why:</p>
<ul>
<li><em>Reordering</em><ul>
<li>Compiler and Processor can reorder the instructions</li>
</ul>
</li>
<li><em>Memory Visibility</em><ul>
<li>Registers; L1, L2, shared L3 cache; CPU sockets</li>
</ul>
</li>
</ul>
<p><em>Go Concurrency Primitives</em>: Goroutines, Channels</p>
<p><em>Go memory model</em>: specifies the conditions under which read of a variable in one goroutine can observe values produced by writes to the same variable in another goroutine.</p>
<p><em>Data race</em>: write to a <em>memory location</em> happening <em>concurrently</em> with another <strong>read</strong> or <strong>write</strong> to that same location. Unless all the accesses involved are <strong>atomic</strong>.</p>
<h2 id="Within-a-Single-Goroutine"><a href="#Within-a-Single-Goroutine" class="headerlink" title="Within a Single Goroutine"></a>Within a Single Goroutine</h2><ul>
<li>Reads and writes must behave as if they <strong>executed in the order specified by the program</strong>.</li>
<li><strong>Compiler can reorder</strong> as long as it doesn’t change the behavior defined in the language specification.</li>
<li><strong>Order observed by one goroutine may differ from order perceived by another</strong>.<ul>
<li>goroutine 1 sets <code>a=1, b=2</code>, but goroutine 2 may see <code>b=2</code> first, and later see <code>a=1</code>.</li>
</ul>
</li>
</ul>
<h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h2><ul>
<li>Happens-Before is <strong>partial ordering of operations</strong></li>
<li>Happens-Before is <strong>transitive</strong></li>
<li>Within a single goroutine, happens-before order is the order expressed by program</li>
<li><strong>To guarantee a read of a variable observes a write to the same variable, the write must happen before the read</strong></li>
<li><strong>If two operation don’t have happen-before relation, they happen concurrently</strong></li>
<li><strong>Certain operation creates happen-before relation: lock, etc</strong></li>
</ul>
<h2 id="What-creates-happens-before"><a href="#What-creates-happens-before" class="headerlink" title="What creates happens-before"></a>What creates happens-before</h2><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>Program initialization runs in a single goroutine, but that goroutine may create other goroutines, which run concurrently.</p>
<p><em>If a package</em> <code>p</code> <em>imports package</em> <code>q</code><em>, the completion of</em> <code>q</code><em>‘s</em> <code>init</code> <em>functions happens before the start of any of</em> <code>p</code><em>‘s.</em></p>
<p><em>The completion of all</em> <code>init</code> <em>functions is synchronized before the start of the function</em> <code>main.main</code><em>.</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for example, if q import p, </span></span><br><span class="line"><span class="comment">// then p.init-&gt;q.init-&gt;main.main</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// q.go</span></span><br><span class="line"><span class="keyword">package</span> q</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;p&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p.go</span></span><br><span class="line"><span class="keyword">package</span> p</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Goroutine-Creation"><a href="#Goroutine-Creation" class="headerlink" title="Goroutine Creation"></a>Goroutine Creation</h3><p>The go statement that start a new goroutine <strong>happens before</strong> the goroutine’s execution begins</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span> <span class="comment">// happens before print statement</span></span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Goroutine-Destruction"><a href="#Goroutine-Destruction" class="headerlink" title="Goroutine Destruction"></a>Goroutine Destruction</h3><p>The exit of a goroutine is <strong>not guaranteed to be synchronized before any event</strong> in the program.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a = <span class="string">&quot;hello world&quot;</span> &#125;() </span><br><span class="line">    <span class="comment">// an aggressive compiler might even delete the entire go statement.</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel-Communication"><a href="#Channel-Communication" class="headerlink" title="Channel Communication"></a>Channel Communication</h3><p>A send on a channel <strong>happens before</strong> the corresponding receive from that channel completes.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span>	<span class="comment">// happens before the print statement</span></span><br><span class="line">    c &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    &lt;-c</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The closing of a channel <strong>happens before</strong> a receive that returns a zero value because the close is closed.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span>	<span class="comment">// happens before the print statement</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    &lt;-c</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A receive from an unbuffered channel <strong>happens before</strong> the send on that channel completes.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span>	<span class="comment">// happens before the print statement</span></span><br><span class="line">    &lt;-c	<span class="comment">// happens before the print statement(where send operation completes)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    c &lt;- <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>The</em> $k$th receive on a channel with capacity $C$ is synchronized before the completion of the $k+C$th send from that channel completes.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        w := w</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c &lt;- <span class="number">0</span></span><br><span class="line">            w()</span><br><span class="line">            &lt;-c</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h3><p><em>For any</em> <code>sync.Mutex</code> <em>or</em> <code>sync.RWMutex</code> <em>variable</em> <code>mu</code> <em>and</em> n &lt; m, call n <em>of</em> <code>mu.Unlock()</code> <em>is synchronized before call</em> m <em>of</em> <code>mu.Lock()</code> <em>returns.</em></p>
<p>For any call to <code>l.RLock</code> on a <code>sync.RWMutex</code> variable <code>l</code>, there is an <em>n</em> such that the <em>n</em>th call to <code>l.Unlock</code> is synchronized before the return from <code>l.RLock</code>, and the matching call to <code>l.RUnlock</code> is synchronized before the return from call <em>n</em>+1 to <code>l.Lock</code>.</p>
<p>A successful call to <code>l.TryLock</code> (or <code>l.TryRLock</code>) is equivalent to a call to <code>l.Lock</code> (or <code>l.RLock</code>). An unsuccessful call has no synchronizing effect at all. As far as the memory model is concerned, <code>l.TryLock</code> (or <code>l.TryRLock</code>) may be considered to be able to return false even when the mutex <em>l</em> is unlocked.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The first call to <code>mu.Unlock()</code> (in <code>f</code>) is synchronized before the second call to <code>mu.Lock()</code> (in <code>main</code>) returns, which is <em>sequenced before</em> the <code>print</code>.</p>
<h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>The <code>sync</code> package provides a safe mechanism for initialization in the presence of multiple goroutines through the use of the <code>Once</code> type. Multiple threads can execute <code>once.Do(f)</code> for a particular <code>f</code>, but only one will run <code>f()</code>, and the other calls block until <code>f()</code> has returned.</p>
<p>A completion of a single call of <code>f()</code> from <code>once.Do(f)</code> <strong>happens before</strong> any call of <code>once.Do(f)</code> returns</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span>	<span class="comment">//happens before the print</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    once.Do(setup)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Atomic-Values"><a href="#Atomic-Values" class="headerlink" title="Atomic Values"></a>Atomic Values</h3><p>If the effect of an atomic operation <em>A</em> is observed by atomic operation <em>B</em>, then <em>A</em> is synchronized before <em>B</em>. All the atomic operations executed in a program behave as though executed in some sequentially consistent order.</p>
<p>The definition of atomic values has the same semantics as C++’s sequentially consistent atomics and Java’s <code>volatile</code> variables.</p>
<h3 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h3><p>The <a href="https://go.dev/pkg/runtime/"><code>runtime</code></a> package provides a <code>SetFinalizer</code> function that adds a finalizer to be called when the object is no longer reachable by the program. Garbage Collector will clear the association and runs finalizer in a separate goroutine.</p>
<p>A call to <code>SetFinalizer(x, f)</code> is synchronized before the finalization call <code>f(x)</code>.</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><ul>
<li>Functions in the sync package<ul>
<li>Wait Groups</li>
<li>Allocation Pools</li>
<li>Condition Variables</li>
<li>Lock-Free Maps</li>
</ul>
</li>
</ul>
<h2 id="Why-Is-Data-Race-Harmful"><a href="#Why-Is-Data-Race-Harmful" class="headerlink" title="Why Is Data Race Harmful"></a>Why Is Data Race Harmful</h2><p>Data race is not ok, it doesn’t just give you stale values.</p>
<ul>
<li>Memory corruption</li>
<li>Panics<ul>
<li>unexpected fault address: 0x0</li>
<li>fatal error: concurrent map read and write</li>
</ul>
</li>
<li>May be fine now, but cause problems at any time</li>
<li>Program will break when compiler upgrades, switch OS, switch processor.<ul>
<li>compiler optimization strategy</li>
<li>different processors have different reordering strategies</li>
</ul>
</li>
</ul>
<h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">        instance = &amp;singleton&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Problems:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instance = &amp;singleton&#123;3, 4&#125;</span><br></pre></td></tr></table></figure>

<p>to</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := singleton&#123;&#125;</span><br><span class="line">s.x = <span class="number">3</span></span><br><span class="line">s.y = <span class="number">4</span></span><br><span class="line">instance = &amp;s</span><br></pre></td></tr></table></figure>

<p>can be reordered to</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := singleton&#123;&#125;</span><br><span class="line">instance = &amp;s</span><br><span class="line">s.x = <span class="number">3</span></span><br><span class="line">s.y = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>Assume there are 2 goroutines, goroutine 1 is executing <code>instance = &amp;s</code>, and at this point goroutine 2 sees that <code>instance != nil</code>, and returns it, and then get the partially created instance </p>
<p>Essence: synchronize the read and write</p>
<h1 id="Formal-Memory-Model"><a href="#Formal-Memory-Model" class="headerlink" title="Formal Memory Model"></a>Formal Memory Model</h1><h2 id="Memory-Operation"><a href="#Memory-Operation" class="headerlink" title="Memory Operation"></a>Memory Operation</h2><p>A memory operation is modeled by 4 details:</p>
<ul>
<li>its <strong>kind</strong>, indicating whether it is an <em>ordinary data read</em>, an <em>ordinary data write</em>, or a <em>synchronizing operation</em> such as an <em>atomic data access</em>, a <em>mutex operation</em>, or a <em>channel operation</em>,</li>
<li>its <strong>location</strong> in the program,</li>
<li>the <strong>memory location</strong> or variable being accessed,</li>
<li>the <strong>values</strong> read or written by the operation.</li>
</ul>
<p>Read-like operation: read, atomic read, <strong>mutex lock</strong>, and <strong>channel receive</strong>.</p>
<p>Write-like operation: write, atomic write, <strong>mutex unlock</strong>, <strong>channel send</strong>, and <strong>channel close</strong>.</p>
<p>Both read-like and write-like: atomic compare-and-swap.</p>
<p>A goroutine execution is a set of memory operations executed by a single goroutine.</p>
<h2 id="Requirement-of-Memory-Model"><a href="#Requirement-of-Memory-Model" class="headerlink" title="Requirement of Memory Model"></a>Requirement of Memory Model</h2><p>Requirements:</p>
<ol>
<li>The memory operations in each goroutine must correspond to a correct sequential execution of that goroutine. That execution must be consistent with the <em><strong>sequenced before</strong></em> relation.</li>
<li>For a given program execution, the mapping <em>W</em>, when limited to synchronizing operations, must be explainable by some implicit total order of the synchronizing operations that is consistent with sequencing and the values read and written by those operations.</li>
<li>For an ordinary (non-synchronizing) data read <em>r</em> on a memory location <em>x</em>, <em>W</em>(<em>r</em>) must be a write <em>w</em> that is <em>visible</em> to <em>r</em>, where visible means that both of the following hold:<ol>
<li><em>w</em> happens before <em>r</em>.</li>
<li><em>w</em> does not happen before any other write <em>w’</em> (to <em>x</em>) that happens before <em>r</em>.</li>
</ol>
</li>
</ol>
<p>The <em><strong>sequential before</strong></em> relation is the memory operation order within a single goroutine</p>
<p>The <em><strong>synchronized before</strong></em> relation is a partial order on synchronizing memory operations, derived from <em>W</em></p>
<p>The <em><strong>happens before</strong></em> relation is defined as the <strong>transitive closure</strong> of the union of the <strong>sequenced before</strong> and <strong>synchronized before</strong> relations.</p>
<p>A Go <em>program execution</em> is modeled as</p>
<ul>
<li>a set of goroutine executions,</li>
<li>together with a mapping <em>W</em> that specifies the write-like operation that each read-like operation reads from.</li>
</ul>
<h2 id="DRF-SC"><a href="#DRF-SC" class="headerlink" title="DRF-SC"></a>DRF-SC</h2><p><em>DRF-SC</em>: data-race-free programs execute in a sequentially consistent manner.</p>
<p><em>Data races</em>:</p>
<ul>
<li>A <em>read-write data race</em> on memory location <em>x</em> consists of a read-like memory operation <em>r</em> on <em>x</em> and a write-like memory operation <em>w</em> on <em>x</em>, at least one of which is non-synchronizing, which are unordered by happens before (that is, neither <em>r</em> happens before <em>w</em> nor <em>w</em> happens before <em>r</em>).</li>
<li>A <em>write-write data race</em> on memory location <em>x</em> consists of two write-like memory operations <em>w</em> and <em>w’</em> on <em>x</em>, at least one of which is non-synchronizing, which are unordered by happens before.</li>
</ul>
<p>Data-race-free program:</p>
<ul>
<li>A Go program without <em>read-write data race</em> and <em>write-write data race</em> is data-race-free.</li>
<li>It have outcomes explained by some sequentially consistent interleaving of the goroutine executions. </li>
<li>This property is called DRF-SC</li>
</ul>
<h2 id="Implementation-Restrictions-of-Data-Races"><a href="#Implementation-Restrictions-of-Data-Races" class="headerlink" title="Implementation Restrictions of Data Races"></a>Implementation Restrictions of Data Races</h2><p>First, any implementation can, upon detecting a data race, report the race and halt execution of the program. Implementations using ThreadSanitizer (accessed with “<code>go</code> <code>build</code> <code>-race</code>”) do exactly this.</p>
<p>Otherwise, a read <em>r</em> of a memory location <em>x</em> that is not larger than a machine word must observe some write <em>w</em> such that <em>r</em> does not happen before <em>w</em> and there is no write <em>w’</em> such that <em>w</em> happens before <em>w’</em> and <em>w’</em> happens before <em>r</em>. That is, each read must observe a value written by a preceding or concurrent write.</p>
<p>Additionally, observation of acausal and “out of thin air” writes is disallowed.</p>
<p>Reads of memory locations larger than a single machine word are encouraged but not required to meet the same semantics as word-sized memory locations, observing a single allowed write <em>w</em>. For performance reasons, implementations may instead treat larger operations as a set of individual machine-word-sized operations in an unspecified order. This means that races on multiword data structures can lead to inconsistent values not corresponding to a single write. When the values depend on the consistency of internal (pointer, length) or (pointer, type) pairs, as can be the case for interface values, maps, slices, and strings in most Go implementations, such races can in turn lead to arbitrary memory corruption.</p>
<h2 id="Implementation-Restriction-Example"><a href="#Implementation-Restriction-Example" class="headerlink" title="Implementation Restriction Example"></a>Implementation Restriction Example</h2><p>The Go memory model restricts compiler optimizations as much as it does Go programs. Some compiler optimizations that would be valid in single-threaded programs are not valid in all Go programs. </p>
<p>In particular, </p>
<ul>
<li>a compiler <strong>must not introduce writes that do not exist in the original program</strong>, </li>
<li>it <strong>must not allow a single read to observe multiple values</strong>, </li>
<li>and it <strong>must not allow a single write to write multiple values</strong>.</li>
</ul>
<p>Not introducing data races into race-free programs means not moving writes out of conditional statements in which they appear. </p>
<p>Not introducing data races also means not assuming that loops terminate. </p>
<p>Not introducing data races also means not assuming that called functions always return or are free of synchronization operations. </p>
<p>Not allowing a single read to observe multiple values means not reloading local variables from shared memory. </p>
<p>Not allowing a single write to write multiple values also means not using the memory where a local variable will be written as temporary storage before the write.</p>
<p>Note that all these optimizations are permitted in C&#x2F;C++ compilers: a Go compiler sharing a back end with a C&#x2F;C++ compiler must take care to disable optimizations that are invalid for Go.</p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>System Design</title>
    <url>/2023/01/30/System-Design/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><ul>
<li>软件整体结构和组件的抽象描述</li>
<li>用于指导软件系统各个方面的设计</li>
</ul>
<h2 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h2><p>所有功能都实现在一个进程中，并部署在一个机器上</p>
<p>问题：</p>
<ul>
<li>C10K problem</li>
<li>运维需要停服</li>
</ul>
<span id="more"></span>

<h2 id="单体架构-垂直应用架构"><a href="#单体架构-垂直应用架构" class="headerlink" title="单体架构 | 垂直应用架构"></a>单体架构 | 垂直应用架构</h2><p>单体：分布式部署，每个机器都有所有功能</p>
<p>垂直应用：分布式部署，按应用垂直切分的单体</p>
<p>优点：</p>
<ul>
<li>水平扩容</li>
<li>运维不需要停服</li>
</ul>
<p>缺点：</p>
<ul>
<li>职责太多，效率不高</li>
</ul>
<h2 id="SOA架构-微服务架构"><a href="#SOA架构-微服务架构" class="headerlink" title="SOA架构 | 微服务架构"></a>SOA架构 | 微服务架构</h2><p>SOA:</p>
<ul>
<li>将应用的不同功能单元抽象为服务</li>
<li>定义服务之间的通信标准</li>
</ul>
<p>微服务：SOA去中心化</p>
<p>问题：</p>
<ul>
<li>数据一致性</li>
<li>高可用：如何协同合作</li>
<li>治理：服务出错时的容灾</li>
<li>解耦 vs 过微：运维成本上升</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需求量增大 –&gt; 增加机器</p>
<p>需求复杂 –&gt; 分工工作</p>
<p>演进思路：</p>
<ul>
<li>垂直切分</li>
<li>水平切分: 耦合性降低，模块独立性变强</li>
</ul>
<h1 id="架构剖析"><a href="#架构剖析" class="headerlink" title="架构剖析"></a>架构剖析</h1><h2 id="Cloud-Computing"><a href="#Cloud-Computing" class="headerlink" title="Cloud Computing"></a>Cloud Computing</h2><p>云计算：通过<strong>软件自动化管理</strong>，<strong>提供计算资源</strong>的<strong>服务网络</strong></p>
<p>基础：</p>
<ul>
<li>虚拟化技术 - 整租 &amp; 合租</li>
<li>编排方案 - 业主 &amp; 租赁平台</li>
</ul>
<p>架构：</p>
<ul>
<li>IaaS (Infrastructure as a Service) –&gt; 房屋租赁平台 &amp; 买房子(繁琐)</li>
<li>PaaS (Platform as a Service) –&gt; 全包 &amp; 清包(繁琐)</li>
<li>SaaS (Software as a Service) –&gt; 雇佣培训过的师傅 &amp; 从零培训师傅(繁琐)</li>
<li>FaaS (Function as a Service) –&gt; 批量生产 &amp; 手工生产(繁琐)</li>
</ul>
<h2 id="Cloud-Native"><a href="#Cloud-Native" class="headerlink" title="Cloud Native"></a>Cloud Native</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Cloud Native:</p>
<ul>
<li>弹性资源<ul>
<li>虚拟化容器</li>
<li>快速扩缩容</li>
</ul>
</li>
<li>微服务架构<ul>
<li>业务的功能单元解耦</li>
<li>统一的通信标准</li>
</ul>
</li>
<li>DevOps<ul>
<li>Swift Development</li>
<li>CI&#x2F;CD</li>
</ul>
</li>
<li>服务网格<ul>
<li>业务与治理结构</li>
<li>异构系统的治理统一化</li>
<li>复杂治理能力</li>
</ul>
</li>
</ul>
<h3 id="弹性资源"><a href="#弹性资源" class="headerlink" title="弹性资源"></a>弹性资源</h3><p>弹性计算资源分类：</p>
<ul>
<li>服务资源调度 (占用资源量级)<ul>
<li>微服务 (使用量比较低)</li>
<li>大服务 (使用量比较高)</li>
</ul>
</li>
<li>计算资源调度<ul>
<li>在线: 榜单 </li>
<li>离线: 榜单更新</li>
</ul>
</li>
<li>消息队列<ul>
<li>在线: 削峰，解耦</li>
<li>离线: 大数据分析</li>
</ul>
</li>
</ul>
<p>弹性存储资源分类：</p>
<ul>
<li>经典<ul>
<li>对象: 宣传视频等</li>
<li>大数据: 用户消费记录</li>
</ul>
</li>
<li>关系型数据库<ul>
<li>收银记录</li>
</ul>
</li>
<li>元数据<ul>
<li>服务发现</li>
</ul>
</li>
<li>NoSQL<ul>
<li>KV数据</li>
</ul>
</li>
</ul>
<h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>云原生时代软件交付的工具</p>
<p><img src="D:\Blog\source_images\image-20230130173228027.png" alt="image-20230130173228027"></p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>通信标准：</p>
<ul>
<li>HTTP</li>
<li>RPC</li>
</ul>
<p>微服务中间件： RPC or HTTP</p>
<ul>
<li>性能: RPC wins</li>
<li>服务治理: RPC wins</li>
<li>协议可解释性: HTTP wins</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230130173731025.png" alt="image-20230130173731025"></p>
<h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><p>Service Mesh (服务网格)</p>
<ul>
<li>微服务之间通信的中间层</li>
<li>高性能网络代理</li>
<li>业务代码和服务网格解耦</li>
</ul>
<p>对比 RPC&#x2F;HTTP 框架</p>
<ul>
<li>异构系统治理统一化</li>
<li>与业务进程解耦，生命周期易于管理</li>
</ul>
<h2 id="架构挑战"><a href="#架构挑战" class="headerlink" title="架构挑战"></a>架构挑战</h2><ul>
<li>基础设施层面<ul>
<li>物理资源是有限的<ul>
<li>机器是有限的</li>
<li>带宽是有限的</li>
</ul>
</li>
<li>资源利用率受制于部署服务</li>
</ul>
</li>
<li>用户层面<ul>
<li>网络通信开销增大</li>
<li>网络抖动导致运维成本增高</li>
<li>异构环境下，不同实例资源水位不均</li>
</ul>
</li>
</ul>
<h2 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h2><h3 id="离在线资源并池"><a href="#离在线资源并池" class="headerlink" title="离在线资源并池"></a>离在线资源并池</h3><p>核心收益：降低物理资源成本，提供更多的弹性资源 –&gt; 合并在线池和离线池</p>
<p>在线业务的特点：</p>
<ul>
<li>IO 密集型为主</li>
<li>潮汐性，实时性</li>
</ul>
<p>离线业务的特点：</p>
<ul>
<li>计算密集型</li>
<li>非实时性</li>
</ul>
<h3 id="资源的扩缩容"><a href="#资源的扩缩容" class="headerlink" title="资源的扩缩容"></a>资源的扩缩容</h3><p>利用在线业务的潮汐性做自动扩缩容，结合离在线资源并池</p>
<h3 id="微服务的亲和性部署"><a href="#微服务的亲和性部署" class="headerlink" title="微服务的亲和性部署"></a>微服务的亲和性部署</h3><ul>
<li>将满足亲和性条件的容器调度到一台宿主机</li>
<li>微服务中间件和服务网格通过共享内存或IPC方式通信</li>
<li>服务网格控制面实施动态灵活的流量调度</li>
</ul>
<h3 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h3><ul>
<li>提高微服务的容错性</li>
<li>容灾</li>
<li>提高开发效率</li>
</ul>
<p>解决思路：基于微服务的中间件 &amp; 服务网格的流量治理</p>
<ul>
<li>熔断、重试</li>
<li>单元化</li>
<li>复杂环境(功能、预览)的流量调度</li>
</ul>
<h3 id="CPU水位负载均衡"><a href="#CPU水位负载均衡" class="headerlink" title="CPU水位负载均衡"></a>CPU水位负载均衡</h3><p>核心收益：</p>
<ul>
<li>异构环境算力差异</li>
<li>自动扩缩容</li>
</ul>
<p>解决思路：CPU水位负载均衡</p>
<ul>
<li>IaaS: 提供资源探针</li>
<li>服务网格: 动态负载均衡</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230130225126408.png" alt="image-20230130225126408"></p>
<h1 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h1>]]></content>
      <tags>
        <tag>System</tag>
      </tags>
  </entry>
  <entry>
    <title>gorm</title>
    <url>/2023/01/24/gorm/</url>
    <content><![CDATA[<h1 id="GORM"><a href="#GORM" class="headerlink" title="GORM"></a>GORM</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">APP --&gt; gorm --&gt; database/sql --&gt; 数据库</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="SQL生成"><a href="#SQL生成" class="headerlink" title="SQL生成"></a>SQL生成</h2><p>gorm statement: chain method(GORM Clauses) + finish method(决定类型&amp;执行)</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>对于finish method来说，调用一系列callback注册的方法</p>
<p>例如，对于Create方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:begin_transaction&quot;</span>, BeginTransaction)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:before_create&quot;</span>, BeforeCreate)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:save_before_associations&quot;</span>, SaveBeforeAssociations)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:create&quot;</span>, Create)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:save_after_associations&quot;</span>, SaveAfterAssociations)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:after_create&quot;</span>, AfterCreate)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:commit_or_rollback_transaction&quot;</span>, CommitOrRollbackTransaction)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// pseudo code</span></span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> db.callbacks.creates &#123;</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展插件系统：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Callback.Create().Register(<span class="string">&quot;&quot;</span>, fn)</span><br><span class="line"><span class="comment">// Remove</span></span><br><span class="line"><span class="comment">// Replace</span></span><br><span class="line"><span class="comment">// Get</span></span><br><span class="line"><span class="comment">// Before, After</span></span><br></pre></td></tr></table></figure>

<h2 id="ConnPool"><a href="#ConnPool" class="headerlink" title="ConnPool"></a>ConnPool</h2><h2 id="Dialector"><a href="#Dialector" class="headerlink" title="Dialector"></a>Dialector</h2>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd</title>
    <url>/2023/01/23/etcd/</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="etcd-简介"><a href="#etcd-简介" class="headerlink" title="etcd 简介"></a>etcd 简介</h2><p>A distributed, reliable key-value store for critical data of distributed systems</p>
<ul>
<li>分布式键值存储</li>
<li>配置共享</li>
<li>服务发现</li>
<li>分布式锁</li>
<li>分布式队列</li>
<li>分布式通知与协调</li>
<li>主备选举</li>
</ul>
<span id="more"></span>

<h2 id="etcd-架构"><a href="#etcd-架构" class="headerlink" title="etcd 架构"></a>etcd 架构</h2><p><img src="D:\Blog\source_images\image-20230123211311435.png" alt="image-20230123211311435"></p>
<h2 id="etcd-集群部署"><a href="#etcd-集群部署" class="headerlink" title="etcd 集群部署"></a>etcd 集群部署</h2><h3 id="单节点伪集群部署"><a href="#单节点伪集群部署" class="headerlink" title="单节点伪集群部署"></a>单节点伪集群部署</h3><p>etcd参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>–name</td>
<td>etcd节点名</td>
</tr>
<tr>
<td>–initial-cluster</td>
<td>etcd启动时，通过这个配置找到别的etcd节点的地址列表。格式“name&#x3D;<a href="http://ip:port,...”">http://ip:port,...”</a></td>
</tr>
<tr>
<td>–initial-cluster-state</td>
<td>初始化集群的时候，存在“new”和“existing”两种状态。new表示新建的集群，existing表示加入已存在的集群</td>
</tr>
<tr>
<td>–listen-client-urls</td>
<td>监听客户端请求的地址列表。格式“<a href="http://ip:port,...”">http://ip:port,...”</a></td>
</tr>
<tr>
<td>–advertise-client-urls</td>
<td>从多个listen-client-urls中选出一个建议的监听地址</td>
</tr>
<tr>
<td>-listen-peer-urls</td>
<td>服务端节点之间通信的监听地址。格式“<a href="http://ip:port”">http://ip:port”</a></td>
</tr>
<tr>
<td>–initial-listen-peer-urls</td>
<td>建议服务端之间通讯使用的地址列表</td>
</tr>
</tbody></table>
<h3 id="多节点集群部署"><a href="#多节点集群部署" class="headerlink" title="多节点集群部署"></a>多节点集群部署</h3><ul>
<li><p>静态配置</p>
<ul>
<li>节点数量已知</li>
<li>节点的ip地址已知</li>
</ul>
</li>
<li><p>etcd动态发现</p>
<ul>
<li>使用<code>curl https://discovery.etcd.io/new?size=3</code>获取三个节点的动态集群</li>
<li>使用<code>--discovery $&#123;DISCOVERY&#125;</code>添加集群节点</li>
<li>不需要指定<code>--initial-cluster</code></li>
</ul>
</li>
</ul>
<p><code>etcdctl --endpoints=$ENDPOINTS member list</code> 可以列出一个集群中所有的节点信息</p>
]]></content>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC</title>
    <url>/2023/01/22/gRPC/</url>
    <content><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><img src="D:\Blog\source_images\image-20230122215840994.png" alt="image-20230122215840994"></p>
<p>缺点：</p>
<ul>
<li>隔离性差，某个服务的宕机会导致所有服务不可用</li>
<li>伸缩性差，只能整体服务进行伸缩</li>
<li>代码耦合在一起，可维护性差</li>
</ul>
<p>解决方案：微服务</p>
<span id="more"></span>

<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="D:\Blog\source_images\image-20230122220029728.png" alt="image-20230122220029728"></p>
<p>微服务架构解决了单体架构的一些致命问题，但是又引入了新的问题：</p>
<ul>
<li>代码冗余，一些公共代码存在于多个服务集群中</li>
<li>服务与服务之间存在调用关系</li>
</ul>
<h3 id="代码冗余问题"><a href="#代码冗余问题" class="headerlink" title="代码冗余问题"></a>代码冗余问题</h3><p>服务未拆分以前，公共功能有统一的实现，如认证、限流、授权等，服务拆分以后，每个服务可能都需要实现一遍</p>
<p>解决方案：</p>
<ul>
<li>使用网关，保证对外的出口一致性，网关根据不同的请求，将其转发到不同的服务(路由)<ul>
<li>由于出口的一致性，可以在网关上实现一些公共功能</li>
</ul>
</li>
<li>可以将公共功能抽取出来，形成一个新的服务，如统一认证中心</li>
</ul>
<h3 id="服务之间的调用"><a href="#服务之间的调用" class="headerlink" title="服务之间的调用"></a>服务之间的调用</h3><p>使用RPC进行调用，但是存在一个问题：如何直到调用哪台机器上的服务，调用方可能需要维护被调用方的地址，等。因此需要引入<strong>服务治理</strong></p>
<p><img src="D:\Blog\source_images\image-20230122223050971.png" alt="image-20230122223050971"></p>
<p><code>服务注册</code>，服务方将服务注册到注册中心</p>
<p><code>服务发现</code>，向注册中心请求服务的地址</p>
<blockquote>
<p>服务与服务之间的调用会发生一些问题，为了避免连锁的雪崩反应，引入<code>服务容错</code></p>
<p>为了追踪调用经过的服务，需要引入<code>链路追踪</code></p>
</blockquote>
]]></content>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Protocol Buffer</title>
    <url>/2023/01/20/Protocol-Buffer/</url>
    <content><![CDATA[<h1 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Field-Numbers"><a href="#Field-Numbers" class="headerlink" title="Field Numbers"></a>Field Numbers</h3><ul>
<li>Field numbers in the range 1 through 15 take one byte to encode</li>
<li>Field numbers in the range 16 through 2047 take two bytes</li>
<li>Field numbers through 19000 to 19999 is reserved for implementation</li>
<li>Largest field number is $2^{29}-1$, or $536,870,911$</li>
</ul>
<span id="more"></span>

<h3 id="Field-Rules"><a href="#Field-Rules" class="headerlink" title="Field Rules"></a>Field Rules</h3><ul>
<li><code>singular</code>: a well-formed message can have zero or one of this field<ul>
<li>Whether or not it’s parsed from the wire cannot be determined</li>
<li>When set to default value, it will not be included when serializing</li>
</ul>
</li>
<li><code>optional</code>: the same as <code>singular</code>, except it check whether the value was explicitly set.<ul>
<li>If the field is set, and contains a value that was explicitly set or parsed from the wire. It will be serialized to the wire.</li>
<li>If the field is unset, it will return the default value, and will not be serialized to the wire.</li>
</ul>
</li>
<li><code>repeated</code>: this field type can be repeated zero or more times in a well-formed message.</li>
<li><code>map</code>: this is a paired key&#x2F;value field type.</li>
</ul>
<h3 id="Scalar-Value-Types"><a href="#Scalar-Value-Types" class="headerlink" title="Scalar Value Types"></a>Scalar Value Types</h3><table>
<thead>
<tr>
<th align="left">.proto Type</th>
<th align="left">Notes</th>
<th align="left">C++ Type</th>
<th align="left">Java&#x2F;Kotlin Type</th>
<th align="left">Python Type</th>
<th align="left">Go Type</th>
<th align="left">Ruby Type</th>
<th align="left">C# Type</th>
<th align="left">PHP Type</th>
<th align="left">Dart Type</th>
</tr>
</thead>
<tbody><tr>
<td align="left">double</td>
<td align="left"></td>
<td align="left">double</td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">float64</td>
<td align="left">Float</td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left"></td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">float32</td>
<td align="left">Float</td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">int32</td>
<td align="left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">int32</td>
<td align="left">Fixnum or Bignum (as required)</td>
<td align="left">int</td>
<td align="left">integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">int64</td>
<td align="left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long</td>
<td align="left">int64</td>
<td align="left">Bignum</td>
<td align="left">long</td>
<td align="left">integer&#x2F;string</td>
<td align="left">Int64</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">Uses variable-length encoding.</td>
<td align="left">uint32</td>
<td align="left">int</td>
<td align="left">int&#x2F;long</td>
<td align="left">uint32</td>
<td align="left">Fixnum or Bignum (as required)</td>
<td align="left">uint</td>
<td align="left">integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">Uses variable-length encoding.</td>
<td align="left">uint64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long</td>
<td align="left">uint64</td>
<td align="left">Bignum</td>
<td align="left">ulong</td>
<td align="left">integer&#x2F;string</td>
<td align="left">Int64</td>
</tr>
<tr>
<td align="left">sint32</td>
<td align="left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">int32</td>
<td align="left">Fixnum or Bignum (as required)</td>
<td align="left">int</td>
<td align="left">integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">sint64</td>
<td align="left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long</td>
<td align="left">int64</td>
<td align="left">Bignum</td>
<td align="left">long</td>
<td align="left">integer&#x2F;string</td>
<td align="left">Int64</td>
</tr>
<tr>
<td align="left">fixed32</td>
<td align="left">Always four bytes. More efficient than uint32 if values are often greater than 228.</td>
<td align="left">uint32</td>
<td align="left">int</td>
<td align="left">int&#x2F;long</td>
<td align="left">uint32</td>
<td align="left">Fixnum or Bignum (as required)</td>
<td align="left">uint</td>
<td align="left">integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">fixed64</td>
<td align="left">Always eight bytes. More efficient than uint64 if values are often greater than 256.</td>
<td align="left">uint64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long</td>
<td align="left">uint64</td>
<td align="left">Bignum</td>
<td align="left">ulong</td>
<td align="left">integer&#x2F;string</td>
<td align="left">Int64</td>
</tr>
<tr>
<td align="left">sfixed32</td>
<td align="left">Always four bytes.</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">int32</td>
<td align="left">Fixnum or Bignum (as required)</td>
<td align="left">int</td>
<td align="left">integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">sfixed64</td>
<td align="left">Always eight bytes.</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long</td>
<td align="left">int64</td>
<td align="left">Bignum</td>
<td align="left">long</td>
<td align="left">integer&#x2F;string</td>
<td align="left">Int64</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left"></td>
<td align="left">bool</td>
<td align="left">boolean</td>
<td align="left">bool</td>
<td align="left">bool</td>
<td align="left">TrueClass&#x2F;FalseClass</td>
<td align="left">bool</td>
<td align="left">boolean</td>
<td align="left">bool</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.</td>
<td align="left">string</td>
<td align="left">String</td>
<td align="left">str&#x2F;unicode</td>
<td align="left">string</td>
<td align="left">String (UTF-8)</td>
<td align="left">string</td>
<td align="left">string</td>
<td align="left">String</td>
</tr>
<tr>
<td align="left">bytes</td>
<td align="left">May contain any arbitrary sequence of bytes no longer than 232.</td>
<td align="left">string</td>
<td align="left">ByteString</td>
<td align="left">str (Python 2) bytes (Python 3)</td>
<td align="left">[]byte</td>
<td align="left">String (ASCII-8BIT)</td>
<td align="left">ByteString</td>
<td align="left">string</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="Default-Values"><a href="#Default-Values" class="headerlink" title="Default Values"></a>Default Values</h3><p>The default value for repeated fields is empty</p>
<p>Default value for message type is dependent on languages</p>
<p>For scalar message fields, once a message is parsed there’s <strong>no way of telling whether a field was explicitly set to the default value</strong></p>
<h3 id="Enumerations"><a href="#Enumerations" class="headerlink" title="Enumerations"></a>Enumerations</h3><p>enum’s first constant must map to zero</p>
<p><code>option allow_alias = true;</code> can be used to define alias</p>
<h3 id="Importing-Definitions"><a href="#Importing-Definitions" class="headerlink" title="Importing Definitions"></a>Importing Definitions</h3><p><code>import public &quot;xx.proto&quot;</code> will allow proto files which import this proto file to use the definitions in xx.proto. </p>
<h2 id="Updating-a-Message-Type"><a href="#Updating-a-Message-Type" class="headerlink" title="Updating a Message Type"></a>Updating a Message Type</h2><p>Changing, adding, or removing fields:</p>
<ul>
<li><strong>Don’t change the field numbers</strong> for any existing fields.</li>
<li>When <strong>adding new fields</strong><ul>
<li>old message format can be parsed by new code (but new code should take care of default value)</li>
<li>new message format can be parsed by old code (old code just ignore the new fields)</li>
</ul>
</li>
<li>Fields can be removed when the fields are no longer used<ul>
<li>the field name and tag should be reserved</li>
<li>or add OBSELETE_ prefix to the field name</li>
</ul>
</li>
</ul>
<p>Compatible types:</p>
<ul>
<li><code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, and <code>bool</code> are all compatible</li>
<li><code>sint32</code> and <code>sint64</code> are compatible with each other</li>
<li><code>string</code> and <code>bytes</code> are compatible as long as the bytes are valid UTF-8</li>
<li><code>Embedded messages</code> are compatible with <code>bytes</code> if <strong>the bytes contain an encoded version of the message</strong></li>
<li><code>fixed32</code> is compatible with <code>sfixed32</code>, and <code>fixed64</code> with <code>sfixed64</code></li>
<li>For <code>string</code>, <code>bytes</code>, and <code>message fields</code>, <code>singular</code> fields are compatible with <code>repeated</code> fields<ul>
<li>For serialized repeated data as input, clients who expect singular field will take the last input.</li>
<li>not safe for numeric types, such as <code>int</code>, <code>bool</code>, and <code>enum</code>. Because repeated fields of numeric types can be serialized in the <a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">packed</a> format, which will not be parsed correctly when a singular field is expected.</li>
</ul>
</li>
</ul>
<p>Binary compatible but possibly API incompatible types:</p>
<ul>
<li><code>enum</code> is compatible with <code>int32</code>, <code>uint32</code>, <code>int64</code>, and <code>uint64</code> in terms of wire format<ul>
<li>But client code may treat them differently when the message is deserialized</li>
</ul>
</li>
<li>Changing a single <code>optional</code> field or extension into a member of a <strong>new</strong> <code>oneof</code> is binary compatible<ul>
<li>For Go, the API will change in incompatible ways</li>
</ul>
</li>
</ul>
<h2 id="Unknown-Fields"><a href="#Unknown-Fields" class="headerlink" title="Unknown Fields"></a>Unknown Fields</h2><ul>
<li>Before versions 3.5, unknown fields are <strong>discarded</strong></li>
<li>In versions 3.5 and later, unknown fields are <strong>retained</strong> and included in the serialized output.</li>
</ul>
<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p><code>Any</code> message type:</p>
<ul>
<li>allow using messages as embedded types without having their .proto definition</li>
<li>contains <code>bytes</code> and a <code>URL</code> which is unique identifier to that message’s type</li>
<li>to use <code>Any</code>, <code>&quot;google/protobuf/any.proto&quot;</code> should be imported</li>
<li>default type URL for a given message type is <code>type.googleapis.com/_packagename_._messagename_</code></li>
</ul>
<h2 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><p>When at most one field will be set at the same time, use oneof to enforce this behavior and save memory.</p>
<ul>
<li>Oneof fields are like regular fields</li>
<li>All the fields in a oneof share memory</li>
<li>At most one field in oneof can be set at the same time</li>
<li>if <em>multiple values are set, the last set value as determined by the order in the proto will overwrite all previous ones</em>.</li>
<li>Oneof fields can be any type except <code>map</code> and <code>repeated</code> fields</li>
<li>If you set a oneof field to the default value (such as setting an int32 oneof field to 0), the “case” of that oneof field will be set, and the value will be serialized on the wire.</li>
</ul>
<h3 id="Compatibility-Issue"><a href="#Compatibility-Issue" class="headerlink" title="Compatibility Issue"></a>Compatibility Issue</h3><p>Adding or Removing Fields:</p>
<ul>
<li>removing a field from a oneof is considered a <strong>backward incompatible</strong> change. <ul>
<li>new version binary cannot process old version message</li>
<li>the information that may be lost is whether the oneof was really set or not</li>
</ul>
</li>
<li>adding a field to a oneof is considered a <strong>forward incompatible</strong> change<ul>
<li>old version binary cannot process new version message, just reverse of removing a field</li>
</ul>
</li>
</ul>
<p>Moving Fields:</p>
<ul>
<li>Moving fields out of a oneof:<ul>
<li>move a single field into a new oneof –&gt; safe</li>
<li>move multiple fields into a new oneof<ul>
<li>considered backward incompatible</li>
<li>but it can be safe when it is known that only one of the fields will be set</li>
</ul>
</li>
<li>move fields into a oneof<ul>
<li>same as “move multiple fields into a new oneof”</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Deleting a Oneof Fields and Add It Back</p>
<ul>
<li>similar to Removing Fields, but this situation there are 3 versions</li>
</ul>
<p>Splitting or Merging a Oneof</p>
<ul>
<li>similar to Moving Existing Fields into Oneof, backward incompatible.</li>
</ul>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><h3 id="Features-1"><a href="#Features-1" class="headerlink" title="Features"></a>Features</h3><p><code>map&lt;key_type, value_type&gt; map_field = N;</code> will create a map field.</p>
<ul>
<li><code>key_type</code> can be <strong>integral type or string type</strong> (any scalar types except <strong>floating point</strong> and **bytes **type)</li>
<li><code>value_type</code> can be any type except another map type</li>
<li>map fields cannot be repeated</li>
<li>When parsing from wire, the last seen is used when there are duplicate keys</li>
</ul>
<h3 id="Backward-Compatibility"><a href="#Backward-Compatibility" class="headerlink" title="Backward Compatibility"></a>Backward Compatibility</h3><p>The map syntax is equivalent to the following on the wire</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">MapFieldEntry</span> &#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeated</span> MapFieldEntry map_field = N;</span><br></pre></td></tr></table></figure>

<h2 id="Defining-a-Service"><a href="#Defining-a-Service" class="headerlink" title="Defining a Service"></a>Defining a Service</h2><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Search(SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JSON-Mapping"><a href="#JSON-Mapping" class="headerlink" title="JSON Mapping"></a>JSON Mapping</h2><p>When parsing JSON-encoded data into a protocol buffer</p>
<ul>
<li>if a value is missing or if its value is <code>null</code>, it will be corresponding <a href="https://developers.google.com/protocol-buffers/docs/proto3#default">default value</a>.</li>
</ul>
<p>When generating JSON-encoded output from a protocol buffer</p>
<ul>
<li>if a protobuf field has a default value will be omitted</li>
<li>A field that is defined with the <code>optional</code> keyword supports field presence.</li>
</ul>
<table>
<thead>
<tr>
<th align="left">proto3</th>
<th align="left">JSON</th>
<th align="left">JSON example</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">message</td>
<td align="left">object</td>
<td align="left"><code>&#123;&quot;fooBar&quot;: v, &quot;g&quot;: null, …&#125;</code></td>
<td align="left">Generates JSON objects. Message field names are mapped to lowerCamelCase and become JSON object keys. If the <code>json_name</code> field option is specified, the specified value will be used as the key instead. Parsers accept both the lowerCamelCase name (or the one specified by the <code>json_name</code> option) and the original proto field name. <code>null</code> is an accepted value for all field types and treated as the default value of the corresponding field type.</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left">string</td>
<td align="left"><code>&quot;FOO_BAR&quot;</code></td>
<td align="left">The name of the enum value as specified in proto is used. Parsers accept both enum names and integer values.</td>
</tr>
<tr>
<td align="left">map&lt;K,V&gt;</td>
<td align="left">object</td>
<td align="left"><code>&#123;&quot;k&quot;: v, …&#125;</code></td>
<td align="left">All keys are converted to strings.</td>
</tr>
<tr>
<td align="left">repeated V</td>
<td align="left">array</td>
<td align="left"><code>[v, …]</code></td>
<td align="left"><code>null</code> is accepted as the empty list <code>[]</code>.</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left">true, false</td>
<td align="left"><code>true, false</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">string</td>
<td align="left"><code>&quot;Hello World!&quot;</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">bytes</td>
<td align="left">base64 string</td>
<td align="left"><code>&quot;YWJjMTIzIT8kKiYoKSctPUB+&quot;</code></td>
<td align="left">JSON value will be the data encoded as a string using standard base64 encoding with paddings. Either standard or URL-safe base64 encoding with&#x2F;without paddings are accepted.</td>
</tr>
<tr>
<td align="left">int32, fixed32, uint32</td>
<td align="left">number</td>
<td align="left"><code>1, -10, 0</code></td>
<td align="left">JSON value will be a decimal number. Either numbers or strings are accepted.</td>
</tr>
<tr>
<td align="left">int64, fixed64, uint64</td>
<td align="left">string</td>
<td align="left"><code>&quot;1&quot;, &quot;-10&quot;</code></td>
<td align="left">JSON value will be a decimal string. Either numbers or strings are accepted.</td>
</tr>
<tr>
<td align="left">float, double</td>
<td align="left">number</td>
<td align="left"><code>1.1, -10.0, 0, &quot;NaN&quot;, &quot;Infinity&quot;</code></td>
<td align="left">JSON value will be a number or one of the special string values “NaN”, “Infinity”, and “-Infinity”. Either numbers or strings are accepted. Exponent notation is also accepted. -0 is considered equivalent to 0.</td>
</tr>
<tr>
<td align="left">Any</td>
<td align="left"><code>object</code></td>
<td align="left"><code>&#123;&quot;@type&quot;: &quot;url&quot;, &quot;f&quot;: v, … &#125;</code></td>
<td align="left">If the <code>Any</code> contains a value that has a special JSON mapping, it will be converted as follows: <code>&#123;&quot;@type&quot;: xxx, &quot;value&quot;: yyy&#125;</code>. Otherwise, the value will be converted into a JSON object, and the <code>&quot;@type&quot;</code> field will be inserted to indicate the actual data type.</td>
</tr>
<tr>
<td align="left">Timestamp</td>
<td align="left">string</td>
<td align="left"><code>&quot;1972-01-01T10:00:20.021Z&quot;</code></td>
<td align="left">Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits. Offsets other than “Z” are also accepted.</td>
</tr>
<tr>
<td align="left">Duration</td>
<td align="left">string</td>
<td align="left"><code>&quot;1.000340012s&quot;, &quot;1s&quot;</code></td>
<td align="left">Generated output always contains 0, 3, 6, or 9 fractional digits, depending on required precision, followed by the suffix “s”. Accepted are any fractional digits (also none) as long as they fit into nano-seconds precision and the suffix “s” is required.</td>
</tr>
<tr>
<td align="left">Struct</td>
<td align="left"><code>object</code></td>
<td align="left"><code>&#123; … &#125;</code></td>
<td align="left">Any JSON object. See <code>struct.proto</code>.</td>
</tr>
<tr>
<td align="left">Wrapper types</td>
<td align="left">various types</td>
<td align="left"><code>2, &quot;2&quot;, &quot;foo&quot;, true, &quot;true&quot;, null, 0, …</code></td>
<td align="left">Wrappers use the same representation in JSON as the wrapped primitive type, except that <code>null</code> is allowed and preserved during data conversion and transfer.</td>
</tr>
<tr>
<td align="left">FieldMask</td>
<td align="left">string</td>
<td align="left"><code>&quot;f.fooBar,h&quot;</code></td>
<td align="left">See <code>field_mask.proto</code>.</td>
</tr>
<tr>
<td align="left">ListValue</td>
<td align="left">array</td>
<td align="left"><code>[foo, bar, …]</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Value</td>
<td align="left">value</td>
<td align="left"></td>
<td align="left">Any JSON value. Check <a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value">google.protobuf.Value</a> for details.</td>
</tr>
<tr>
<td align="left">NullValue</td>
<td align="left">null</td>
<td align="left"></td>
<td align="left">JSON null</td>
</tr>
<tr>
<td align="left">Empty</td>
<td align="left">object</td>
<td align="left"><code>&#123;&#125;</code></td>
<td align="left">An empty JSON object</td>
</tr>
</tbody></table>
<h1 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h1><h2 id="Principles"><a href="#Principles" class="headerlink" title="Principles"></a>Principles</h2><table>
<thead>
<tr>
<th align="left">ID</th>
<th align="left">Name</th>
<th align="left">Used For</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">VARINT</td>
<td align="left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">I64</td>
<td align="left">fixed64, sfixed64, double</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">LEN</td>
<td align="left">string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">SGROUP</td>
<td align="left">group start (deprecated)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">EGROUP</td>
<td align="left">group end (deprecated)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">I32</td>
<td align="left">fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message    := (tag value)*</span><br><span class="line"></span><br><span class="line">tag        := (field &lt;&lt; 3) bit-or wire_type;</span><br><span class="line">                encoded as varint</span><br><span class="line">value      := varint      for wire_type == VARINT,</span><br><span class="line">              i32         for wire_type == I32,</span><br><span class="line">              i64         for wire_type == I64,</span><br><span class="line">              len-prefix  for wire_type == LEN,</span><br><span class="line">              &lt;empty&gt;     for wire_type == SGROUP or EGROUP</span><br><span class="line"></span><br><span class="line">varint     := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64;</span><br><span class="line">                encoded as varints (sintN are ZigZag-encoded first)</span><br><span class="line">i32        := sfixed32 | fixed32 | float;</span><br><span class="line">                encoded as 4-byte little-endian;</span><br><span class="line">                memcpy of the equivalent C types (u?int32_t, float)</span><br><span class="line">i64        := sfixed64 | fixed64 | double;</span><br><span class="line">                encoded as 8-byte little-endian;</span><br><span class="line">                memcpy of the equivalent C types (u?int32_t, float)</span><br><span class="line"></span><br><span class="line">len-prefix := size (message | string | bytes | packed);</span><br><span class="line">                size encoded as varint</span><br><span class="line">string     := valid UTF-8 string (e.g. ASCII);</span><br><span class="line">                max 2GB of bytes</span><br><span class="line">bytes      := any sequence of 8-bit bytes;</span><br><span class="line">                max 2GB of bytes</span><br><span class="line">packed     := varint* | i32* | i64*,</span><br><span class="line">                consecutive values of the type specified in `.proto`</span><br></pre></td></tr></table></figure>

<h1 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h1><h2 id="Steaming-Multiple-Messages"><a href="#Steaming-Multiple-Messages" class="headerlink" title="Steaming Multiple Messages"></a>Steaming Multiple Messages</h2><p>Similar to HTTP &amp; TCP, </p>
<ul>
<li>use bytes to transfer data</li>
<li>define the format of data</li>
<li>extract information from the data according to the format.</li>
</ul>
<h2 id="Large-Data-Sets"><a href="#Large-Data-Sets" class="headerlink" title="Large Data Sets"></a>Large Data Sets</h2><p>divide large data structure to smaller ones</p>
<h2 id="Self-Describing-Messages"><a href="#Self-Describing-Messages" class="headerlink" title="Self-Describing Messages"></a>Self-Describing Messages</h2><p>use <code>import &quot;google/protobuf/descriptor.proto&quot;</code></p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/descriptor.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SelfDescribingMessage</span> &#123;</span><br><span class="line">  <span class="comment">// Set of FileDescriptorProtos which describe the type and its dependencies.</span></span><br><span class="line">  google.protobuf.FileDescriptorSet descriptor_set = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The message and its type, encoded as an Any message.</span></span><br><span class="line">  google.protobuf.Any message = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Fields-Presence"><a href="#Fields-Presence" class="headerlink" title="Fields Presence"></a>Fields Presence</h1><h2 id="Presence-Disciplines"><a href="#Presence-Disciplines" class="headerlink" title="Presence Disciplines"></a>Presence Disciplines</h2><p>Presence defines the <strong>semantics of translating</strong> between API representations and serialized representation</p>
<ul>
<li>The <em>no presence</em> discipline <strong>relies upon the field value</strong> to make decisions at (de)serialization time</li>
<li>The <em>explicit presence</em> discipline <strong>relies upon the explicit tracking state</strong></li>
</ul>
<h2 id="Presence-in-Wire-Format"><a href="#Presence-in-Wire-Format" class="headerlink" title="Presence in Wire Format"></a>Presence in Wire Format</h2><p>When serializing</p>
<ul>
<li>fields with <em>no presence</em> are not serialized if they contain their default value</li>
<li>fields with <em>presence</em> are serialized although they contain their default value</li>
</ul>
<p>When deserializing</p>
<ul>
<li>duplicate field values may be handled in different ways depending on the field definition<ul>
<li>Duplicate <code>repeated</code> fields are typically appended</li>
<li>Duplicate <code>optional</code> fields follows ‘the last one wins’ rules</li>
</ul>
</li>
<li>For enum fields, <em><strong>out-of-range values may be stored as unknown fields in the API</strong></em>, <strong>even though the wire-format tag was recognized</strong>.</li>
</ul>
<h2 id="Presence-in-Proto-3"><a href="#Presence-in-Proto-3" class="headerlink" title="Presence in Proto 3"></a>Presence in Proto 3</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Field type</td>
<td><code>optional</code></td>
<td>Explicit Presence</td>
</tr>
<tr>
<td>Singular numeric (integer or floating point)</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>Singular enum</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>Singular string or bytes</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>Singular numeric (integer or floating point)</td>
<td>Yes</td>
<td>✔️</td>
</tr>
<tr>
<td>Singular enum</td>
<td>Yes</td>
<td>✔️</td>
</tr>
<tr>
<td>Singular string or bytes</td>
<td>Yes</td>
<td>✔️</td>
</tr>
<tr>
<td>Singular message</td>
<td>Yes</td>
<td>✔️</td>
</tr>
<tr>
<td>Singular message</td>
<td>No</td>
<td>✔️</td>
</tr>
<tr>
<td>Repeated</td>
<td>N&#x2F;A</td>
<td></td>
</tr>
<tr>
<td>Oneofs</td>
<td>N&#x2F;A</td>
<td>✔️</td>
</tr>
<tr>
<td>Maps</td>
<td>N&#x2F;A</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Semantics-of-Presence"><a href="#Semantics-of-Presence" class="headerlink" title="Semantics of Presence"></a>Semantics of Presence</h2><h3 id="Merging"><a href="#Merging" class="headerlink" title="Merging"></a>Merging</h3><p>If field presence is not tracked, then an update patch alone cannot represent an update to the default value, because only non-default values are merged-from.</p>
<p>Updating to set a default value in this case requires some external mechanism, such as <code>FieldMask</code>.</p>
<h3 id="Compatibility"><a href="#Compatibility" class="headerlink" title="Compatibility"></a>Compatibility</h3><p>binary compatible, but logically, there may be problems.</p>
<p>i.e. round trip between optional fields and non-optional fields</p>
<h1 id="Styles"><a href="#Styles" class="headerlink" title="Styles"></a>Styles</h1><ul>
<li><p><strong>Don’t</strong> Go from Repeated to Scalar</p>
</li>
<li><p><strong>Do</strong> Include an Unspecified Value in an Enum</p>
</li>
<li><p><strong>Do</strong> Use Well-Known Types and Common Types</p>
<ul>
<li><p>Well-Known Types:</p>
<ul>
<li><p><a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/duration.proto">duration</a> is a signed, fixed-length span of time (for example, 42s).</p>
</li>
<li><p><a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/timestamp.proto">timestamp</a> is a point in time independent of any time zone or calendar (for example, 2017-01-15T01:30:15.01Z).</p>
</li>
<li><p><a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/field_mask.proto">field_mask</a> is a set of symbolic field paths (for example, f.b.d).</p>
</li>
</ul>
</li>
<li><p>Common Types:</p>
<ul>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/interval.proto">interval</a> is a time interval independent of time zone or calendar (for example, 2017-01-15T01:30:15.01Z - 2017-01-16T02:30:15.01Z).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/date.proto">date</a> is a whole calendar date (for example, 2005-09-19).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/dayofweek.proto">dayofweek</a> is a day of week (for example, Monday).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/timeofday.proto">timeofday</a> is a time of day (for example, 10:42:23).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/latlng.proto">latlng</a> is a latitude&#x2F;longitude pair (for example, 37.386051 latitude and -122.083855 longitude).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/money.proto">money</a> is an amount of money with its currency type (for example, 42 USD).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/postal_address.proto">postal_address</a> is a postal address (for example, 1600 Amphitheatre Parkway Mountain View, CA 94043 USA).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/color.proto">color</a> is a color in the RGBA color space.</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/month.proto">month</a> is a month of year (for example, April).</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For extendible:</p>
<ul>
<li>Use different messages for storage and wire</li>
<li>Don’t Include Primitive Types in a Top-level Request or Response Proto</li>
<li>Never Use Booleans for Something That Has Two States Now, but Might Have More Later<ul>
<li>If you are using boolean for a field, make sure that the field is indeed describing just two possible states (for all time, not just now and the near future). </li>
<li>Often, the flexibility of an enum, int, or message turns out to be worth it.</li>
</ul>
</li>
<li>Rarely Use an Integer Field for an ID<ul>
<li>int64 is not as big as it used to be</li>
<li>can start with an internal message type</li>
</ul>
</li>
<li><em>Rarely</em> Define a Pagination API Without a Continuation Token</li>
</ul>
]]></content>
      <tags>
        <tag>Protobuf</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Compiler</title>
    <url>/2023/01/20/Go-Compiler/</url>
    <content><![CDATA[<h1 id="编译器和静态分析"><a href="#编译器和静态分析" class="headerlink" title="编译器和静态分析"></a>编译器和静态分析</h1><h2 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><p><img src="D:\Blog\source_images\image-20230120191244188.png" alt="img"></p>
<span id="more"></span>

<ul>
<li>分析部分 (front end)<ul>
<li>词法分析 –&gt; 词素(lexeme)</li>
<li>语法分析 –&gt; 抽象语法树(AST, Abstract Syntax Tree)</li>
<li>语义分析，收集类型信息，进行语义检查 –&gt; decorated AST</li>
<li>中间代码生成 –&gt; Intermediate Representation(IR) <ul>
<li>IR 是<strong>机器无关</strong>的</li>
</ul>
</li>
</ul>
</li>
<li>综合部分 (back end)<ul>
<li>代码优化(<strong>机器无关</strong>) –&gt; optimized IR</li>
<li>代码生成 –&gt; 目标代码</li>
</ul>
</li>
</ul>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>静态分析通常用于<strong>后端代码优化</strong></p>
<p>不执行程序代码，推导程序的行为，分析程序的性质，根据这些性质优化代码</p>
<ul>
<li>控制流分析 (Control Flow): 程序执行的流程</li>
<li>数据流分析 (Data Flow): 数据在控制流上的传递</li>
</ul>
<p>分析方式：</p>
<ul>
<li>过程内分析 (Intra-procedural analysis): 仅在函数内分析</li>
<li>过程间分析 (Inter-procedural analysis): 考虑函数调用时的参数传递和返回值的控制流和数据流<ul>
<li>过程间分析比较复杂，需要综合数据流和控制流</li>
</ul>
</li>
</ul>
<h1 id="Go-编译器优化"><a href="#Go-编译器优化" class="headerlink" title="Go 编译器优化"></a>Go 编译器优化</h1><p>Go 编译器为了追求编译的速度，编译器的优化较少</p>
<p>一些优化方向：</p>
<ul>
<li>函数内联</li>
<li>逃逸分析</li>
<li>默认栈大小调整</li>
<li>循环展开</li>
<li>边界检查消除</li>
</ul>
<h2 id="函数内联-Function-Inlining"><a href="#函数内联-Function-Inlining" class="headerlink" title="函数内联 (Function Inlining)"></a>函数内联 (Function Inlining)</h2><p>内联：将callee的副本替换到caller的位置，同时<strong>重写代码以反映参数的传递</strong></p>
<p>优点：</p>
<ul>
<li>消除调用开销，例如传参，保存寄存器等</li>
<li><strong>将过程间分析转化为过程内分析</strong>，帮助其他优化，例如<strong>逃逸分析</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>函数体变大，对 instruction cache (icache) 不友好</li>
<li>编译生成的 go 镜像变大</li>
</ul>
<p>函数内联大多数情况下是正优化</p>
<p>内联策略：调用和被调用函数的规模</p>
<h2 id="内联优化"><a href="#内联优化" class="headerlink" title="内联优化"></a>内联优化</h2><p>Go函数内联受到的限制多：interface，defer等语言特性限制了内联，内联策略非常保守</p>
<p>优化：调整函数内联的策略</p>
<h2 id="逃逸分析-Escape-Analysis"><a href="#逃逸分析-Escape-Analysis" class="headerlink" title="逃逸分析 (Escape Analysis)"></a>逃逸分析 (Escape Analysis)</h2><p>分析代码中指针的动态作用域：指针在何处能被访问</p>
<p>大致思路：</p>
<ul>
<li>从对象被分配处出发，沿着控制流观察对象的数据流：</li>
<li>若发现指针 p 在当前作用域 s 的时候：<ul>
<li>作为参数传递给别的函数</li>
<li>传递给全局变量</li>
<li>传递给其他goroutine</li>
<li>传递给已逃逸的指针指向的对象</li>
</ul>
</li>
<li>则指针 p 逃逸出了 s，反之没有逃逸出 s</li>
</ul>
<h2 id="逃逸优化"><a href="#逃逸优化" class="headerlink" title="逃逸优化"></a>逃逸优化</h2><p><strong>函数内联拓展了函数的边界，更多对象不逃逸</strong></p>
<p>未逃逸的对象可以栈上分配</p>
<ul>
<li>栈的分配和回收速度很快：移动sp</li>
<li>减少在heap上的分配，减轻GC的负担</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Memory</title>
    <url>/2023/01/20/Go-Memory/</url>
    <content><![CDATA[<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">业务代码 --&gt; SDK --&gt; 基础库 --&gt; 语言runtime --&gt; OS</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h2><p>业务优化，runtime优化，SDK优化</p>
<p>数据驱动</p>
<ul>
<li>自动化性能分析工具 – pprof</li>
<li>依靠数据而非猜测</li>
<li>首先优化最大瓶颈</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230120155529260.png" alt="image-20230120155529260"></p>
<p>性能优化和软件质量：</p>
<ul>
<li>保证<strong>接口稳定</strong>前提的情况下改进具体实现</li>
<li><strong>测试驱动开发</strong>：Test Driven Development</li>
<li><strong>文档</strong>：描述优化，做了什么，达到什么效果</li>
<li><strong>隔离性</strong>：通过选项控制是否开启优化</li>
<li><strong>可观测</strong>：必要的日志输出</li>
</ul>
<h1 id="Auto-Memory-Management"><a href="#Auto-Memory-Management" class="headerlink" title="Auto Memory Management"></a>Auto Memory Management</h1><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p><strong>自动内存管理</strong>管理的是<strong>动态内存</strong>(运行时根据需求动态分配的内存)： <code>malloc()</code></p>
<p>自动内存管理: 由程序语言的 runtime 系统管理动态内存</p>
<ul>
<li>保证内存使用的<em>正确性</em>和<em>安全性</em>: double-free problem, use-after-free problem</li>
<li>避免手动内存管理</li>
</ul>
<p>自动内存管理的三个任务：</p>
<ul>
<li>为对象分配新空间</li>
<li>找到存活的对象</li>
<li>回收死亡对象的内存空间</li>
</ul>
<p>线程类型</p>
<ul>
<li><p>Mutator thread: 业务线程，分配新对象，修改对象指向关系</p>
</li>
<li><p>Collector thread: GC线程，找到存活对象，回收死亡对象的内存空间</p>
</li>
</ul>
<p>GC分类：</p>
<ul>
<li>Serial GC: 只有一个Collector线程</li>
<li>Parallel GC: 支持多个Collector同时回收的GC算法</li>
<li>Concurrent GC: Mutators threads 和 Collector threads 可以同时执行<ul>
<li><strong>Collectors必须感知对象指向关系的改变</strong>，例如在GC过程中，Mutator线程修改了对象的指向关系</li>
</ul>
</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230120160944188.png" alt="image-20230120160944188"></p>
<p>GC算法的评价：</p>
<ul>
<li>安全性(safety)：不能回收存活的对象</li>
<li>吞吐率(throughput)：$1-\frac{time_{GC}}{time_{total}}$</li>
<li>暂停时间(pause time): stop the world(STW) 业务是否感知的到</li>
<li>内存开销(space overhead): GC metadata overhead</li>
</ul>
<h2 id="Tracing-Garbage-Collection"><a href="#Tracing-Garbage-Collection" class="headerlink" title="Tracing Garbage Collection"></a>Tracing Garbage Collection</h2><h3 id="Collection-Strategy"><a href="#Collection-Strategy" class="headerlink" title="Collection Strategy"></a>Collection Strategy</h3><p>对象回收的条件：指针指向不可达的对象可以被回收</p>
<p>回收过程：</p>
<ol>
<li><p>标记根对象</p>
<ul>
<li>根对象包括：静态变量、全局变量、常量、线程栈</li>
</ul>
</li>
<li><p>标记可达对象</p>
<ul>
<li>求指针指向关系的传递闭包，找到所有的可达对象</li>
</ul>
</li>
<li><p>清理不可达对象</p>
<ul>
<li><p>将存活对象复制到另外的内存空间 (<strong>Copying GC</strong>)</p>
<p><img src="D:\Blog\source_images\image-20230120162342068.png" alt="image-20230120162342068"></p>
</li>
<li><p>将死亡对象标记为可分配，用 free-list 管理 (<strong>Mark-Sweep GC</strong>)</p>
<p><img src="C:\Users\Anyu\AppData\Roaming\Typora\typora-user-images\image-20230120162436503.png" alt="image-20230120162436503"></p>
</li>
<li><p>移动并整理存活对象，根据一定的策略做压缩 (Mark-Compact GC)</p>
<p><img src="D:\Blog\source_images\image-20230120162602987.png" alt="image-20230120162602987"></p>
</li>
</ul>
</li>
<li><p>根据对象不同的生命周期，采取不同的回收策略</p>
</li>
</ol>
<h3 id="Generational-GC"><a href="#Generational-GC" class="headerlink" title="Generational GC"></a>Generational GC</h3><p>分代假说 (Generational Hypothesis): 很多对象很快就死亡了</p>
<ul>
<li>Intuition: 很多对象分配之后就很快不适用了</li>
</ul>
<p>每个对象都有年龄，年龄即为经历过GC的次数</p>
<ul>
<li>区别年轻代和老年的对象，使用不同的策略</li>
<li>年轻代 (Young Generation)<ul>
<li>常规的对象分配，存活对象很少</li>
<li>采用<strong>copying GC</strong></li>
<li>GC吞吐率高</li>
</ul>
</li>
<li>老年代 (Old Generation)<ul>
<li>对象趋向于一直活着，反复复制的开销很大</li>
<li>可以采用<strong>mark-sweep GC</strong></li>
</ul>
</li>
</ul>
<h2 id="Referencing-Counting"><a href="#Referencing-Counting" class="headerlink" title="Referencing Counting"></a>Referencing Counting</h2><p>基本思路：</p>
<ul>
<li>每个对象都有一个与之关联的引用计数</li>
<li>对象的存活条件：当且仅当引用计数大于0</li>
</ul>
<p>优点：</p>
<ul>
<li>内存管理操作被平摊到了程序执行过程中</li>
<li>内存管理不需要了解runtime的实现细节，例如 C++ 中的 smart pointer，Rust 中的 ownership 和 lifetime</li>
</ul>
<p>缺点：</p>
<ul>
<li>维护开销大，需要通过<strong>原子操作</strong>保证引用计数操作的唯一性和可见性</li>
<li>无法回收<strong>环形的不可达数据结构</strong> –&gt; 可通过 weak reference 解决</li>
<li>内存开销大，每个对象都需要额外的空间记录引用计数</li>
<li>回收内存时依然<strong>可能引入暂停</strong> –&gt; 例如回收一个很大的链表</li>
</ul>
<h1 id="Go-内存管理"><a href="#Go-内存管理" class="headerlink" title="Go 内存管理"></a>Go 内存管理</h1><h2 id="Go-内存分配"><a href="#Go-内存分配" class="headerlink" title="Go 内存分配"></a>Go 内存分配</h2><p>目标：为对象在 heap 上分配内存</p>
<h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><ul>
<li>提前为内存<strong>分块</strong>:<ol>
<li>调用 <code>mmap()</code> 向OS申请一大块内存，例如4MB</li>
<li>将内存分为大块，如 8KB，称为<em>mspan</em></li>
<li>再将mspan分为特定大小的小块，用于对象分配</li>
<li><strong>nonscan mspan</strong>: 不包含指针的对象 – <strong>GC不需要扫描</strong></li>
<li><strong>scan mspan</strong>: 包含指针的对象 – <strong>GC需要扫描</strong></li>
</ol>
</li>
<li>对象分配：根据块大小，分配最适合的块</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>TCMalloc: thread caching</li>
<li>每个p包含一个 mcache 用于快速分配，用于绑定于 p 上的 g 分配对象</li>
<li>mcache 管理一组 mspan</li>
<li>mcache 已满时，mcache 向 mcentral 申请带有未分配块的 mspan</li>
<li>当 mspan 没有对象的时候，mspan 会先被缓存在 mcentral 中，而不是立刻释放给 OS</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230120165816117.png" alt="image-20230120165816117"></p>
<h2 id="内存分配的优化"><a href="#内存分配的优化" class="headerlink" title="内存分配的优化"></a>内存分配的优化</h2><h3 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h3><ol>
<li>对象分配是<strong>高频</strong>的操作: 每秒GB级别的对象分配</li>
<li><strong>小对象</strong>占比例比较高 –&gt; 对小对象可以进行特定的优化</li>
<li>Go内存分配比较耗时<ul>
<li>分配路径较长: <code>g -&gt; m -&gt; p -&gt; mcache -&gt; mspan -&gt; memory block -&gt; return pointer</code></li>
<li>pprof: 对象分配的函数是最频繁调用的函数之一</li>
</ul>
</li>
</ol>
<h3 id="小对象内存分配优化方案-–-Balanced-GC"><a href="#小对象内存分配优化方案-–-Balanced-GC" class="headerlink" title="小对象内存分配优化方案 – Balanced GC"></a>小对象内存分配优化方案 – Balanced GC</h3><ul>
<li>将 noscan 对象在 per-g allocation buffer (GAB) 上分配，并使用移动对象 GC 管理这部分内存，提高对象分配和回收效率<ul>
<li>每个 g 会附加一个较大的 allocation buffer (例如1KB) 用来分配小于128B的 nonscan 小对象</li>
</ul>
</li>
<li><strong>bump pointer 风格</strong>的对象分配。<ul>
<li>分配对象时，根据对象大小移动 <code>top</code> 指针并返回，快速完成一次对象分配</li>
<li>同原先调用 <code>mallocgc()</code> 进行对象分配的方式相比，balanced GC <strong>缩短了对象分配的路径</strong>，降低 CPU 使用</li>
</ul>
</li>
<li>从 Go runtime 内存管理模块的角度看，一个 allocation buffer 其实是一个大对象。本质上 balanced GC 是<strong>将多次小对象的分配合并成一次大对象的分配</strong>。<ul>
<li>存在问题：当 GAB 中哪怕只有一个小对象存活时，Go runtime 也会认为整个大对象（即 GAB）存活。</li>
<li>解决方案：balanced GC 会根据 GC 策略，<strong>将 GAB 中存活的对象移动到另外的 GAB 中</strong>，从而压缩并清理 GAB 的内存空间，原先的 GAB 空间由于不再有存活对象，可以全部释放，如下图所示。<img src="D:\Blog\source_images\image-20230120171942068.png" alt="img"></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-Style</title>
    <url>/2023/01/19/Go-Style/</url>
    <content><![CDATA[<h1 id="高质量编码"><a href="#高质量编码" class="headerlink" title="高质量编码"></a>高质量编码</h1><p>什么是高质量？</p>
<ul>
<li>考虑到edge case</li>
<li>异常状况处理，稳定性</li>
<li>易读易维护，易于重构</li>
</ul>
<span id="more"></span>

<p>编程原则？</p>
<ul>
<li>简单性 - 消除多余的复杂性，否则代码难以维护</li>
<li>可读性 - 保证代码的可维护性</li>
<li>生产力 - 团队的整体工作效率</li>
</ul>
<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><ul>
<li><p>gofmt</p>
</li>
<li><p>goimports</p>
</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>公共符号必须要使用注释</strong></p>
<ul>
<li>代码作用</li>
<li>代码如何做的</li>
<li>代码实现的原因</li>
<li>什么情况会出错</li>
</ul>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h3><ul>
<li>简洁胜于冗长</li>
<li>缩略词全大写，但位于变量开头的时候全小写<ul>
<li>例如ServeHTTP instead of ServeHttp</li>
<li>xmlHTTPRequest 或 XMLHTTPRequest</li>
</ul>
</li>
<li>变量距离使用的距离越远，则需要携带越多的上下文信息<ul>
<li>全局变量要在名字中体现出更多的上下文信息，使得可以辨别其含义</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; n; index++ &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> send(req *Request, t time.Time)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good, deadline has more semantics</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> send(req *Request, deadline time.Time)</span><br></pre></td></tr></table></figure>

<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul>
<li>函数名不需要携带包信息，因为包名和函数名总是成对出现的</li>
<li>函数名应该尽量简短</li>
<li>当包名和函数的返回类型一样时，可以省略类型信息</li>
<li>当包名和函数的返回类型不一样时，可以在函数名中加入类型信息</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(l net.Listener, handler Handler)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad, http.ServeHTTP when invoking, which is verbose</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(l net.Listener, handler Handler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h3><ul>
<li>小写字母组成，不包含大写字母和下划线</li>
<li>简短并包含上下文信息</li>
<li>不与标准库同名</li>
</ul>
<h3 id="其他规则"><a href="#其他规则" class="headerlink" title="其他规则"></a>其他规则</h3><ul>
<li>不使用常用变量作为包名，例如bufio而不是buf</li>
<li>使用单数而不使用复数，例如encoding而不是encodings</li>
<li>谨慎使用缩写</li>
</ul>
<h3 id="顶层变量声明"><a href="#顶层变量声明" class="headerlink" title="顶层变量声明"></a>顶层变量声明</h3><p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;error&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> myError &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _e <span class="type">error</span> = F()</span><br><span class="line"><span class="comment">// F 返回一个 myError 类型的实例，但是我们要 error 类型</span></span><br></pre></td></tr></table></figure>

<p><strong>对于未导出的顶层常量和变量，使用_作为前缀</strong></p>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><p>避免嵌套，保证正常流程清晰</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">if</span> foo &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good, 分支中包含多个return语句，可以去除冗余的分支</span></span><br><span class="line"><span class="keyword">if</span> foo &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>尽量保持正常代码路径为最小缩进</p>
<ul>
<li>优先处理错误和特殊情况，尽早返回或继续循环以减少嵌套</li>
<li>线性原理，逻辑尽量走直线，避免复杂的嵌套分支</li>
<li>正常流程代码沿屏幕往下流动</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OneFunc</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    err := DoSomething()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        err = DoAnotherThing()</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>	<span class="comment">// normal case</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OneFunc</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := DoSomething(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := DoAnotherThing(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误与异常处理"><a href="#错误与异常处理" class="headerlink" title="错误与异常处理"></a>错误与异常处理</h2><p>简单错误：</p>
<ul>
<li>指仅出现一次的错误，且<strong>其他地方不需要捕获该错误</strong></li>
<li>优先使用 <code>errors.New</code> 创建匿名变量来表示简单错误</li>
<li>如果有格式化需求可以使用 <code>fmt.Errorf</code></li>
</ul>
<p>错误的Wrap和Unwrap</p>
<ul>
<li>在 <code>fmt.Errorf</code> 中使用 <code>%w</code> 关键字来将一个错误 wrap 至其错误链中</li>
<li>错误的 wrap 实际上提供了一个 error 嵌套另一个 error 的功能，从而生成 error 的跟踪链条，以方便判断错误</li>
</ul>
<p>错误判定</p>
<ul>
<li>判断一个错误链是否包含一个特定的错误，使用 <code>errors.Is</code> 的方法</li>
<li>获取特定种类的错误，使用 <code>errors.As</code> 方法</li>
</ul>
<p>Panic：</p>
<ul>
<li>不建议在业务代码中使用 panic</li>
<li>建议使用 error 代替 panic</li>
<li>程序启动阶段发生不可逆转的作用的时候，可以在 init 或 main 中使用 panic， 尽早暴露错误</li>
</ul>
<p>Recovery：</p>
<ul>
<li>通常在recovery中打印出panic时的调用堆栈 <code>debug.Stack()</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treeFS)</span></span> Open(name <span class="type">string</span>) (f fs.File, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            f = <span class="literal">nil</span></span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;git fs panics: %v\n%s&quot;</span>, e, debug.Stack())</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>error 应提供上下文信息链，方便定位</li>
<li>panic用于定位真正异常的情况</li>
</ul>
<h2 id="Interface合理化验证"><a href="#Interface合理化验证" class="headerlink" title="Interface合理化验证"></a>Interface合理化验证</h2><p>将实现特定结构的导出类型进行检查。如果 <code>http.Handler</code> 和 <code>Handler</code> 类型不匹配，则 <code>var _ http.Handler = (*Handler)(nil)</code> 编译时就会出错。方便提早暴露问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">var</span> _ http.Handler = (*Handler)(<span class="literal">nil</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="零值-Mutex-是有效的"><a href="#零值-Mutex-是有效的" class="headerlink" title="零值 Mutex 是有效的"></a>零值 Mutex 是有效的</h2><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p>
<p><strong>不要把mutex嵌入到(导出或非导出)结构体中</strong>!</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">mu := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure>

<h2 id="Channel的size为1或0"><a href="#Channel的size为1或0" class="headerlink" title="Channel的size为1或0"></a>Channel的size为1或0</h2><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，<strong>考虑是什么阻止了 channel 在高负载下和阻塞写时的写入</strong>，以及当这种情况发生时系统逻辑有哪些变化</p>
<h2 id="枚举从1开始"><a href="#枚举从1开始" class="headerlink" title="枚举从1开始"></a>枚举从1开始</h2><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。<strong>由于变量的默认值为 0</strong>，因此通常应以非零值开头枚举。</p>
<p><strong>在某些情况下，使用零值是有意义的</strong>(枚举从零开始)，例如，<strong>当零值是理想的默认行为时</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">type</span> Opeartion <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Add Opeartion = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">	Subtract</span><br><span class="line">    Multiply</span><br><span class="line">    Divide</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good, default to stdout</span></span><br><span class="line"><span class="keyword">type</span> LogOutput <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	LogToStdout LogOutput = <span class="literal">iota</span></span><br><span class="line">    LogToFile</span><br><span class="line">    LogToRemote</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="使用-time-处理时间"><a href="#使用-time-处理时间" class="headerlink" title="使用 time 处理时间"></a>使用 time 处理时间</h2><h3 id="time-Time-瞬时时间"><a href="#time-Time-瞬时时间" class="headerlink" title="time.Time 瞬时时间"></a>time.Time 瞬时时间</h3><p>在<strong>比较、增加和减少</strong>时间的时候使用 <code>time.Time</code> 中的方法</p>
<ul>
<li>比较 Time.Before, Time.After, Time.Equal</li>
<li>增加 Time.Add, Time.AddDate</li>
<li>减少 Time.Sub</li>
</ul>
<h3 id="外部系统中的-time-Time-和-time-Duration"><a href="#外部系统中的-time-Time-和-time-Duration" class="headerlink" title="外部系统中的 time.Time 和 time.Duration"></a>外部系统中的 time.Time 和 time.Duration</h3><ul>
<li>Command-line 标志: <a href="https://golang.org/pkg/flag/"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></li>
<li>JSON: <a href="https://golang.org/pkg/encoding/json/"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON"><code>UnmarshalJSON</code></a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串</li>
<li>SQL: <a href="https://golang.org/pkg/database/sql/"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</li>
<li>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</li>
</ul>
<p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p>
<p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad, 单位未指定</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Interval <span class="type">int</span> <span class="string">`json:&quot;interval&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    IntervalMillis <span class="type">int</span> <span class="string">`json:&quot;intervalMillis&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="避免可变全局变量"><a href="#避免可变全局变量" class="headerlink" title="避免可变全局变量"></a>避免可变全局变量</h2><p>使用选择<strong>依赖注入方式避免改变全局变量</strong>。 既适用于函数指针又适用于其他值类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">var</span> _timeNow = time.Now</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  now := _timeNow()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good </span></span><br><span class="line"><span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;</span><br><span class="line">  now <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSigner</span><span class="params">()</span></span> *signer &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;signer&#123;</span><br><span class="line">    now: time.Now,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span></span> Sign(msg <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  now := s.now()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="避免在公共结构中嵌入类型"><a href="#避免在公共结构中嵌入类型" class="headerlink" title="避免在公共结构中嵌入类型"></a>避免在公共结构中嵌入类型</h2><p>这些嵌入的类型<strong>泄漏实现细节</strong>、<strong>不利于类型演化</strong>和<strong>导致文档模糊</strong>。</p>
<h3 id="类型演化"><a href="#类型演化" class="headerlink" title="类型演化"></a>类型演化</h3><p>结构获得与类型同名的字段。 所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p>
<ul>
<li>向嵌入接口添加方法是一个破坏性的改变。</li>
<li>从嵌入结构体删除方法是一个破坏性改变。</li>
<li>删除嵌入类型是一个破坏性的改变。</li>
<li>即使使用满足相同接口的类型替换嵌入类型，也是一个破坏性的改变。</li>
</ul>
<h2 id="避免使用-init"><a href="#避免使用-init" class="headerlink" title="避免使用 init()"></a>避免使用 <code>init()</code></h2><p>导入包尽可能要做到 <em>deterministic</em>，<strong>不能因为在不同地方导入包就造成不同的初始化行为</strong>。因此应该尽可能避免使用 <code>init()</code> 函数。如果必须要使用 <code>init()</code> 函数，则需要做到以下几点</p>
<ol>
<li>无论程序环境或调用如何，都要完全确定。</li>
<li>避免依赖于其他<code>init()</code>函数的顺序或副作用。虽然<code>init()</code>顺序是明确的，但代码可以更改， 因此<code>init()</code>函数之间的关系可能会使代码变得脆弱和容易出错。</li>
<li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数&#x2F;输入等。</li>
<li>避免<code>I/O</code>，包括文件系统、网络和系统调用。</li>
</ol>
<p>不能满足这些要求的代码可能属于要作为<code>main()</code>调用的一部分（或程序生命周期中的其他地方）， 或者作为<code>main()</code>本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性， 而不是执行“init magic”</p>
<p>考虑到上述情况，在某些情况下，<code>init()</code>可能更可取或是必要的，可能包括：</p>
<ul>
<li><strong>不能表示为单个赋值的复杂表达式</strong>。</li>
<li>可插入的钩子，如<code>database/sql</code>、编码类型注册表等。</li>
<li>对 <a href="https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations">Google Cloud Functions</a> 和其他形式的确定性预计算的优化。</li>
</ul>
<h2 id="主函数退出方式"><a href="#主函数退出方式" class="headerlink" title="主函数退出方式"></a>主函数退出方式</h2><p>使用 <strong>os.Exit</strong> 或 <strong>log.Fatal</strong> 退出，<strong>单一出口退出</strong>，例如将逻辑封装在 <code>run</code> 函数中，<code>run</code> 函数返回一个 error。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    args := Args[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;missing files&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    name := args[<span class="number">0</span>]</span><br><span class="line">    f, err := os.Open(name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;open file %s failed: %w&quot;</span>, name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    b, err := os.ReadAll(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read file %s failed: %w&quot;</span>, name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在序列化结构中使用字段标记"><a href="#在序列化结构中使用字段标记" class="headerlink" title="在序列化结构中使用字段标记"></a>在序列化结构中使用字段标记</h2><p>任何序列化到JSON、YAML，或其他支持基于标记的字段命名的格式应使用相关标记进行注释</p>
<p>这样后续就可以对字段名进行修改而不影响序列化和反序列化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">type</span> Stock <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="type">int</span></span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">type</span> Stock <span class="keyword">struct</span> &#123;</span><br><span class="line">    Price <span class="type">int</span> <span class="string">`json：“price”`</span></span><br><span class="line">    Name <span class="type">int</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Goroutine-泄露"><a href="#Goroutine-泄露" class="headerlink" title="Goroutine 泄露"></a>Goroutine 泄露</h2><p>不要在代码中泄漏 goroutine。 使用 <a href="https://pkg.go.dev/go.uber.org/goleak">go.uber.org&#x2F;goleak</a> 来测试可能产生 goroutine 的包内的 goroutine 泄漏。</p>
<p>一般来说，每个 goroutine:</p>
<ul>
<li>必须有一个可预测的停止运行时间；或者</li>
<li>必须有一种方法可以向 goroutine 发出信号它应该停止</li>
</ul>
<p><strong>不要在init函数中使用goroutine</strong></p>
<h2 id="nil是有效的Slice"><a href="#nil是有效的Slice" class="headerlink" title="nil是有效的Slice"></a>nil是有效的Slice</h2><p><code>nil</code> 是一个有效的长度为 0 的 slice。虽然 nil 切片是有效的切片，但它不等于长度为 0 的切片（一个为 nil，另一个不是），<strong>并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</strong></p>
<ul>
<li>不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</li>
<li>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</li>
<li>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</li>
</ul>
<h2 id="初始化规则"><a href="#初始化规则" class="headerlink" title="初始化规则"></a>初始化规则</h2><ul>
<li>字段名初始化结构体，除非结构体中的字段有3个或更少，或者有顺序意义</li>
<li>省略结构体中的零值字段，除了在表驱动测试中的测试用例</li>
<li>对零值结构使用 <code>var</code> 初始化</li>
<li>初始化零值结构体的引用使用 <code>&amp;User&#123;&#125;</code> 而不用 <code>new(User)</code></li>
<li>初始化Map<ul>
<li>在尽可能的情况下，请在初始化时提供 map 容量大小</li>
<li>如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</li>
<li>基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)。</li>
</ul>
</li>
</ul>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice预分配内存</p>
<ul>
<li>尽可能使用 <code>make()</code> 初始化切片时提供容量信息</li>
</ul>
<p>Slice大内存未释放</p>
<ul>
<li>在已有的切片上创建切片，不会创建新的底层数组，且原来的切片存在引用，不会被释放</li>
<li>可以使用 copy 代替 re-slice</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLastBySlice</span><span class="params">(origin []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> origin[<span class="built_in">len</span>(origin)<span class="number">-2</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLastBySlice</span><span class="params">(origin []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, origin[<span class="built_in">len</span>(origin)<span class="number">-2</span>:])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map预分配内存</p>
<ul>
<li>不断向 map 添加元素会触发map扩容</li>
<li>提前分配空间可以避免 re-hash 和扩容</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串处理：</p>
<ul>
<li>strings.Builder &gt; bytes.Buffer &gt; +</li>
<li>strings.Builder 和 bytes.Buffer 均使用了 []byte 类型作为底层存储结构</li>
<li>strings.Builder 直接将底层的 []byte 结构转化为了字符串类型返回，而 bytes.Buffer 在转换字符串的时候重新申请了一片空间因此 strings.Builder 比 bytes.Buffer 略快</li>
<li><strong>已知字符串长度的时候，可以通过 <code>Grow</code> 预分配空间更进一步提升性能</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preStrBuilder</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buidler strings.Builder</span><br><span class="line">    builder.Grow(n * <span class="built_in">len</span>(str))	<span class="comment">// similar to bytes.Buffer.Grow</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">        builder.WriteString(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Empty-Struct"><a href="#Empty-Struct" class="headerlink" title="Empty Struct"></a>Empty Struct</h2><p>使用空结构体节省内存</p>
<ul>
<li><code>struct&#123;&#125;&#123;&#125;</code> 不占内存空间</li>
<li>可以作为占位符使用，并且具有一定的语义</li>
</ul>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>使用 atomic 包</p>
<ul>
<li>锁通过系统调用实现，成本较高</li>
<li>atomic操作由硬件实现，性能较好</li>
<li>非数值操作可以使用 <code>atomic.Value</code>, 能承载一个 <code>interface&#123;&#125;</code></li>
</ul>
<h2 id="Type-Conversion"><a href="#Type-Conversion" class="headerlink" title="Type Conversion"></a>Type Conversion</h2><p>优先使用 <code>strconv</code> 而不是 <code>fmt</code> </p>
<p>避免字符串到字节切片的转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Good</span></span><br><span class="line">data := []<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">    w.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h1><h2 id="功能选项"><a href="#功能选项" class="headerlink" title="功能选项"></a>功能选项</h2><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p>
<p>将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">    apply(o *options) <span class="comment">//! unexported</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">    cache <span class="type">bool</span></span><br><span class="line">    logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cacheOption <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="type">bool</span>)</span></span> cacheOption &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheOption(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheOption)</span></span> apply(o *options) &#123;</span><br><span class="line">    o.cache = <span class="type">bool</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggerOption <span class="keyword">struct</span> &#123;</span><br><span class="line">    Log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span></span> loggerOption &#123;</span><br><span class="line">    <span class="keyword">return</span> loggerOption&#123;Log: log&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l logOption)</span></span> apply(o *options) &#123;</span><br><span class="line">    o.logger = l.Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(addr <span class="type">string</span>, opt ...Option)</span></span> &#123;</span><br><span class="line">    options := options&#123;</span><br><span class="line">        cache: defaultCache,</span><br><span class="line">        logger: zap.NewNop(),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opt &#123;</span><br><span class="line">        o.apply(&amp;options)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Self-referential-functions"><a href="#Self-referential-functions" class="headerlink" title="Self-referential functions"></a>Self-referential functions</h3><p>通过Option函数进行一系列的配置option，其中配置option由类似Verbosity等函数得到(返回闭包)，Option配置的返回值为配置之前的option，因此通过重新采用返回值的option，即可恢复到之前的配置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> option <span class="function"><span class="keyword">func</span><span class="params">(f *Foo)</span></span> option</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verbosity sets Foo&#x27;s verbosity level to v.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Verbosity</span><span class="params">(v <span class="type">int</span>)</span></span> option &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(f *Foo)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        previous := f.verbosity</span><br><span class="line">        f.verbosity = v</span><br><span class="line">        <span class="keyword">return</span> Verbosity(previous)	<span class="comment">//! recall the function in closure</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span></span> Option(opts ...option) option &#123;</span><br><span class="line">    <span class="keyword">var</span> prev option</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        prev = opt(f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomethingVerbosely</span><span class="params">(foo *Foo, verbosity <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    prev := foo.Option(Verbosity(verbosity))</span><br><span class="line">    <span class="keyword">defer</span> foo.Option(prev) <span class="comment">// cancel the option after this function</span></span><br><span class="line">    <span class="comment">// Do Something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Style</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-Profile</title>
    <url>/2023/01/19/Go-Profile/</url>
    <content><![CDATA[<h1 id="性能调优准则"><a href="#性能调优准则" class="headerlink" title="性能调优准则"></a>性能调优准则</h1><ul>
<li>要依靠<strong>数据</strong>而不是猜测</li>
<li>要定位到<strong>最大瓶颈</strong>，而不是细枝末节</li>
<li>不要过早优化</li>
<li>不要过度优化</li>
</ul>
<span id="more"></span>

<h1 id="性能分析工具pprof"><a href="#性能分析工具pprof" class="headerlink" title="性能分析工具pprof"></a>性能分析工具pprof</h1><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p><img src="D:\Blog\source_images\image-20230119214436210.png" alt="image-20230119214436210"></p>
<h2 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h2><p>使用命令 <code>go tool pprof &quot;localhost:6060/debug/pprof/profile?seconds=10&quot;</code> 采集10s的数据，并进入可交互的终端</p>
<ul>
<li><code>top[N]</code>: 查看占用资源最多的函数<ul>
<li>flat: 当前函数<strong>本身</strong>的执行耗时 </li>
<li>flat%: 执行耗时占的百分比</li>
<li>sum%: 该函数及其之上的函数占的总百分比</li>
<li>cum: 当前函数<strong>及其调用函数</strong>的总执行耗时</li>
<li>cum%: 总执行耗时的百分比</li>
<li>flat &#x3D;&#x3D; cum –&gt; 函数中没有调用其他函数</li>
<li>flat &#x3D;&#x3D; 0 –&gt; 函数中只有其他函数的调用</li>
</ul>
</li>
<li><code>list [regexp]</code>: 根据正则表达式查找代码行</li>
<li><code>web</code>: 调用关系可视化</li>
</ul>
<h2 id="堆分析"><a href="#堆分析" class="headerlink" title="堆分析"></a>堆分析</h2><p>使用 <code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/heap&quot;</code> 命令，在localhost:8080地址展示各种视图和工具进行分析</p>
<h2 id="其他分析"><a href="#其他分析" class="headerlink" title="其他分析"></a>其他分析</h2><p>协程分析：<code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/goroutine&quot;</code></p>
<p>锁分析：<code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/mutex&quot;</code></p>
<p>阻塞分析：<code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/block&quot;</code></p>
<h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p>通过 <code>go test</code> 命令可以指定生成测试程序的 profile，这些profile可以用来分析 cpu, block, mem 等性能</p>
<p>例如</p>
<ul>
<li>CPU分析<ul>
<li><code>go test -cpuprofile=cpu.log module/package</code> </li>
<li><code>go tool pprof -http=:8080 cpu.log</code></li>
</ul>
</li>
<li>block分析<ul>
<li><code>go test -blockprofile=block.log module/package</code></li>
<li><code>go tool pprof -http=:8080 block.log</code></li>
</ul>
</li>
<li>mem分析<ul>
<li><code>go test -memprofile=block.log module/package</code></li>
<li><code>go tool pprof -http=:8080 mem.log</code></li>
</ul>
</li>
</ul>
<h1 id="pprof原理和采样过程"><a href="#pprof原理和采样过程" class="headerlink" title="pprof原理和采样过程"></a>pprof原理和采样过程</h1><h2 id="CPU采样"><a href="#CPU采样" class="headerlink" title="CPU采样"></a>CPU采样</h2><ul>
<li>操作系统定时器：启动一个操作系统的定时器，每10ms发送一个SIGPROF信息给进程</li>
<li>进程堆栈：进程<strong>每次收到SIGPROF信号都记录调用堆栈</strong></li>
<li>写缓冲：每100ms读取记录的调用堆栈并写入到输出流</li>
</ul>
<h2 id="Heap采样"><a href="#Heap采样" class="headerlink" title="Heap采样"></a>Heap采样</h2><ul>
<li>采样程序通过<strong>内存分配器</strong>在堆上分配和释放的内存，<strong>记录分配&#x2F;释放的大小和数量</strong></li>
<li>采样率：<strong>每512KB采样一次</strong>，可在运行开头修改，1表示每次分配均记录</li>
<li>采样时间：程序开始运行时到采样时</li>
<li>采样指标：alloc_space, alloc_objects, inuse_space, inuse_objects</li>
<li>inuse&#x3D;alloc-free</li>
</ul>
<h2 id="Goroutine-amp-ThreadCreate-采样"><a href="#Goroutine-amp-ThreadCreate-采样" class="headerlink" title="Goroutine &amp; ThreadCreate 采样"></a>Goroutine &amp; ThreadCreate 采样</h2><ul>
<li>Goroutine<ul>
<li>记录所有用户发起的且在运行中的goroutine(<strong>即入口非runtime开头的goroutine</strong>)runtime.main的调用栈信息</li>
</ul>
</li>
<li>ThreadCreate<ul>
<li>记录程序创建的所有系统线程的信息</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">direction LR</span><br><span class="line">id1(stop the world) --&gt; id2(遍历allg切片) --&gt; id3(输出创建g的堆栈) --&gt; id4(start the world)</span><br></pre></td></tr></table></figure>

<h2 id="Block-amp-Mutex-采样"><a href="#Block-amp-Mutex-采样" class="headerlink" title="Block &amp; Mutex 采样"></a>Block &amp; Mutex 采样</h2><ul>
<li>Block采样<ul>
<li>采样阻塞操作的次数和耗时</li>
<li>采样率：阻塞耗时超过阈值才会被记录，也可以设置采样率，1表示每次都记录</li>
</ul>
</li>
<li>锁竞争<ul>
<li>采样争抢锁的次数和耗时</li>
<li>采样率：只记录固定比例的锁操作，也可以设置采样率，1表示每次都记录</li>
</ul>
</li>
</ul>
<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="业务服务优化"><a href="#业务服务优化" class="headerlink" title="业务服务优化"></a>业务服务优化</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>服务：能<strong>单独部署</strong>，承载<strong>一定功能</strong>的程序</p>
<p>依赖：Service A的功能实现依赖Service B的响应结果，则Service A依赖Service B</p>
<p>调用链路：支持一个接口的相关服务集合及其相互之间的依赖关系</p>
<p>基础库：公共的工具包，中间件</p>
<h3 id="单体Service优化流程"><a href="#单体Service优化流程" class="headerlink" title="单体Service优化流程"></a>单体Service优化流程</h3><ol>
<li>建立服务性能的<strong>评估手段</strong><ul>
<li>Benchmark</li>
<li>Others</li>
</ul>
</li>
<li>分析性能数据，定义<strong>性能瓶颈</strong></li>
<li>优化代码，消除瓶颈</li>
<li>验证优化效果</li>
</ol>
<h4 id="评估手段"><a href="#评估手段" class="headerlink" title="评估手段"></a>评估手段</h4><ul>
<li>不同负载性能表现有差异</li>
<li>不同请求参数覆盖的逻辑不同，请求流量不同</li>
<li>压测范围<ul>
<li>单机压测</li>
<li>集群压测</li>
</ul>
</li>
<li>性能数据采集<ul>
<li>单机性能数据</li>
<li>集群性能数据</li>
</ul>
</li>
</ul>
<h4 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h4><ul>
<li>使用库不规范</li>
<li>高并发场景优化不足，例如异步log</li>
</ul>
<h4 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h4><ul>
<li>正确性<ul>
<li><strong>确保正确性</strong></li>
<li>响应数据diff</li>
</ul>
</li>
<li>重复压测验证</li>
<li>上线后评估优化效果<ul>
<li>关注监控</li>
<li>收集性能数据</li>
<li>逐步放量</li>
</ul>
</li>
</ul>
<h3 id="服务链路性能优化"><a href="#服务链路性能优化" class="headerlink" title="服务链路性能优化"></a>服务链路性能优化</h3><p>分析链路</p>
<h2 id="基础库优化"><a href="#基础库优化" class="headerlink" title="基础库优化"></a>基础库优化</h2><ol>
<li>分析基础库核心逻辑和性能瓶颈<ul>
<li>设计完善的改造方案</li>
<li>数据按需获取</li>
<li>序列化反序列化优化</li>
</ul>
</li>
<li>内部压测验证</li>
<li>推广业务服务落地验证</li>
</ol>
<h2 id="Go语言优化"><a href="#Go语言优化" class="headerlink" title="Go语言优化"></a>Go语言优化</h2><p>编译器 &amp; 运行时优化</p>
<ul>
<li>优化<strong>内存分配策略</strong></li>
<li>优化代码<strong>编译流程</strong>，生成更高效的程序</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Profile</tag>
      </tags>
  </entry>
  <entry>
    <title>GFS</title>
    <url>/2022/12/17/GFS/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Big storage abstraction is important in distributed systems.</p>
<p>Why is it hard?</p>
<ul>
<li>Performance –&gt; Sharding</li>
<li>Faults –&gt; Tolerance</li>
<li>Tolerance –&gt; Replication</li>
<li>Replication –&gt; Consistency</li>
<li>Consistency –&gt; Low Performance</li>
</ul>
<span id="more"></span>

<p>Why we need GFS?</p>
<ul>
<li>A strawman replication design:</li>
</ul>
<p><img src="D:\Blog\source_images\repl.drawio.png" alt="repl.drawio"></p>
<ul>
<li>User1 write 1 to two machines, User2 write 2 to two machines</li>
<li>Due to the network, server1 see 2 first; server2 see 1 first.</li>
<li>Consistency is destroyed!</li>
</ul>
<p>How about GFS?</p>
<ul>
<li>Performance: Sharding, every file will be automatically sharded by GFS.</li>
<li>Performance: it has high aggregate performance to a large number of clients. </li>
<li>Fault Tolerance: Automatic failure recovery.</li>
<li>Designed for a single datacenter.</li>
<li>Designed for big sequential access.</li>
<li>Designed for data-intensive applications.</li>
</ul>
<p>What problem does GFS solve?</p>
<ul>
<li>Component failures are norm rather than exception<ul>
<li>Constant monitoring, error detection, fault tolerance, and automatic recovery are needed.</li>
</ul>
</li>
<li>Files are huge, so it’s unwieldy to manage billions of KB-sized files.<ul>
<li>Design choices of I&#x2F;O operation and block sizes have to be revisited.</li>
</ul>
</li>
<li>Appending and sequential reading are more common than write operation.<ul>
<li>Appending become the focus of optimization and atomicity guarantee instead of caching data blocks in the client (like what normal filesystems do).</li>
</ul>
</li>
<li>Co-designing the applications and the file system API, relaxing GFS’s consistency model, and designing an atomic append operation.</li>
</ul>
<h1 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h1><h2 id="Assumption"><a href="#Assumption" class="headerlink" title="Assumption"></a>Assumption</h2><ul>
<li>System is built from inexpensive components that <em>usually fails</em> –&gt; so it needs monitor and detect, tolerate and recovery from component failure.</li>
<li>System stores mostly large files. <em>Large files operations</em> should be efficient.</li>
<li>Two kinds of reads: <strong>large streaming read</strong> and <strong>small random reads</strong>.<ul>
<li>Performance-conscious applications often batch and sort small reads to advance steadily through the file rather than go back and forth.</li>
</ul>
</li>
<li>Two kinds of writes: <strong>large, sequential writes that append data to files</strong> (normal and need to be optimized) and <strong>small writes at random positions</strong> (rare and need not to be efficient).</li>
<li>Should support well-defined semantic of <em>appending files concurrently</em> –&gt; Atomicity with minimal synchronization overhead is needed.</li>
<li><strong>High sustained bandwidth</strong> is more important than low latency.</li>
</ul>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Files are <em>organized hierarchically</em> in directories and <em>identified by pathnames</em>.</p>
<p>support usual operations like <em>create, delete, open, close, read, write</em>.</p>
<p>GFS also has <em>snapshot</em> and <em>record append</em> operations</p>
<ul>
<li><strong>Snapshot</strong> creates a copy of a file or a directory tree at low cost. </li>
<li><strong>Record append</strong> –&gt; atomic append, allows multiple clients to append data to the same file concurrently.</li>
<li>Useful for implementing <strong>multi-way merging</strong> and <strong>producer-consumer queues</strong>.</li>
</ul>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="D:\Blog\source_images\image-20221221170828501.png" alt="image-20221221170828501"></p>
<p>GFS Clusters:</p>
<ul>
<li><p>single <em>master</em></p>
</li>
<li><p>multiple <em>chunkserver</em></p>
</li>
<li><p>multiple client (client and chunkserver can be run on same machine)</p>
</li>
<li><p>Each of these is typically a commodity Linux machine running a user-level server process.</p>
</li>
</ul>
<p>File Storage:</p>
<ul>
<li>Files are divided into <strong>fix-sized</strong> chunks.</li>
<li>Each <strong>chunks</strong> identified by an immutable and globally unique 64 bit chunk handle.</li>
<li><strong>Chunk handle</strong> is assigned by the master at the time of chunk creation.</li>
<li>Chunkservers store chunks on local disks as Linux files and read or write chunk data specified by a chunk handle and byte range.</li>
<li>Each chunk is replicated on multiple chunkservers.</li>
</ul>
<p>Single Master:</p>
<ul>
<li>Maintains all filesystem metadata.<ul>
<li>Namespace.</li>
<li>Access control information.</li>
<li>Mapping from file to chunks.</li>
<li>Current location of chunks.</li>
</ul>
</li>
<li>Control system-wide activities.<ul>
<li>Chunk lease management.</li>
<li>Garbage collection of orphaned chunks.</li>
<li>Chunk migration between chunkservers.</li>
</ul>
</li>
<li>Periodically communicate with chunkservers in <em>HeartBeat</em> messages to <em>give it instructions</em> and <em>collect its state</em>.</li>
</ul>
<p>Client:</p>
<ul>
<li>implement the filesystem API.</li>
<li>Communicate with master for metadata and chunkserver for data.</li>
<li>Neither client nor chunkserver cache the data.<ul>
<li>For Client, most app stream through the file, it’s too large to be cached.</li>
<li>it also eliminate cache coherence issues. (<strong>client cache metadata instead</strong>)</li>
<li>For Chunkserver, Linux’s buffer cache is enough.</li>
</ul>
</li>
</ul>
<h3 id="Single-Master"><a href="#Single-Master" class="headerlink" title="Single Master"></a>Single Master</h3><p>Benefit: simplify the design and enable master to make sophisticated chunk replacement and replication decisions by using global knowledge.</p>
<p>But we need to minimize the read and write on master so that it doesn’t become the bottleneck.</p>
<p>So Client only ask master for metadata, and caches this information for a limited time and interacts with the chunkservers directly for many subsequent operations.</p>
<hr>
<p>Simple read operation:</p>
<ol>
<li>Client translates file name and byte offset into chunk index within the file.</li>
<li>Client sends request to master containing chunk index and file name.</li>
<li>Master replies with the corresponding chunk handle and location of replicas.</li>
<li>Client caches the information using the fila name and chunk index as the key.</li>
<li>Client then sends the request to one of the replicas (mostly the closest one), the request specifies the chunk range and chunk handle<ul>
<li>In fact, the client typically asks for multiple chunks in the same request and the master can also include the informa- tion for chunks immediately following those requested</li>
</ul>
</li>
</ol>
<h3 id="Chunk-Size"><a href="#Chunk-Size" class="headerlink" title="Chunk Size"></a>Chunk Size</h3><p>Chunk Size, 64MB, is much larger than file system block sizes.</p>
<p>Each chunk is stored as plain Linux file and extended only as needed. This kind of lazy allocation avoids space wasting due to internal fragmentation.</p>
<p>Advantages of large chunk size:</p>
<ul>
<li>Reduce client’s needs to interact with master.</li>
<li>Since on a large chunk, a client is more likely to perform many operations on a given chunk.</li>
<li>Reduces the size of the metadata stored on the master. Thus we can keep the metadata in memory.</li>
</ul>
<p>Disadvantages of large chunk size:</p>
<ul>
<li>Small files consist a small number of chunks. The chunkservers storing those chunks may become hot spots if many clients are accessing the same file</li>
<li>In practice, hot spot is not a major problem. But hot spots did develop when GFS was first used by a batch-queue system.<ul>
<li>One solution: making the batch-queue system stagger application start times</li>
<li>A potential long-term solution: allow clients to read data from other clients in such situations.</li>
</ul>
</li>
</ul>
<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>All metadata is kept in memory, there are three kind of metadata:</p>
<ol>
<li>The file and chunk namespace.</li>
<li>The mapping from files to chunks.</li>
<li>location of each chunks’ replicas.</li>
</ol>
<p>First two kinds of metadata (namespaces and file-to-chunk mapping) is logged on local disk and replicated by a remote machine. The master doesn’t store chunk location information, instead, it ask each chunkserver about its chunks at master’s startup and whenever chunkserver joins the cluster.</p>
<hr>
<p>Why we want data structure in-memory?</p>
<ul>
<li>Since metadata is stored in memory, master can easily periodically scan the entire state <strong>in the background</strong>. This periodic scanning is used to implement <strong>chunk garbage collecting</strong>, <strong>re-replication in the presence of chunkserver failures</strong>, <strong>chunk migration between chunkservers for balance-loading and disk space usage</strong>.</li>
</ul>
<p>Why we don’t need to keep chunk location persistent in disk?</p>
<ul>
<li>The master can keep chunk location up-to-date thereafter because it controls all chunk placement and monitors chunkserver status <strong>with regular HeartBeat messages</strong>. This also eliminate the problem of <em>keeping the master and chunkservers in sync</em> as chunkservers <em>join and leave the cluster, change names, fail, restart, and so on</em>.</li>
</ul>
<p>What is operation log?</p>
<ul>
<li>It contains historical record of critical metadata changes.<ul>
<li>It is the only persistent record of metadata.</li>
<li>It serves as local timeline that defines the order of concurrent operations.</li>
<li>Files, chunks and their versions are identified by local time.</li>
</ul>
</li>
<li>Operation log must be stored reliably and we should not make changes visible to clients until metadata changes are made persistent.</li>
<li>We replicate it on multiple remote machines and respond to a client operation only after flushing the corresponding log record to disk both locally and remotely.</li>
<li>The master batches several log records together before flushing thereby reducing the impact of flushing and replication on overall system throughput.</li>
</ul>
<h3 id="Consistency-Model"><a href="#Consistency-Model" class="headerlink" title="Consistency Model"></a>Consistency Model</h3><p>GFS has a relaxed consistency model</p>
<p>What is guarantees by GFS?</p>
<ul>
<li><p><strong>File namespaces mutations are atomic</strong>, it’s handled by master using a namespace locking. And the global total order is defined by master’s operation log file.</p>
</li>
<li><p>File region state after mutation</p>
<ul>
<li>A file region is consistent if all clients will always see the same data, regardless of which replicas they read from.</li>
<li>A region is defined after a file data mutation if it is consistent and clients will see what the mutation writes in its entirety. </li>
<li>When a mutation succeeds without interference from concurrent writers, the affected region is defined.</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>write</th>
<th>record append</th>
</tr>
</thead>
<tbody><tr>
<td>Serial success</td>
<td>defined</td>
<td>defined, interspersed with inconsistent</td>
</tr>
<tr>
<td>Concurrent success</td>
<td>consistent but undefined</td>
<td>defined, interspersed with inconsistent</td>
</tr>
<tr>
<td>Failure</td>
<td>inconsistent</td>
<td>inconsistent</td>
</tr>
</tbody></table>
</li>
<li><p>Atomic append –&gt; data appended <em>at least once</em>, but at an offset of GFS’s choosing.</p>
<ul>
<li>The offset is returned to the client and marks the beginning of a defined region that contains the record.</li>
<li>GFS may insert padding or record duplicates in between.</li>
</ul>
</li>
<li><p>After a sequence of successful mutations, the mutated file region is guaranteed to be defined.</p>
<ul>
<li>By applying mutations to a chunk in same order on all replicas.</li>
<li>By using chunk version to detect stale replica.</li>
<li>Stale chunk will be garbage collected.</li>
</ul>
</li>
<li><p>Client cache the chunk locations, they may read from stale replicas.</p>
<ul>
<li>This window is limited by lease time</li>
<li>stale replica usually return premature end rather than outdated data since most files are append-only.</li>
</ul>
</li>
</ul>
<p>Implication of Applications</p>
<ul>
<li>append-only rather than writes</li>
<li>checkpointing</li>
<li>self-validating, e.g. record checksums</li>
<li>self-identifying, e.g. record identifier</li>
</ul>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="Lease-and-Mutation-Order"><a href="#Lease-and-Mutation-Order" class="headerlink" title="Lease and Mutation Order"></a>Lease and Mutation Order</h2><p>We use lease to maintain a consistent mutation order across replicas. The master grant a chunk lease to one of the replicas, called <em>primary</em>. A <em>primary</em> picks a mutation ordering for all replicas.</p>
<p>Lease mechanism is designed to <strong>minimize management overhead of master</strong>. It has timeout of 60s. </p>
<p><img src="D:\Blog\source_images\image-20221221223610132.png" alt="image-20221221223610132"></p>
<p>Write operation:</p>
<ol>
<li>Client asks Master who is the primary and other replica locations. If there is no primary, master then  grants one</li>
<li>Master replies the information, and client cache the data for future mutations. It needs to request master again only when primary becomes unreachable.</li>
<li>Client pushes data to all replicas. Chunkserver stores the data in local LRU buffer cache until the data is used or aged out.</li>
<li>Once the replicas have acknowledged the data, Client sends write request to primary. The primary assigns consecutive serial numbers to mutations.</li>
<li>The primary forward the write request to all replicas.</li>
<li>The secondary reply to primary when completed.</li>
<li>The primary replies to the client. <ul>
<li>If error happens at the secondary, primary sends error message to client; Then the client request is considered failed, and the modified region is left in an <strong>inconsistent state</strong>.</li>
<li>If it had failed at the primary, it would not have been assigned a serial number and forwarded.</li>
<li>Client code handles such errors by retrying the failed mutation.</li>
</ul>
</li>
</ol>
<p>If a write by the application is large or straddles a chunk boundary, GFS client code breaks it down into multiple write operations. Final result is consistent but maybe undefined because of interleave of other write operations.</p>
<h2 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h2><p>The control flow and data flow are decoupled, data is <strong>pushed linearly</strong> along a <strong>carefully picked chain</strong> of chunkservers <strong>in a pipelined fashion</strong> to fully <strong>utilize network bandwidth</strong> (so full outbound bandwidth is used to transfer data as fast as possible).</p>
<p>To <strong>avoid high-latency links</strong>, each machine forward data to “closest” machine in network that has not received the data.</p>
<h2 id="Atomic-Append"><a href="#Atomic-Append" class="headerlink" title="Atomic Append"></a>Atomic Append</h2><p>Difference between traditional write and record append?</p>
<ul>
<li>Traditional write: Client specify data and offset –&gt; the concurrent write is not serializable.</li>
<li>In record append (atomic append), Client only specify the data, GFS determine the offset and appends data to the file at least once atomically. And GFS returns the offset to the client.</li>
</ul>
<p>Why we need atomic append?</p>
<ul>
<li>Without atomic append, Clients would need more complicated and expensive synchronization, like through a lock manager.</li>
</ul>
<p>How does atomic append do?</p>
<ul>
<li><p>Record append is mutation that follows the control flow above with only a little extra logic at the primary. </p>
<ul>
<li><p>The primary checks to see if appending the record to the current chunk would cause the chunk to exceed the maximum size (64 MB). If so, it pads the chunk to the maximum size, tells secondaries to do the same, and replies to the client indicating that the operation should be retried on the next chunk.</p>
</li>
<li><p>Record append is restricted to be at most one-fourth of the maximum chunk size to keep worstcase fragmentation at an acceptable level.</p>
</li>
</ul>
</li>
</ul>
<p>How to deal with the inconsistency caused by atomic append?</p>
<ul>
<li>If a record append fails at any replica, the client retries the operation. </li>
<li>As a result, replicas of the same chunk may contain different data possibly including duplicates of the same record in whole or in part. GFS does not guarantee that all replicas are bytewise identical.</li>
<li>Record is written <em><strong>at least once</strong></em>!</li>
<li>Application is responsible for dealing with the inconsistency.</li>
</ul>
<h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>How to implement snapshot using a <strong>copy-on-write</strong> technique?</p>
<ol>
<li>Master receive a snapshot request and then revoke leases.</li>
<li>Master log the request to disk. Then create new files but pointing to same chunks as source files.</li>
<li>When Client want to write to chunk C in new files, It sends request to master to find lease holder, The Master noticed that the reference to C is greater than 1, It then asks each chunkserver that has a current replica of C to create a new chunk called C’. <ul>
<li>By creating the new chunk on the same chunkservers as the original, we ensure that the data can be copied locally, not over the network.</li>
</ul>
</li>
</ol>
<h1 id="Master-Operation"><a href="#Master-Operation" class="headerlink" title="Master Operation"></a>Master Operation</h1><p>Master manage namespace operations, manage chunk replicas throughout the system, make placement decisions, create new chunks, coordinate system-wide activities, balance load.</p>
<h2 id="Namespace-Management-and-Locking"><a href="#Namespace-Management-and-Locking" class="headerlink" title="Namespace Management and Locking"></a>Namespace Management and Locking</h2><p>Unlike traditional filesystems, GFS logically represent its namespace as lookup table mapping pathname to metadata. </p>
<p>Prefix compression –&gt; makes it suitable in memory. </p>
<p>Each node in lookup table has a read-write lock. </p>
<p>How to lock?</p>
<ul>
<li>Since the namespace can have many nodes, read-write lock objects are allocated lazily and deleted once they are not in use.</li>
<li>locks are acquired in a consistent total order to prevent deadlock: they are first ordered by level in the namespace tree and lexicographically within the same level.</li>
</ul>
<h2 id="Replica-Placement-Physically"><a href="#Replica-Placement-Physically" class="headerlink" title="Replica Placement (Physically)"></a>Replica Placement (Physically)</h2><p>Purpose of chunk replica placement policy:</p>
<ul>
<li>maximize data reliability and availability</li>
<li>maximize network bandwidth utilization</li>
</ul>
<p>Method: Spread chunk replicas across racks. This ensures that some replicas of a chunk will survive and remain available even if an entire rack is damaged or offline (such as network partitioning).</p>
<h2 id="Replicas-Management"><a href="#Replicas-Management" class="headerlink" title="Replicas Management"></a>Replicas Management</h2><p>Chunk replicas are created for three reasons: </p>
<ul>
<li>chunk creation</li>
<li>re-replication</li>
<li>rebalancing.</li>
</ul>
<p>Where to place initial empty replicas when creating a chunk?</p>
<ul>
<li>We want to place new replicas on chunkserver whose spare disk space is more than average.</li>
<li>We want to limit recent creation on chunkserver (to avoid heavy write on this chunkserver)</li>
<li>We want to spread chunk replicas across racks.</li>
</ul>
<p>The master re-replicates a chunk as soon as the number of available replicas falls below a user-specified goal. Similar to creating a chunk replica.</p>
<p>The master rebalances replicas periodically: it examines the current replica distribution and moves replicas for better disk space and load balancing.</p>
<h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><p>After a file is deleted, GFS does not immediately reclaim the available physical storage. It does so only lazily during regular garbage collection at both the file and chunk levels</p>
<p>How GFS do garbage collection?</p>
<ul>
<li><p>For Master</p>
<ul>
<li><p>When a file is deleted, it is logged by master immediately. But master rename it to a hidden name with  deletion timestamp.</p>
</li>
<li><p>During the master’s regular scan of the file system namespace, it removes any such hidden files if they have existed for more than three days.</p>
</li>
</ul>
</li>
<li><p>For Chunkserver</p>
<ul>
<li>In a similar regular scan of the chunk namespace, the master identifies orphaned chunks and erases the metadata for those chunks. </li>
<li>In a HeartBeat message regularly exchanged with the master, each chunkserver reports a subset of the chunks it has, and the master replies with the identity of all chunks that are no longer present in the master’s metadata. </li>
<li>Then the chunkserver is free to delete its replicas of such chunks.</li>
</ul>
</li>
</ul>
<p>Benefit:</p>
<ol>
<li>Simple and reliable for distributed system.</li>
<li>It merge storage reclamation into regular background activities.</li>
<li>The delay in reclaiming storage provides a safety net against accidental, irreversible deletion.</li>
</ol>
<p>Main disadvantage: frequently creation and deletion will cause the space tight.</p>
<p>Solution: expediting storage reclamation if a deleted file is explicitly deleted again.</p>
<h2 id="Stale-Replica-Detection"><a href="#Stale-Replica-Detection" class="headerlink" title="Stale Replica Detection"></a>Stale Replica Detection</h2><p>Master increase the chunk version number when it grant a new lease on a chunk. When a replica is not available at this time, its chunk version will not advanced. So when it restart and report its chunk version number to Master, Master will detect that it is a stale replica. </p>
<p>The master removes stale replicas in its regular garbage collection </p>
<h1 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h1><p>Two problems caused by <strong>component failure</strong>:</p>
<ul>
<li>unavailability</li>
<li>corrupted data</li>
</ul>
<h2 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a>Availability</h2><p>Two strategies for high availability:</p>
<ul>
<li>Fast Recovery<ul>
<li>Restore state and restart no matter how they terminated.</li>
</ul>
</li>
<li>Replication<ul>
<li>Chunk Replication</li>
<li>Master Replication</li>
</ul>
</li>
</ul>
<h2 id="Data-Integrity"><a href="#Data-Integrity" class="headerlink" title="Data Integrity"></a>Data Integrity</h2><p>Why we need checksum in chunkserver to detect corruption of stored data?</p>
<ul>
<li>Disks and machines failures are common, causing data corruption.</li>
<li>But it’s impractical to compare replicas to detect corruption. Besides, the semantic of record append doesn’t guarantee identical replicas.</li>
<li>Therefore, each chunkserver must independently verify the integrity of its own copy by maintaining checksums.</li>
</ul>
<p>What happens when reading corrupted data?</p>
<ul>
<li>For Reads, chunkserver verify checksum of data block before returning any data to requester.</li>
<li>If it doesn’t match the checksum, it returns a error to requester and report a mismatch to the master.</li>
<li>Master re-replicate the chunk.</li>
<li>Then master instruct deletion of the corrupted replica.</li>
</ul>
<p>How to calculate checksum when writing data?</p>
<ul>
<li>For appending, There is no need to read the data to checksum first. Because we can checksum later when reading this data.</li>
<li>For random writing, we must read the data and checksum first.</li>
</ul>
<p>Like other metadata, checksums are kept in memory and stored persistently with logging, separate from user data.</p>
<p>During idle periods, chunkservers can scan and verify the contents of inactive chunks.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>GFS structure:</p>
<ul>
<li>Master Data: two tables that matter<ul>
<li>file name –&gt; array of chunk handles</li>
<li>handle –&gt; list of chunk servers, version number, primary, lease expiration</li>
<li>Log and Checkpoint of the 2 above tables –&gt; disk</li>
</ul>
</li>
</ul>
<p>GFS read operation:</p>
<ol>
<li>Client sends file and offset to Master.</li>
<li>Master sends back chunk handles and list of servers back to Client.<ul>
<li>Client cache the map.</li>
</ul>
</li>
<li>Client talk to one of the chunk servers (maybe one closest to the Client)<ul>
<li>chunk server runs Linux filesystem, chunk is stored by file whose name is chunk handle.</li>
</ul>
</li>
<li>Chunk server sends back the chunk files to Client.</li>
</ol>
<p>GFS write(append) operation:</p>
<ul>
<li><p>No Primary</p>
<ol>
<li>Find up-to-date replicas (according to the version numbers in the master).</li>
<li>Pick a primary and a secondary.</li>
<li>Increase the version number.</li>
<li>Sends the primary and secondary with the updated version number and messages and <em>lease</em>.</li>
<li>Master write the version number to the disk.</li>
</ol>
</li>
<li><p>Primary</p>
<ol>
<li>Client sends message to Primary.</li>
<li>Primary sends message to Secondary.</li>
<li>If all Secondary replies ok, Primary sends ok to Client.</li>
<li>Else Primary sends not ok to Client.</li>
</ol>
</li>
</ul>
<p>why we need lease?</p>
<ul>
<li>to avoid “split brain” problem caused by network partition</li>
</ul>
]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Network</title>
    <url>/2022/12/16/Go-Network/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Network</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Current Limit</title>
    <url>/2022/12/15/Current-Limit/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce</title>
    <url>/2022/12/15/MapReduce/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>MapReduce: a <strong>programming model</strong> and <strong>associated implementation</strong> for <strong>processing and generating large datasets</strong>.</p>
<ul>
<li>Map: process key&#x2F;value pair to generate intermediate key&#x2F;value pairs.</li>
<li>Reduce: merges all intermediate values associated with the same intermediate key.</li>
</ul>
<span id="more"></span>

<p>runtime system responsibility:</p>
<ul>
<li>Partitioning the input data.</li>
<li>Scheduling the program’s execution across a set of machines.</li>
<li>Handling managed failures.</li>
<li>Managing inter-machine communication.</li>
</ul>
<p>Motivation:</p>
<ul>
<li>Special purpose coding on distributed systems is hard.</li>
<li>Hide the messy details of parallelization, fault-tolerance, data distribution and load balancing.</li>
</ul>
<h1 id="Programming-Model"><a href="#Programming-Model" class="headerlink" title="Programming Model"></a>Programming Model</h1><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>map and reduce functions are deterministic functions: always get the same output with same input.</p>
<p>map: (k1, v1) –&gt; list(k2, v2)</p>
<p>reduce: (k2, list(v2)) –&gt; list(v3)</p>
<p>Input keys and values are drawn from different domain than the output keys and values. But intermediate keys and values are from the same domain. </p>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>Distributed Grep</p>
</li>
<li><p>Count of URL Access Frequency</p>
</li>
<li><p>Reverse Web-Link Graph: The map function outputs $&lt;target, source&gt;$ pairs for each link to a target URL found in a page named source. The reduce function concatenates the list of all source URLs associated with a given target URL and emits the pair $&lt;target, list(source)&gt;$</p>
</li>
<li><p>Term-Vector per Host</p>
</li>
<li><p>Inverted Index: The map function parses each document, and emits a sequence of $&lt;word, document ID&gt;$ pairs. The reduce function accepts all pairs for a given word, sorts the corresponding document IDs and emits a $&lt;word, list(document ID)&gt;$ pair. The set of all output pairs forms a simple inverted index. It is easy to augment this computation to keep track of word positions.</p>
</li>
<li><p>Distributed Sort: The map function extracts the key from each record, and emits a $&lt;key, record&gt;$ pair. The reduce function emits all pairs unchanged. This computation depends on the partitioning functions and the R files’ ordering properties.</p>
</li>
</ul>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>Implementation environment:</p>
<ul>
<li>Commodity computers are used.</li>
<li>Network (switched Ethernet) is the bottleneck.</li>
<li>Cluster of computers, thus <strong>machine failures are common</strong>.</li>
<li>Storage hardware is inexpensive; using a distributed file system (GFS) to manage data; replication is used.</li>
<li>Users submit jobs to a scheduling system. Each <strong>job</strong> consists of <strong>a set of tasks</strong>, and is <strong>mapped by the scheduler</strong> to a set of available machines within a cluster.</li>
</ul>
<h2 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h2><p><img src="D:\Blog\source_images\image-20221217145110248.png" alt="image-20221217145110248"></p>
<p>What happens when user call MapReduce:</p>
<ol>
<li>The MapReduce library first split input files into M pieces of typically 16 to 64 MB per pieces. It then starts up many copies of the user program on a cluster of machines.</li>
<li>The copied program on master is special. The rest are workers that are assigned work by the master. There are M map tasks and R reduce tasks to assign. The master picks idle workers and assigns each one a map task or a reduce task.</li>
<li>A worker who is assigned a map task reads the input split, and use user-defined map function to process the split. The <strong>intermediate keys and values are buffered in the memory</strong>.</li>
<li><strong>Periodically, the buffered pairs are written to disk</strong>, partitioned into R regions by partition function i.e. $hash(key)%R$. The locations of these buffered pairs on the local disk are passed back to the master, who is responsible for forwarding these locations to the reduce workers.</li>
<li>When a reducer worker is notified by master about the locations, it then uses remote procedure call (RPC) to remotely reads the intermediate keys and values from the map worker’s local disks.</li>
<li>When a reduce worker has read all intermediate data, it sorts it by the intermediate keys so that all occurrences of the same key are grouped together. The <em><strong>sorting is needed because typically many different keys map to the same reduce task</strong></em>. If the amount of intermediate data is too large to fit in memory, an <strong>external sort</strong> (i.e. external merge sort) is used.</li>
<li>The reduce worker iterate the sorted intermediate data, for each unique intermediate key encountered, it passed the key and the corresponding list of intermediate values to user’s reduce function. The output of Reduce function is appended to a final output file for this reduce partition.</li>
<li>When all map tasks and reduce tasks had been done, the master wakeup the user program.</li>
<li>After successful completion, the output is available in R output files. They can be used as input of another MapReduce call.</li>
</ol>
<h2 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h2><p>For each map task and reduce task, it stores:</p>
<ul>
<li>The state (idle, in-progress, or completed)</li>
<li>The identity of the worker machine (for non-idle tasks).</li>
</ul>
<p>master is like a conduit:</p>
<ul>
<li>it propagate the location of R regions on map tasks to reduce tasks</li>
<li>Therefore, for each completed map tasks, the master stores the locations and sizes of R regions.</li>
<li>Updates to this location and size information are received as map tasks are completed. The information is pushed incrementally to workers that have in-progress reduce tasks</li>
</ul>
<h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><h3 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h3><p>How to determine failure of worker?</p>
<ul>
<li>The master pings every worker periodically. If no response is received from a worker in a certain amount of time, the master marks the worker as failed.</li>
</ul>
<p>Which tasks to rollback when workers failed?</p>
<ul>
<li>Any map tasks completed by the failed worker are reset back to their initial idle state, and therefore become eligible for scheduling on other workers. </li>
<li>Similarly, any map task or reduce task in progress on a failed (map or reduce separately) worker is also reset to idle and becomes eligible for rescheduling.</li>
</ul>
<p> Why completed map tasks on failed worker should re-execute while completed reduce tasks don’t?</p>
<ul>
<li>Completed map tasks are re-executed on a failure because their <em>output is stored on the local disk(s)</em> of the failed machine and is therefore <strong>inaccessible</strong>. </li>
<li>Completed reduce tasks do not need to be re-executed since <strong>their output is stored in a global file system</strong>.</li>
</ul>
<p>What happens if map tasks are re-executed?</p>
<ul>
<li>When a map task is executed first by worker A and then later executed by worker B (because A failed), all workers executing reduce tasks are notified of the re-execution. Any reduce task that has not already read the data from worker A will read the data from worker B.</li>
</ul>
<h3 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h3><p>Can be solved with periodic checkpoints of master data structure.</p>
<p>But since there is only one master, it’s unlikely to fail.</p>
<p>So when master fails, we can just abort the computation.</p>
<h3 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h3><p>When user-supplied map and reduce functions are deterministic:</p>
<ul>
<li>MapReduce will produce the same output as non-faulting sequential execution of program.</li>
<li>That property relies on <em><strong>atomic commit</strong></em> of map and reduce tasks.<ul>
<li>For map tasks: when a map task completes, the worker sends a message to the master and includes the names of the R temporary files in the message. <em>If the master receives a completion message for an already completed map task, it ignores the message. Otherwise, it records the names of R files in a master data structure</em>.</li>
<li>For reduce tasks: when a reduce task completes, the <em>reduce worker atomically renames its temporary output file to the final output file</em>. If the same reduce task is executed on multiple machines, multiple rename calls will be executed for the same final output file. We rely on the atomic rename operation provided by the underlying file system to guarantee that the final file system state contains just the data produced by one execution of the reduce task.</li>
</ul>
</li>
</ul>
<p>When user-supplied map and reduce functions are non-deterministic:</p>
<ul>
<li>MapReduce will provide weaker but still reasonable semantics.</li>
<li>In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program. However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.</li>
<li>Consider map task M and reduce tasks $R_1$ and $R_2$. Let $e(R_i)$ be the execution of $R_i$ that committed (there is exactly one such execution). The weaker semantics arise because $e(R_1)$ may have read the output produced by one execution of M and $e(R_2)$ may have read the output produced by a different execution of M.</li>
</ul>
<h2 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h2><p>Since network bandwidth is the bottleneck, one optimization is that running GFS and MapReduce on the same set of machines. And master schedule map tasks to read input locally as possible.</p>
<h2 id="Task-Granularity"><a href="#Task-Granularity" class="headerlink" title="Task Granularity"></a>Task Granularity</h2><p>Ideally M and R should be much larger than number of workers</p>
<ul>
<li>Improves load balancing</li>
<li>Speeds up recovery</li>
</ul>
<p>Practical bounds of M and R:</p>
<ul>
<li>master must take $O(M+R)$ to do scheduling, and take $O(M*R)$ piece of state.</li>
<li>R is also constrained by users because the output of each reduce task ends up in a separate output file.</li>
<li>R is often a small multiple of the number of worker machines we expect to use.</li>
</ul>
<h2 id="Backup-Tasks"><a href="#Backup-Tasks" class="headerlink" title="Backup Tasks"></a>Backup Tasks</h2><p>What is a straggler?</p>
<ul>
<li>straggler is the machine that takes an unusually long time to compute the tasks, it’s often the bottleneck.</li>
</ul>
<p> Backup mechanism to deal with straggler</p>
<ul>
<li>When a <strong>MapReduce operation is close to completion</strong>, the master <strong>schedules backup executions of the remaining in-progress tasks</strong>.</li>
<li>The task is marked as completed whenever either the primary or the backup execution completes.</li>
</ul>
<h1 id="Refinement"><a href="#Refinement" class="headerlink" title="Refinement"></a>Refinement</h1><h2 id="Partition-Function"><a href="#Partition-Function" class="headerlink" title="Partition Function"></a>Partition Function</h2><p>Default partition function: $hash(key)%R$, this tends to generate well-balanced partitions.</p>
<p>But sometimes input are skewed, we need some special partition functions.</p>
<p>For example, when output keys are URLs, and we want all entries for a single host to end up in the same output file. We can then use $hash(Hostname(url))$.</p>
<h2 id="Ordering-Guarantees"><a href="#Ordering-Guarantees" class="headerlink" title="Ordering Guarantees"></a>Ordering Guarantees</h2><p>Within a given partition, the intermediate key&#x2F;value pairs are processed in increasing key order (because it is sorted by reduce). </p>
<p>This ordering makes it easy to <em><strong>generate a sorted output file per partition</strong></em>, which is useful when the output file format needs to support efficient <strong>random access lookups by key</strong> (hash + binary search, similar to hash join algorithm in database)</p>
<h2 id="Combiner-Functions"><a href="#Combiner-Functions" class="headerlink" title="Combiner Functions"></a>Combiner Functions</h2><p>Combiner functions is like a reduce function but runs on map workers.</p>
<p>It can reduce the network overhead by pre-processing (aggregating) the keys and values.</p>
<p>For some kind of tasks, it’s very useful.</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="Input-and-Output-Formats"><a href="#Input-and-Output-Formats" class="headerlink" title="Input and Output Formats"></a>Input and Output Formats</h3><p>Text mode: treat each line as key&#x2F;value pair</p>
<ul>
<li>key: offset in the file</li>
<li>value: content of the line</li>
</ul>
<p>Reader mode: user provide reader interface to split the range.</p>
<h3 id="Side-effects"><a href="#Side-effects" class="headerlink" title="Side effects"></a>Side effects</h3><p>It is useful to generate auxiliary files in map or reduce tasks, MapReduce don’t provide two-phase commit. Therefore, tasks that produce multiple output files with cross-file consistency requirements should be deterministic.</p>
<h3 id="Skipping-Bad-Records"><a href="#Skipping-Bad-Records" class="headerlink" title="Skipping Bad Records"></a>Skipping Bad Records</h3><p>Sometimes it is feasible to ignore some bad records caused by user program, for example doing a statistic analysis on a large dataset.</p>
<p>MapReduce provide some mode to detect records that caused deterministic crashes and skip these records.</p>
<h3 id="Local-Execution"><a href="#Local-Execution" class="headerlink" title="Local Execution"></a>Local Execution</h3><p>Debugging MapReduce is triky, so MapReduce provide tools of debugging, profiling, and small-scale testing, enabling sequentially execute all of the work for a MapReduce operation on the local machine.  </p>
<h3 id="Status-Information"><a href="#Status-Information" class="headerlink" title="Status Information"></a>Status Information</h3><p>The master runs an internal HTTP server and exports a set of status pages for human consumption. </p>
<h3 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h3><p>The MapReduce library provides a counter facility to count occurrences of various events. </p>
<p>To use this facility, <em>user code creates a named counter object</em> and then <em>increments the counter appropriately in the Map and&#x2F;or Reduce function</em>. For example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Counter *uppercase;</span><br><span class="line">uppercase = <span class="built_in">GetCounter</span>(<span class="string">&quot;uppercase&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(String name, String contents) &#123;</span><br><span class="line">    <span class="keyword">for</span> (w : contents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isCapitalized</span>(w)) &#123;</span><br><span class="line">            uppercase-&gt;<span class="built_in">Increment</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">EmitIntermediate</span>(w, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The counter values from individual worker machines are periodically propagated to the master (<em>piggybacked</em> on the ping response). </p>
<p>The master aggregates the counter values from successful map and reduce tasks and returns them to the user code when the MapReduce operation is completed. </p>
<p>The current counter values are also displayed on the master status page so that a human can watch the progress of the live computation. </p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Success of MapReduce</p>
<ol>
<li>Model is easy to use, it hides parallelism, load balance, locality, fault tolerance, etc.</li>
<li>Model is expressive, can be used to solve many problems.</li>
<li>It has scalability, fault tolerance, consistency.</li>
</ol>
<p>Some takeaways</p>
<ol>
<li>Restricting programming model makes it easy for parallelism and fault tolerance.</li>
<li>Network bandwidth is scarce resource. (locality optimization).</li>
<li>Redundant execution can be used to reduce the impact of slow machines.</li>
</ol>
]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Concurrency</title>
    <url>/2022/12/15/Go-Concurrency/</url>
    <content><![CDATA[<blockquote>
<p>Materials:</p>
<ul>
<li><a href="https://vimeo.com/49718712">concurrency is not parallelism</a></li>
<li><a href="https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view">rethinking classical concurrency patterns</a></li>
<li><a href="https://pkg.go.dev/sync#pkg-overview">go sync package</a></li>
<li><a href="https://go.dev/talks/2012/concurrency.slide#1">go concurrency patterns</a></li>
<li><a href="https://blogtitle.github.io/categories/concurrency/">go advanced concurrency patterns</a></li>
</ul>
</blockquote>
<span id="more"></span>

<h1 id="Concurrency-Overview"><a href="#Concurrency-Overview" class="headerlink" title="Concurrency Overview"></a>Concurrency Overview</h1><p>Why concurrency?</p>
<ul>
<li>I&#x2F;O concurrency (network capacity, disk capacity)</li>
<li>Parallelism (multi-core machine)</li>
<li>Convenience (periodic work)</li>
</ul>
<p>Distinctions between concurrency and parallelism?</p>
<ul>
<li>Parallelism: simultaneous executing of programs, which may be correlated, or not be.</li>
<li>Concurrency:  composition of independent executing programs. <em>it’s not same as parallelism, although it enables parallelism</em>!</li>
</ul>
<p>Essence of concurrency:</p>
<ul>
<li>A complex problem can be broken down into several easy-to-understand components.</li>
<li>The pieces can be composed concurrently.</li>
<li>The result is <strong>scalable, correct and maybe parallel</strong>.</li>
</ul>
<h1 id="Go-Concurrency-Features"><a href="#Go-Concurrency-Features" class="headerlink" title="Go Concurrency Features"></a>Go Concurrency Features</h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>Goroutines</p>
<ul>
<li>It’s independently executing program with its own stack which can shrink and grow automatically</li>
<li>Goroutines are multiplexed dynamically onto threads as needed</li>
</ul>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>Communicating in go?</p>
<ul>
<li>Communicating in golang is through channels, it’s more like via file descriptor;</li>
<li>While in original CSP (Communicating Sequential Processing) is through process name, it’s more like via file</li>
</ul>
<p>Synchronization and Communication:</p>
<ul>
<li>Both send and receive are synchronous</li>
<li>A sender and receiver must both be ready to play their part in the communication. Otherwise we wait until they are.</li>
<li>Thus <strong>channels both communicate and synchronize</strong>.</li>
</ul>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>Buffered channels remove synchronization</p>
<p>It seems like Erlang’s mailbox</p>
<h2 id="The-Go-Approach"><a href="#The-Go-Approach" class="headerlink" title="The Go Approach"></a>The Go Approach</h2><p>Principle: <strong>Don’t communicate by sharing memory (i.e. mutex, locks), share memory by communicating.</strong></p>
<p>Low level concurrency: lock, mutex, condition, waitgroup, pool.</p>
<p>high level concurrency: goroutine, channel.</p>
<p><strong>garbage collector, closure, channel, goroutine, select</strong> – these features just stitch together to make concurrency in go powerful and expressive.</p>
<h1 id="Go-Concurrency-Patterns"><a href="#Go-Concurrency-Patterns" class="headerlink" title="Go Concurrency Patterns"></a>Go Concurrency Patterns</h1><h2 id="Generator-Function-Returns-a-Channel"><a href="#Generator-Function-Returns-a-Channel" class="headerlink" title="Generator : Function Returns a Channel"></a>Generator : Function Returns a Channel</h2><h3 id="Normal-Generator-Model"><a href="#Normal-Generator-Model" class="headerlink" title="Normal Generator Model"></a>Normal Generator Model</h3><p>Channels are first-class values (so as functions).</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := boring(<span class="string">&quot;boring!&quot;</span>) <span class="comment">// Function returning a channel.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;You say: %q\n&quot;</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;You&#x27;re boring; I&#x27;m leaving.&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span><span class="params">(msg <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123; <span class="comment">// Returns receive-only channel of strings.</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// We launch the goroutine from inside the function.</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">            c &lt;- fmt.Sprintf(<span class="string">&quot;%s %d&quot;</span>, msg, i)</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c <span class="comment">// Return the channel to the caller.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channels-as-a-Handle-on-a-Service"><a href="#Channels-as-a-Handle-on-a-Service" class="headerlink" title="Channels as a Handle on a Service"></a>Channels as a Handle on a Service</h3><p>Our boring function above returns a channel that lets us communicate with the boring service it provides.</p>
<p>We can have more instances of the service.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    joe := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    ann := boring(<span class="string">&quot;Ann&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(&lt;-joe)</span><br><span class="line">        fmt.Println(&lt;-ann)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Multiplexing-Fan-In"><a href="#Multiplexing-Fan-In" class="headerlink" title="Multiplexing (Fan-In)"></a>Multiplexing (Fan-In)</h3><p>These programs make Joe and Ann count in lockstep.  </p>
<p>We can instead use a fan-in function to let whosoever is ready talk.</p>
<p>It uses multi-channels as input and output a channel that receive multi channels’ output in different goroutines.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(input1, input2 &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; c &lt;- &lt;-input1 &#125; &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; c &lt;- &lt;-input2 &#125; &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := fanIn(boring(<span class="string">&quot;Joe&quot;</span>), boring(<span class="string">&quot;Ann&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(&lt;-c)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">input1 --&gt; channel1 --&gt; channel3</span><br><span class="line">input2 --&gt; channel2 --&gt; channel3</span><br><span class="line">channel3 --&gt; output</span><br></pre></td></tr></table></figure>

<h3 id="Restoring-Sequencing"><a href="#Restoring-Sequencing" class="headerlink" title="Restoring Sequencing"></a>Restoring Sequencing</h3><p>Fan-In is useful, but sometimes we want restoring the sequencing of two services.</p>
<p>Idea is <strong>sending a channel on a channel, making goroutines wait its turn</strong></p>
<p>So, first we define a struct that contains a channel for the reply</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    str <span class="type">string</span></span><br><span class="line">    wait <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For receiver who receives message:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    msg1 := &lt;-c</span><br><span class="line">    fmt.Println(msg1)</span><br><span class="line">    msg2 := &lt;-c</span><br><span class="line">    fmt.Println(msg2)</span><br><span class="line">    msg1.wait &lt;- <span class="literal">true</span>	<span class="comment">// unlock the sender which is stalled on &lt;-WaitForIt</span></span><br><span class="line">    msg2.wait &lt;- <span class="literal">true</span>	<span class="comment">// unlock the sender which is stalled on &lt;-WaitForIt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For Sender who sends message:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">WaitForIt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> ExistUnsentMessage() &#123;</span><br><span class="line">    c &lt;- message&#123;<span class="string">&quot;message&quot;</span>, WaitForIt&#125;</span><br><span class="line">    time.Sleep(time.Duration(rand.Intn(<span class="number">2e3</span>)) * time.Millisecond)</span><br><span class="line">    &lt;-WaitForIt		<span class="comment">// get stalled when </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The technique above can restore the sequence of message: for the fact that Sender cannot send message twice to channel <code>c</code> because it will get stalled in <code>&lt;-WaitForIt</code> statement</p>
<blockquote>
<p>Assume sender1 sends on msg1, then it will get stalled on <code>&lt;-WaitForIt</code>, sender2 then can send on msg2, and also get stalled on <code>&lt;-WaitForIt</code>, and because sender1 sent first, so sender1 get stalled on <code>c &lt;- message&#123;...&#125;</code> first, so msg1 is still sender1</p>
</blockquote>
<blockquote>
<p> Assume sender1 sends on msg2, then sender2 sends on msg1, so the same situation as above  </p>
</blockquote>
<h2 id="Select-Statement"><a href="#Select-Statement" class="headerlink" title="Select Statement"></a>Select Statement</h2><h3 id="Fan-In-Using-Select"><a href="#Fan-In-Using-Select" class="headerlink" title="Fan-In Using Select"></a>Fan-In Using Select</h3><p>By using select statement, we only need to start one goroutine to fan-in channels.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(input1, input2 &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input1:  c &lt;- s</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input2:  c &lt;- s</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Timeout-Using-Select"><a href="#Timeout-Using-Select" class="headerlink" title="Timeout Using Select"></a>Timeout Using Select</h3><p>The time.After function returns a channel that blocks for the specified duration.<br>After the interval, the channel delivers the current time, once.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">            fmt.Println(<span class="string">&quot;You&#x27;re too slow.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Timeout-for-Whole-Conversation-Using-Select"><a href="#Timeout-for-Whole-Conversation-Using-Select" class="headerlink" title="Timeout for Whole Conversation Using Select"></a>Timeout for Whole Conversation Using Select</h3><p>Create the timer once, outside the loop, to time out the entire conversation.<br>While in the previous program, we had a timeout for each message.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    timeout := time.After(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">            fmt.Println(<span class="string">&quot;You talk too much.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Receive-on-quit-channel"><a href="#Receive-on-quit-channel" class="headerlink" title="Receive on quit channel"></a>Receive on quit channel</h3><p>When it want to quit a goroutine, send message on quit channel</p>
<p><code>case &lt;-quit</code> will do cleanup (like remove a temporary file), and tell back that it had quit (<strong>round-trip quit, in case that main goroutine quit before cleanup had been done</strong>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">c := boring(<span class="string">&quot;Joe&quot;</span>, quit)</span><br><span class="line"><span class="keyword">for</span> i := rand.Intn(<span class="number">10</span>); i &gt;= <span class="number">0</span>; i-- &#123; fmt.Println(&lt;-c) &#125;</span><br><span class="line">quit &lt;- <span class="string">&quot;Bye!&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Joe says: %q\n&quot;</span>, &lt;-quit)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- fmt.Sprintf(<span class="string">&quot;%s: %d&quot;</span>, msg, i):</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">    cleanup()</span><br><span class="line">    quit &lt;- <span class="string">&quot;See you!&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Daisy-Chain"><a href="#Daisy-Chain" class="headerlink" title="Daisy Chain"></a>Daisy Chain</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	routine1 --&gt; routine2 --left channel--&gt; routine3 --right channel--&gt; routine4 --&gt; routine5 --&gt; routine...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(left, right <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    left &lt;- <span class="number">1</span> + &lt;-right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="number">10000</span></span><br><span class="line">    leftmost := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    right := leftmost</span><br><span class="line">    left := leftmost</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        right = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> f(left, right)</span><br><span class="line">        left = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123; c &lt;- <span class="number">1</span> &#125;(right)</span><br><span class="line">    fmt.Println(&lt;-leftmost)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Rethinking-Classical-Concurrent-Patterns"><a href="#Rethinking-Classical-Concurrent-Patterns" class="headerlink" title="Rethinking Classical Concurrent Patterns"></a>Rethinking Classical Concurrent Patterns</h1><p>Two principles in go:</p>
<ol>
<li>Start goroutines when you have concurrent work</li>
<li>Share by communicating</li>
</ol>
<p>Other principles in go:</p>
<ol>
<li>Make concurrency internal detail.</li>
<li>Add concurrency on the caller side of the API.</li>
<li>Concurrency is not asynchronicity.</li>
</ol>
<h2 id="Asynchronous-API"><a href="#Asynchronous-API" class="headerlink" title="Asynchronous API"></a>Asynchronous API</h2><p>Concurrency is not asynchronicity.</p>
<p>An asynchronous API returns to the caller <strong>before its result is ready</strong>.</p>
<p>An asynchronous program is not necessarily concurrent: a program could call an asynchronous function and then sit idle waiting for the results.</p>
<p>There are several asynchronous patterns:</p>
<ul>
<li>asynchronous callback (deprecated)</li>
<li>future</li>
<li>producer-consumer queue</li>
</ul>
<h3 id="Asynchronous-Callback"><a href="#Asynchronous-Callback" class="headerlink" title="Asynchronous Callback"></a>Asynchronous Callback</h3><p>A callback is a simple function that’s passed as a value to another function, and will only be executed when the event happens.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetch immediately returns, then fetches the item and </span></span><br><span class="line"><span class="comment">// invokes f in a goroutine when the item is available. </span></span><br><span class="line"><span class="comment">// If the item does not exist,</span></span><br><span class="line"><span class="comment">// Fetch invokes f on the zero Item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>, f <span class="keyword">func</span>(Item)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        […]</span><br><span class="line">        f(item)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>In the Future pattern, instead of returning the result, the function returns a proxy object that allows the caller to wait for the result at some later point.</p>
<p>The Go analogue to a <strong>Future</strong> is a <strong>single-element buffered channel</strong>.</p>
<p>To use Futures for concurrency, the caller must <strong>set up concurrent work before retrieving results</strong>.</p>
<p>If they retrieve the results too early, the program executes <em>sequentially instead of concurrently</em>.</p>
<p>the channel pattern seems to be more common than the function-based alternative</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: API, channel-based</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch immediately returns a channel, then fetches </span></span><br><span class="line"><span class="comment">// the requested item and sends it on the channel. </span></span><br><span class="line"><span class="comment">// If the item does not exist,</span></span><br><span class="line"><span class="comment">// Fetch closes the channel without sending.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        […]</span><br><span class="line">        c &lt;- item</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: The precise way, function-based</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">()</span></span> Item) &#123;</span><br><span class="line">    item := <span class="built_in">new</span>(Item)</span><br><span class="line">    ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    […]</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> Item &#123;</span><br><span class="line">        &lt;-ready</span><br><span class="line">        <span class="keyword">return</span> *item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: caller side</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Right</span></span><br><span class="line">a := Fetch(<span class="string">&quot;a&quot;</span>) </span><br><span class="line">b := Fetch(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">consume(&lt;-a, &lt;-b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// False</span></span><br><span class="line">a := &lt;-Fetch(<span class="string">&quot;a&quot;</span>) <span class="comment">// routine get stalled on this line, so will lose concurrency</span></span><br><span class="line">b := &lt;-Fetch(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">consume(a, b)</span><br></pre></td></tr></table></figure>

<h3 id="Producer–Consumer-Queue"><a href="#Producer–Consumer-Queue" class="headerlink" title="Producer–Consumer Queue"></a>Producer–Consumer Queue</h3><p>A producer–consumer queue also returns a channel, but the <strong>channel receives any number of results and is typically unbuffered</strong>.</p>
<p>A channel fed by one goroutine and read by another <strong>acts as a queue</strong>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Glob finds all items with names matching pattern</span></span><br><span class="line"><span class="comment">// and sends them on the returned channel.</span></span><br><span class="line"><span class="comment">// It closes the channel when all items have been sent. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(pattern <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">        <span class="keyword">for</span> […] &#123;</span><br><span class="line">            […]</span><br><span class="line">            c &lt;- item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Producer-Consumer Queue: caller side</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> Glob(<span class="string">&quot;[ab]*&quot;</span>) &#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Analysis-of-Asynchronous-API"><a href="#Analysis-of-Asynchronous-API" class="headerlink" title="Analysis of Asynchronous API"></a>Analysis of Asynchronous API</h3><p>Classical Benefit:</p>
<ul>
<li>Responsiveness : Avoid blocking UI and network threads<ul>
<li>Most other languages don’t multiplex across OS threads, and kernel schedulers can be unpredictable. So some popular languages and frameworks keep all of the UI or network logic on a single thread. If that thread makes a call that blocks for too long, the UI becomes choppy, or network latency spikes.</li>
<li>Since calls to asynchronous APIs by definition don’t block, they help to keep single-threaded programs responsive.</li>
<li>For go, goroutines are managed by go-runtime, not by kernel scheduler, so the first benefit doesn’t apply to go.</li>
</ul>
</li>
<li>Efficiency : Reduce  idle threads<ul>
<li>Threads are expensive</li>
<li>Languages that don’t multiplex over threads can use asynchronous APIs to keep threads busy, reducing the total number of threads — and context-switches</li>
<li>For go, goroutine is lightweight, it doesn’t spend too much on context switch.</li>
</ul>
</li>
<li>Efficiency : Reclaim stack frames<ul>
<li>Save frame space for other purpose.</li>
<li>For go, runtime resize and reallocate stack as needed. Besides, <strong>the storage location chosen by implementation is irrelevant to the semantics of the language</strong>.</li>
</ul>
</li>
<li>Concurrency : Initiate concurrent work<ul>
<li>Can be important for network RPCs</li>
</ul>
</li>
</ul>
<p>Classical Problems:</p>
<ul>
<li>Caller-Side Ambiguity</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	kind <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = <span class="keyword">map</span>[<span class="type">string</span>]Item&#123;</span><br><span class="line">	<span class="string">&quot;a&quot;</span>: Item&#123;<span class="string">&quot;gopher&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;b&quot;</span>: Item&#123;<span class="string">&quot;rabbit&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSlowThing</span><span class="params">()</span></span> &#123; time.Sleep(<span class="number">10</span> * time.Millisecond) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(a, b Item)</span></span> &#123;</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		item := items[name]</span><br><span class="line">		c &lt;- item</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glob finds all items with names matching pattern</span></span><br><span class="line"><span class="comment">// and sends them on the returned channel.</span></span><br><span class="line"><span class="comment">// It closes the channel when all items have been sent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(pattern <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">		<span class="keyword">for</span> name, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">			<span class="keyword">if</span> ok, _ := filepath.Match(pattern, name); !ok &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			c &lt;- item</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> Glob(<span class="string">&quot;[ab]*&quot;</span>) &#123;</span><br><span class="line">		fmt.Println(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Condition-Variable"><a href="#Condition-Variable" class="headerlink" title="Condition Variable"></a>Condition Variable</h2><h3 id="Condition-Variable-Analysis"><a href="#Condition-Variable-Analysis" class="headerlink" title="Condition Variable Analysis"></a>Condition Variable Analysis</h3><p>Problems:</p>
<ul>
<li>Spurious wakeups: Signal some or the threads are hard.</li>
<li>Forgotten signals: Forget to signal some threads when programming.</li>
<li>Starvation: long-running threads will get starved.</li>
<li>Unresponsive cancellation: While waiting for a condition, it may miss other event.</li>
</ul>
<p>Fundamentally, <strong>condition variables rely on communicating by sharing memory</strong>: they signal that a change has occurred, but leave it up to the signalled goroutine to check other shared variables to figure out what. On the other hand, the <strong>Go approach is to share by communicating</strong>.</p>
<h3 id="Semaphore-Sharing-by-Communicating"><a href="#Semaphore-Sharing-by-Communicating" class="headerlink" title="Semaphore : Sharing by Communicating"></a>Semaphore : Sharing by Communicating</h3><p>Go Benefits:</p>
<ul>
<li>Indicate the existence of new data.</li>
<li>Share data by communicating data.</li>
<li>Share things by communicating things.</li>
<li>Metadata are data too!</li>
<li>Mark transitions: mark that a broadcast by close a channel.</li>
</ul>
<p>Buffered channels –&gt; Semaphore pattern</p>
<h2 id="Worker-Pool"><a href="#Worker-Pool" class="headerlink" title="Worker Pool"></a>Worker Pool</h2><p>Benefits:</p>
<ul>
<li>Distribute work across threads<ul>
<li>Threads are heavyweight, worker pool allow reusing threads</li>
<li>Goroutines are lightweight, so it doesn’t apply to go</li>
</ul>
</li>
<li>Limit work in flight</li>
</ul>
<p>Principles:</p>
<ul>
<li><p>Start your goroutine only when you have concurrent work to do now</p>
</li>
<li><p>WaitGroup is enough –&gt; semaphore patterns</p>
</li>
</ul>
<h1 id="Go-Advanced-Concurrency-Patterns"><a href="#Go-Advanced-Concurrency-Patterns" class="headerlink" title="Go Advanced Concurrency Patterns"></a>Go Advanced Concurrency Patterns</h1><h2 id="Timeout-and-Multi-channels"><a href="#Timeout-and-Multi-channels" class="headerlink" title="Timeout and Multi-channels"></a>Timeout and Multi-channels</h2><h3 id="Timed-Channel-Operations"><a href="#Timed-Channel-Operations" class="headerlink" title="Timed Channel Operations"></a>Timed Channel Operations</h3><p>Keep trying doing something, but drop the ball when timeout</p>
<ul>
<li><code>context</code> implementation (more idiomatic)</li>
<li><code>time</code> implementation</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// context impl.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChanTimedContext</span><span class="params">(ctx context.Context, d time.Duration, message Type, c <span class="keyword">chan</span>&lt;- Type)</span></span> (written <span class="type">bool</span>) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(ctx, d)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// time impl.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChanTimedTimer</span><span class="params">(d time.Duration, message Type, c <span class="keyword">chan</span>&lt;- Type)</span></span> (written <span class="type">bool</span>) &#123;</span><br><span class="line">	t := time.NewTimer(d)</span><br><span class="line">	<span class="keyword">defer</span> t.Stop()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="First-in-First-Served"><a href="#First-in-First-Served" class="headerlink" title="First in First Served"></a>First in First Served</h3><p>Sometimes you want to write the same message to many channels, writing to whichever is available first, but <strong>never writing the same message twice</strong> on the same channel.</p>
<ul>
<li>Use <code>select</code> statement to achieve so.</li>
<li>Use goroutines and waits</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// select statement</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServeSelect</span><span class="params">(message Type, a, b <span class="keyword">chan</span> Type)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> a &lt;- message:</span><br><span class="line">            a = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> b &lt;- message:</span><br><span class="line">            b = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// goroutine</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServeGoroutine</span><span class="params">(message Type, a, b <span class="keyword">chan</span> Type)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a &lt;- message; wg.Done() &#125; ()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; b &lt;- message; wg.Done() &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this case performance might matter, and at the time of writing the solution that spawns goroutines takes almost 4 times more than the one with <code>select</code>.</p>
<p>If the amount of channels is not known at compile time, the first solution becomes trickier, but it is still possible, while the second one stays basically unchanged.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServedGoroutinesVariadic</span><span class="params">(message Type, chs ...<span class="keyword">chan</span>&lt;- Type)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(chs))</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> chs &#123;</span><br><span class="line">		c := c</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- message; wg.Done() &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServedSelectVariadic</span><span class="params">(message Type, chs ...<span class="keyword">chan</span>&lt;- Type)</span></span> &#123;</span><br><span class="line">	cases := <span class="built_in">make</span>([]reflect.SelectCase, <span class="built_in">len</span>(chs))</span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> chs &#123;</span><br><span class="line">		cases[i] = reflect.SelectCase&#123;</span><br><span class="line">			Dir:  reflect.SelectSend,</span><br><span class="line">			Chan: reflect.ValueOf(ch),</span><br><span class="line">			Send: reflect.ValueOf(message),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(chs); i++ &#123;</span><br><span class="line">		chosen, _, _ := reflect.Select(cases)</span><br><span class="line">		cases[chosen].Chan = reflect.ValueOf(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The solution using reflection is almost two orders of magnitude slower than the one with goroutines and unreadable.</p>
<h3 id="First-in-First-Serve-with-Timeout"><a href="#First-in-First-Serve-with-Timeout" class="headerlink" title="First in First Serve with Timeout"></a>First in First Serve with Timeout</h3><p>There are two solutions in case you want to try a several sends and abort if it takes too long.</p>
<ul>
<li><code>time + select</code> : better if account of channels are known at compile time.</li>
<li><code>context + go</code> : channels are unknown at compile time.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// time + select</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChansTimedTimerSelect</span><span class="params">(d time.Duration, message Type, a, b <span class="keyword">chan</span> Type)</span></span> (written <span class="type">int</span>) &#123;</span><br><span class="line">	t := time.NewTimer(d)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> a &lt;- message:</span><br><span class="line">			a = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> b &lt;- message:</span><br><span class="line">			b = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t.Stop()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// context + go</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChansTimedContextGoroutines</span><span class="params">(ctx context.Context, d time.Duration, message Type, ch ...<span class="keyword">chan</span> Type)</span></span> (written <span class="type">int</span>) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(ctx, d)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		wr <span class="type">int32</span></span><br><span class="line">		wg sync.WaitGroup</span><br><span class="line">	)</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(ch))</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		c := c</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">				atomic.AddInt32(&amp;wr, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(wr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><h3 id="time-Ticker"><a href="#time-Ticker" class="headerlink" title="time.Ticker"></a>time.Ticker</h3><p>NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. </p>
<p>The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. </p>
<p>Stop the ticker to release associated resources.</p>
<p>Some caveats:</p>
<ul>
<li><strong>Sends will drop all unread values if <code>C</code> already has one message in it</strong>.</li>
<li>It <strong>must be stopped</strong>: the GC will not collect it otherwise.</li>
<li>Setting <code>C</code> is useless: <strong>messages will still be sent on the original channel</strong>.</li>
</ul>
<h3 id="time-Tick"><a href="#time-Tick" class="headerlink" title="time.Tick"></a>time.Tick</h3><p>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only.</p>
<p>But this is something that should never be used unless you plan to carry the returned <code>chan</code> around and keep using it for the <strong>entire lifetime of the program</strong>.</p>
<p><strong>Because the underlying Ticker cannot be recovered by the garbage collector; it “leaks”</strong>.</p>
<h3 id="time-Timer"><a href="#time-Timer" class="headerlink" title="time.Timer"></a>time.Timer</h3><p>The Timer type represents a single event. <em>When the Timer expires, the current time will be sent on C</em>, unless the Timer was created by AfterFunc. <em><strong>A Timer must be created with NewTimer or AfterFunc</strong></em>.</p>
<p><code>Reset</code> changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.</p>
<p><em><strong>For a Timer created with NewTimer, Reset should be invoked only on stopped or expired timers with drained channels</strong></em>.</p>
<p>Some caveat:</p>
<ul>
<li><code>C</code> cannot be set by user although it is exported.</li>
<li><code>Timer</code> returned by <code>AfterFunc</code> doesn’t use <code>C</code> at all.</li>
<li><code>C</code> will not be closed even after Stop the Timer</li>
<li><code>Stop</code> is safe only after <code>New</code> and <code>Reset</code>.</li>
<li><code>Reset</code> is only valid after <code>Stop</code>.</li>
<li>Received value is valid only if channel is drained after each <code>Stop</code>.</li>
<li>The channel should be drained if and only if the channel has not been read yet.</li>
</ul>
<p><code>time.Afterfunc</code>:</p>
<ul>
<li>AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that <strong>can be used to cancel the call using its Stop method</strong>.</li>
<li>when calling <code>Stop</code>, if <code>false</code> is returned, it means that stopping failed and the function was already started.</li>
</ul>
<p><code>time.NewTimer</code>:</p>
<ul>
<li><p>NewTimer creates a new Timer that will send the current time on its channel after at least duration d.</p>
</li>
<li><p>This means that there is no way to construct a valid <code>Timer</code> without starting it. If you need to construct one for future re-use, you either do it lazily or you have to create and stop it, which can be done with this code:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.NewTimer(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> !t.Stop() &#123;</span><br><span class="line">	&lt;-t.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>time.Stop</code>:</p>
<ul>
<li><p>Stop prevents the Timer from firing. It returns <strong>true</strong> if the <strong>call stops the timer</strong>, <strong>false</strong> if the timer has <em><strong>already expired</strong></em> <strong>or</strong> <em><strong>been stopped</strong></em>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//* not thread safe</span></span><br><span class="line"><span class="keyword">if</span> !t.Stop() &#123;</span><br><span class="line">	&lt;-t.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>time.Reset</code>:</p>
<ul>
<li>Note that it is not possible to use Reset’s return value correctly, as there is a race condition between draining the channel and the new timer expiring. <strong>Reset should always be invoked on stopped or expired channels</strong>.</li>
<li>You cannot use <code>Stop</code> nor <code>Reset</code> concurrently <em>with other receives from the channel</em>, and in order for the value sent on <code>C</code> to be valid, <strong><code>C</code> should be drained exactly once before each <code>Reset</code></strong>.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Timer API</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">	C &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span></span>) *Timer</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span></span> *Timer</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Timer)</span></span> Stop(<span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Timer)</span></span> Reset(d Duration) <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_images\image-20221216234927956.png" alt="image-20221216234927956"></p>
<h3 id="time-After"><a href="#time-After" class="headerlink" title="time.After"></a>time.After</h3><p>This is basically the same concept of <code>Tick</code> but instead of hiding a <code>Ticker</code>, hides a <code>Timer</code>. This is slightly better because once the timer will fire, it will be collected. Please note that timers use 1-buffered channels, so they can fire even if no one is receiving.</p>
<p>But if you care about performance and you want to be able to cancel the call, you should not use <code>After</code>.</p>
<h2 id="Some-Tricks"><a href="#Some-Tricks" class="headerlink" title="Some Tricks"></a>Some Tricks</h2><ul>
<li>For-select loop</li>
<li>Service channel, reply channels (channel of channel)</li>
<li><code>nil</code> channel for select cases</li>
</ul>
<h1 id="Example-Search-Engine"><a href="#Example-Search-Engine" class="headerlink" title="Example : Search Engine"></a>Example : Search Engine</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	res <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Search <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FakeSearch</span><span class="params">(kind <span class="type">string</span>)</span></span> Search &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line">		<span class="keyword">return</span> Result&#123;fmt.Sprintf(<span class="string">&quot;%v returns %v&quot;</span>, kind, query)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	Web    = FakeSearch(<span class="string">&quot;Web&quot;</span>)</span><br><span class="line">	Image  = FakeSearch(<span class="string">&quot;Image&quot;</span>)</span><br><span class="line">	Video  = FakeSearch(<span class="string">&quot;Video&quot;</span>)</span><br><span class="line">	Web1   = FakeSearch(<span class="string">&quot;Web&quot;</span>)</span><br><span class="line">	Image1 = FakeSearch(<span class="string">&quot;Image&quot;</span>)</span><br><span class="line">	Video1 = FakeSearch(<span class="string">&quot;Video&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Generator</span><span class="params">(query <span class="type">string</span>)</span></span> <span class="keyword">chan</span> Result &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Web(query) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Image(query) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Video(query) &#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">timeout edition of google search engine</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoogleTimeout</span><span class="params">(query <span class="type">string</span>)</span></span> []Result &#123;</span><br><span class="line">	results := <span class="built_in">make</span>([]Result, <span class="number">0</span>)</span><br><span class="line">	ch := Generator(query)</span><br><span class="line">	timeout := time.After(<span class="number">80</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">			results = <span class="built_in">append</span>(results, res)</span><br><span class="line">			fmt.Println(res)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">			<span class="keyword">return</span> results</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchWithReplicas</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">for</span> _, search := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(search <span class="keyword">func</span>(query <span class="type">string</span>)</span></span> Result) &#123;</span><br><span class="line">			ch &lt;- search(query)</span><br><span class="line">		&#125;(search)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Google</span><span class="params">(query <span class="type">string</span>)</span></span> []Result &#123;</span><br><span class="line">	<span class="keyword">var</span> results []Result</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Web, Web1) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Image, Image1) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Video, Video1) &#125;()</span><br><span class="line">	timeout := time.After(time.Duration(<span class="number">80</span>) * time.Millisecond)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">			results = <span class="built_in">append</span>(results, res)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">			<span class="comment">// return results</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	start := time.Now()</span><br><span class="line">	results := Google(<span class="string">&quot;who are you?&quot;</span>)</span><br><span class="line">	elapsed := time.Since(start)</span><br><span class="line">	fmt.Println(elapsed)</span><br><span class="line">	fmt.Println(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Example-Load-Balancer"><a href="#Example-Load-Balancer" class="headerlink" title="Example : Load Balancer"></a>Example : Load Balancer</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">this is a pseudo code for load balancer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Requester</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> <span class="comment">// the operation to perform</span></span><br><span class="line">	c  <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// the channel to return results</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requester</span><span class="params">(works <span class="keyword">chan</span> Request)</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(<span class="number">80</span>)) * time.Millisecond) <span class="comment">//* to emulate load time</span></span><br><span class="line">		works &lt;- Request&#123;workFn, c&#125;</span><br><span class="line">		result := &lt;-c</span><br><span class="line">		futherProcess(result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Worker</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	requests <span class="keyword">chan</span> Request</span><br><span class="line">	pending  <span class="type">int</span></span><br><span class="line">	index    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> work(done <span class="keyword">chan</span> *Worker) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		req := &lt;-w.requests</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(req Request)</span></span> &#123;</span><br><span class="line">			req.c &lt;- req.fn()</span><br><span class="line">			done &lt;- w</span><br><span class="line">		&#125;(req)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Balacer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool []*Worker</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Balancer <span class="keyword">struct</span> &#123;</span><br><span class="line">	pool Pool</span><br><span class="line">	done <span class="keyword">chan</span> *Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> balancer(work <span class="keyword">chan</span> Request) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> req := &lt;-work:</span><br><span class="line">			b.dispatch(req)</span><br><span class="line">		<span class="keyword">case</span> w := &lt;-b.done:</span><br><span class="line">			b.complete(w)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> dispatch(req Request) &#123;</span><br><span class="line">	w := heap.Pop(&amp;b.pool).(*Worker)</span><br><span class="line">	w.requests &lt;- req</span><br><span class="line">	w.pending++</span><br><span class="line">	heap.Push(&amp;b.pool, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> complete(w *Worker) &#123;</span><br><span class="line">	w.pending--</span><br><span class="line">	heap.Remove(&amp;b.pool, w.index)</span><br><span class="line">	heap.Push(&amp;b.pool, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> poolSize = <span class="number">30</span></span><br><span class="line">	<span class="keyword">var</span> requests <span class="keyword">chan</span> Request = <span class="built_in">make</span>(<span class="keyword">chan</span> Request)</span><br><span class="line">	<span class="keyword">go</span> requester(requests) <span class="comment">//* load request and generate work</span></span><br><span class="line">	<span class="keyword">var</span> b Balancer = Balancer&#123;<span class="built_in">make</span>(Pool, <span class="number">0</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> *Worker)&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; poolSize; i++ &#123;</span><br><span class="line">		b.pool = <span class="built_in">append</span>(b.pool, &amp;Worker&#123;requests, <span class="number">0</span>, i&#125;)</span><br><span class="line">		<span class="keyword">go</span> b.pool[i].work(b.done)</span><br><span class="line">	&#125; <span class="comment">//* generate workers</span></span><br><span class="line"></span><br><span class="line">	b.balancer(requests) <span class="comment">//* do load balance things</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>RISC-V</title>
    <url>/2022/11/17/RISC-V/</url>
    <content><![CDATA[<p>CSR (Control and Status Registers) : 64bits</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>register</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>mscratch</td>
<td>Machine Scratch。保存机器模式的栈顶指针，这一点在离开机器模式进入低特权级模式（如监管模式）时非常重要，因为一旦在低特权级模式发生异常，将可能会回到机器模式处理，这时机器模式需要有自己的栈来保存M模式下的执行所调用的函数参数和返回地址。</td>
</tr>
<tr>
<td>mstatus</td>
<td>Machine Status。保存机器状态的寄存器。</td>
</tr>
<tr>
<td>mtvec</td>
<td>Machine Trap Vector。指向中断处理函数的入口地址。</td>
</tr>
<tr>
<td>mepc</td>
<td>Machine Exception PC。指向发生异常的那条指令的地址。</td>
</tr>
<tr>
<td>mcause</td>
<td>Machine Cause。发生中断的原因，如果发生的中断是异常，其最高位为0，低位为异常编号；如果发生的是其他类型的中断，则其最高位为1，低位为中断编号。</td>
</tr>
<tr>
<td>mtval</td>
<td>Machine Trap Value。异常发生时，附带的参数值。例如，当缺页异常发生时，mtval的值就是程序想要访问的虚地址。</td>
</tr>
<tr>
<td>mie</td>
<td>Machine Interrupt Enable。中断开启寄存器。</td>
</tr>
<tr>
<td>mip</td>
<td>Machine Interrupt Pending。中断等待寄存器。</td>
</tr>
<tr>
<td>mideleg</td>
<td>Machine Interrupt Delegation Registers。中断代理寄存器。</td>
</tr>
<tr>
<td>medeleg</td>
<td>Machine Exception Delegation Registers。异常代理寄存器。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>sscratch</td>
<td>Supervisor Scratch。保存监管模式的栈顶指针，这一点在离开机器模式进入低特权级模式（如用户模式）时非常重要，因为一旦在低特权级模式发生异常，将可能会回到监管模式处理（假设已通过异常授权），这时监管模式需要用自己的栈保存程序执行的返回地址等。</td>
</tr>
<tr>
<td>sstatus</td>
<td>Supervisor Status。保存监管状态的寄存器。</td>
</tr>
<tr>
<td>stvec</td>
<td>Supervisor Trap Vector。指向监管模式中断处理函数的入口地址。</td>
</tr>
<tr>
<td>sepc</td>
<td>Supervisor Exception PC。指向发生异常的那条指令的地址。</td>
</tr>
<tr>
<td>scause</td>
<td>Supervisor Cause。发生中断的原因，如果发生的中断是异常，其最高位为0，低位为异常编号；如果发生的是其他中断其最高位为1，低位为中断编号。</td>
</tr>
<tr>
<td>stval</td>
<td>Supervisor Trap Value。异常发生时，附带的参数值。例如，当缺页异常发生时，mtval的值就是程序想要访问的虚地址。</td>
</tr>
<tr>
<td>sie</td>
<td>Supervisor Interrupt Enable。中断开启寄存器。</td>
</tr>
<tr>
<td>sip</td>
<td>Supervisor Interrupt Pending。中断等待寄存器。</td>
</tr>
<tr>
<td>sideleg</td>
<td>Supervisor Interrupt Delegation Registers。中断代理寄存器。</td>
</tr>
<tr>
<td>sedeleg</td>
<td>Supervisor Exception Delegation Registers。异常代理寄存器。</td>
</tr>
</tbody></table>
<p>CSR 读写指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>csrr rd, csr</td>
<td>Control and Status Register Read，<strong>读</strong>CSR指令。 把csr寄存器中的值写入到rd寄存器中。</td>
</tr>
<tr>
<td>csrw csr, rs1</td>
<td>Control and Status Register Write，<strong>写</strong>CSR指令。 把rs1的值写到csr寄存器中。</td>
</tr>
<tr>
<td>csrs csr, rs1</td>
<td>Control and Status Register Set，<strong>设置</strong>CSR指令。 对于rs1中每一个为1的位，将csr寄存器中对应位置位。</td>
</tr>
<tr>
<td>csrc csr, rs1</td>
<td>Control and Status Register Clear，<strong>清除</strong>CSR指令。 对于rs1中每一个为1的位，将csr寄存器中对应位清零。</td>
</tr>
<tr>
<td>csrrs rd, csr, rs1</td>
<td>Control and Status Register Read and Set，<strong>读后置位</strong>CSR指令。 记控制寄存器中的值为t，把t和寄存器rs1按位或的结果写入csr寄存器，再把t写入rd寄存器。</td>
</tr>
<tr>
<td>csrrc rd, csr, rs1</td>
<td>Control and Status Register Read and Clear，<strong>读后清除</strong>CSR指令。 记控制寄存器中的值为t，把t和寄存器rs1中的值按位与的结果写入csr寄存器，再把t写入rd寄存器。</td>
</tr>
<tr>
<td>csrrw rd, csr, rs1</td>
<td>Control and Status Register Read and Write，<strong>读后写</strong>CSR指令。 记控制寄存器中的值为t，把寄存器rs1的值写入csr寄存器，再把t写入rd寄存器。</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>RISC-V</tag>
      </tags>
  </entry>
</search>
