<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GFS</title>
    <url>/2022/12/17/GFS/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Network</title>
    <url>/2022/12/16/Go-Network/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Network</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Current Limit</title>
    <url>/2022/12/15/Current-Limit/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce</title>
    <url>/2022/12/15/MapReduce/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>MapReduce: a <strong>programming model</strong> and <strong>associated implementation</strong> for <strong>processing and generating large datasets</strong>.</p>
<ul>
<li>Map: process key&#x2F;value pair to generate intermediate key&#x2F;value pairs.</li>
<li>Reduce: merges all intermediate values associated with the same intermediate key.</li>
</ul>
<p>runtime system responsibility:</p>
<ul>
<li>Partitioning the input data.</li>
<li>Scheduling the program’s execution across a set of machines.</li>
<li>Handling managed failures.</li>
<li>Managing inter-machine communication.</li>
</ul>
<p>Motivation:</p>
<ul>
<li>Special purpose coding on distributed systems is hard.</li>
<li>Hide the messy details of parallelization, fault-tolerance, data distribution and load balancing.</li>
</ul>
<h1 id="Programming-Model"><a href="#Programming-Model" class="headerlink" title="Programming Model"></a>Programming Model</h1><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>map and reduce functions are deterministic functions: always get the same output with same input.</p>
<p>map: (k1, v1) –&gt; list(k2, v2)</p>
<p>reduce: (k2, list(v2)) –&gt; list(v3)</p>
<p>Input keys and values are drawn from different domain than the output keys and values. But intermediate keys and values are from the same domain. </p>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>Distributed Grep</p>
</li>
<li><p>Count of URL Access Frequency</p>
</li>
<li><p>Reverse Web-Link Graph: The map function outputs $&lt;target, source&gt;$ pairs for each link to a target URL found in a page named source. The reduce function concatenates the list of all source URLs associated with a given target URL and emits the pair $&lt;target, list(source)&gt;$</p>
</li>
<li><p>Term-Vector per Host</p>
</li>
<li><p>Inverted Index: The map function parses each document, and emits a sequence of $&lt;word, document ID&gt;$ pairs. The reduce function accepts all pairs for a given word, sorts the corresponding document IDs and emits a $&lt;word, list(document ID)&gt;$ pair. The set of all output pairs forms a simple inverted index. It is easy to augment this computation to keep track of word positions.</p>
</li>
<li><p>Distributed Sort: The map function extracts the key from each record, and emits a $&lt;key, record&gt;$ pair. The reduce function emits all pairs unchanged. This computation depends on the partitioning facilities described in Section 4.1 and the ordering properties described in Section 4.2. (TODO)</p>
</li>
</ul>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>Implementation environment:</p>
<ul>
<li>Commodity computers are used.</li>
<li>Network (switched Ethernet) is the bottleneck.</li>
<li>Cluster of computers, thus <strong>machine failures are common</strong>.</li>
<li>Storage hardware is inexpensive; using a distributed file system (GFS) to manage data; replication is used.</li>
<li>Users submit jobs to a scheduling system. Each <strong>job</strong> consists of <strong>a set of tasks</strong>, and is <strong>mapped by the scheduler</strong> to a set of available machines within a cluster.</li>
</ul>
<h2 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h2><p><img src="D:\Blog\source_images\image-20221217145110248.png" alt="image-20221217145110248"></p>
<p>What happens when user call MapReduce:</p>
<ol>
<li>The MapReduce library first split input files into M pieces of typically 16 to 64 MB per pieces. It then starts up many copies of the user program on a cluster of machines.</li>
<li>The copied program on master is special. The rest are workers that are assigned work by the master. There are M map tasks and R reduce tasks to assign. The master picks idle workers and assigns each one a map task or a reduce task.</li>
<li>A worker who is assigned a map task reads the input split, and use user-defined map function to process the split. The <strong>intermediate keys and values are buffered in the memory</strong>.</li>
<li><strong>Periodically, the buffered pairs are written to disk</strong>, partitioned into R regions by partition function i.e. $hash(key)%R$. The locations of these buffered pairs on the local disk are passed back to the master, who is responsible for forwarding these locations to the reduce workers.</li>
<li>When a reducer worker is notified by master about the locations, it then uses remote procedure call (RPC) to remotely reads the intermediate keys and values from the map worker’s local disks.</li>
<li>When a reduce worker has read all intermediate data, it sorts it by the intermediate keys so that all occurrences of the same key are grouped together. The <em><strong>sorting is needed because typically many different keys map to the same reduce task</strong></em>. If the amount of intermediate data is too large to fit in memory, an <strong>external sort</strong> (i.e. external merge sort) is used.</li>
<li>The reduce worker iterate the sorted intermediate data, for each unique intermediate key encountered, it passed the key and the corresponding list of intermediate values to user’s reduce function. The output of Reduce function is appended to a final output file for this reduce partition.</li>
<li>When all map tasks and reduce tasks had been done, the master wakeup the user program.</li>
<li>After successful completion, the output is available in R output files. They can be used as input of another MapReduce call.</li>
</ol>
<h2 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h2><p>For each map task and reduce task, it stores:</p>
<ul>
<li>The state (idle, in-progress, or completed)</li>
<li>The identity of the worker machine (for non-idle tasks).</li>
</ul>
<p>master is like a conduit:</p>
<ul>
<li>it propagate the location of R regions on map tasks to reduce tasks</li>
<li>Therefore, for each completed map tasks, the master stores the locations and sizes of R regions.</li>
<li>Updates to this location and size information are received as map tasks are completed. The information is pushed incrementally to workers that have in-progress reduce tasks</li>
</ul>
<h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><h3 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h3><p>How to determine failure of worker?</p>
<ul>
<li>The master pings every worker periodically. If no response is received from a worker in a certain amount of time, the master marks the worker as failed.</li>
</ul>
<p>Which tasks to rollback when workers failed?</p>
<ul>
<li>Any map tasks completed by the failed worker are reset back to their initial idle state, and therefore become eligible for scheduling on other workers. </li>
<li>Similarly, any map task or reduce task in progress on a failed (map or reduce separately) worker is also reset to idle and becomes eligible for rescheduling.</li>
</ul>
<p> Why completed map tasks on failed worker should re-execute while completed reduce tasks don’t?</p>
<ul>
<li>Completed map tasks are re-executed on a failure because their <em>output is stored on the local disk(s)</em> of the failed machine and is therefore <strong>inaccessible</strong>. </li>
<li>Completed reduce tasks do not need to be re-executed since <strong>their output is stored in a global file system</strong>.</li>
</ul>
<p>What happens if map tasks are re-executed?</p>
<ul>
<li>When a map task is executed first by worker A and then later executed by worker B (because A failed), all workers executing reduce tasks are notified of the re-execution. Any reduce task that has not already read the data from worker A will read the data from worker B.</li>
</ul>
<h3 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h3><p>Can be solved with periodic checkpoints of master data structure.</p>
<p>But since there is only one master, it’s unlikely to fail.</p>
<p>So when master fails, we can just abort the computation.</p>
<h3 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h3><p>When user-supplied map and reduce functions are deterministic:</p>
<ul>
<li>MapReduce will produce the same output as non-faulting sequential execution of program.</li>
<li>That property relies on <em><strong>atomic commit</strong></em> of map and reduce tasks.<ul>
<li>For map tasks: when a map task completes, the worker sends a message to the master and includes the names of the R temporary files in the message. <em>If the master receives a completion message for an already completed map task, it ignores the message. Otherwise, it records the names of R files in a master data structure</em>.</li>
<li>For reduce tasks: when a reduce task completes, the <em>reduce worker atomically renames its temporary output file to the final output file</em>. If the same reduce task is executed on multiple machines, multiple rename calls will be executed for the same final output file. We rely on the atomic rename operation provided by the underlying file system to guarantee that the final file system state contains just the data produced by one execution of the reduce task.</li>
</ul>
</li>
</ul>
<p>When user-supplied map and reduce functions are non-deterministic:</p>
<ul>
<li>MapReduce will provide weaker but still reasonable semantics.</li>
<li>In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program. However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.</li>
<li>Consider map task M and reduce tasks $R_1$ and $R_2$. Let $e(R_i)$ be the execution of $R_i$ that committed (there is exactly one such execution). The weaker semantics arise because $e(R_1)$ may have read the output produced by one execution of M and $e(R_2)$ may have read the output produced by a different execution of M.</li>
</ul>
<h2 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h2><p>Since network bandwidth is the bottleneck, one optimization is that running GFS and MapReduce on the same set of machines. And master schedule map tasks to read input locally as possible.</p>
<h2 id="Task-Granularity"><a href="#Task-Granularity" class="headerlink" title="Task Granularity"></a>Task Granularity</h2><p>Ideally M and R should be much larger than number of workers</p>
<ul>
<li>Improves load balancing</li>
<li>Speeds up recovery</li>
</ul>
<p>Practical bounds of M and R:</p>
<ul>
<li>master must take $O(M+R)$ to do scheduling, and take $O(M*R)$ piece of state.</li>
<li>R is also constrained by users because the output of each reduce task ends up in a separate output file.</li>
<li>R is often a small multiple of the number of worker machines we expect to use.</li>
</ul>
<h2 id="Backup-Tasks"><a href="#Backup-Tasks" class="headerlink" title="Backup Tasks"></a>Backup Tasks</h2><p>What is a straggler?</p>
<ul>
<li>straggler is the machine that takes an unusually long time to compute the tasks, it’s often the bottleneck.</li>
</ul>
<p> Backup mechanism to deal with straggler</p>
<ul>
<li>When a <strong>MapReduce operation is close to completion</strong>, the master <strong>schedules backup executions of the remaining in-progress tasks</strong>.</li>
<li>The task is marked as completed whenever either the primary or the backup execution completes.</li>
</ul>
<h1 id="Refinement"><a href="#Refinement" class="headerlink" title="Refinement"></a>Refinement</h1><h2 id="Partition-Function"><a href="#Partition-Function" class="headerlink" title="Partition Function"></a>Partition Function</h2><p>Default partition function: $hash(key)%R$, this tends to generate well-balanced partitions.</p>
<p>But sometimes input are skewed, we need some special partition functions.</p>
<p>For example, when output keys are URLs, and we want all entries for a single host to end up in the same output file. We can then use $hash(Hostname(url))$.</p>
<h2 id="Ordering-Guarantees"><a href="#Ordering-Guarantees" class="headerlink" title="Ordering Guarantees"></a>Ordering Guarantees</h2><p>Within a given partition, the intermediate key&#x2F;value pairs are processed in increasing key order (because it is sorted by reduce). </p>
<p>This ordering makes it easy to <em><strong>generate a sorted output file per partition</strong></em>, which is useful when the output file format needs to support efficient <strong>random access lookups by key</strong> (hash + binary search, similar to hash join algorithm in database)</p>
<h2 id="Combiner-Functions"><a href="#Combiner-Functions" class="headerlink" title="Combiner Functions"></a>Combiner Functions</h2><p>Combiner functions is like a reduce function but runs on map workers.</p>
<p>It can reduce the network overhead by pre-processing (aggregating) the keys and values.</p>
<p>For some kind of tasks, it’s very useful.</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="Input-and-Output-Formats"><a href="#Input-and-Output-Formats" class="headerlink" title="Input and Output Formats"></a>Input and Output Formats</h3><p>Text mode: treat each line as key&#x2F;value pair</p>
<ul>
<li>key: offset in the file</li>
<li>value: content of the line</li>
</ul>
<p>Reader mode: user provide reader interface to split the range.</p>
<h3 id="Side-effects"><a href="#Side-effects" class="headerlink" title="Side effects"></a>Side effects</h3><p>It is useful to generate auxiliary files in map or reduce tasks, MapReduce don’t provide two-phase commit. Therefore, tasks that produce multiple output files with cross-file consistency requirements should be deterministic.</p>
<h3 id="Skipping-Bad-Records"><a href="#Skipping-Bad-Records" class="headerlink" title="Skipping Bad Records"></a>Skipping Bad Records</h3><p>Sometimes it is feasible to ignore some bad records caused by user program, for example doing a statistic analysis on a large dataset.</p>
<p>MapReduce provide some mode to detect records that caused deterministic crashes and skip these records.</p>
<h3 id="Local-Execution"><a href="#Local-Execution" class="headerlink" title="Local Execution"></a>Local Execution</h3><p>Debugging MapReduce is triky, so MapReduce provide tools of debugging, profiling, and small-scale testing, enabling sequentially execute all of the work for a MapReduce operation on the local machine.  </p>
<h3 id="Status-Information"><a href="#Status-Information" class="headerlink" title="Status Information"></a>Status Information</h3><p>The master runs an internal HTTP server and exports a set of status pages for human consumption. </p>
<h3 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h3><p>The MapReduce library provides a counter facility to count occurrences of various events. </p>
<p>To use this facility, <em>user code creates a named counter object</em> and then <em>increments the counter appropriately in the Map and&#x2F;or Reduce function</em>. For example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Counter *uppercase;</span><br><span class="line">uppercase = <span class="built_in">GetCounter</span>(<span class="string">&quot;uppercase&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(String name, String contents) &#123;</span><br><span class="line">    <span class="keyword">for</span> (w : contents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isCapitalized</span>(w)) &#123;</span><br><span class="line">            uppercase-&gt;<span class="built_in">Increment</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">EmitIntermediate</span>(w, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The counter values from individual worker machines are periodically propagated to the master (<em>piggybacked</em> on the ping response). </p>
<p>The master aggregates the counter values from successful map and reduce tasks and returns them to the user code when the MapReduce operation is completed. </p>
<p>The current counter values are also dis- played on the master status page so that a human can watch the progress of the live computation. </p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Success of MapReduce</p>
<ol>
<li>Model is easy to use, it hides parallelism, load balance, locality, fault tolerance, etc.</li>
<li>Model is expressive, can be used to solve many problems.</li>
<li>It has scalability, fault tolerance, consistency.</li>
</ol>
<p>Some takeaways</p>
<ol>
<li>Restricting programming model makes it easy for parallelism and fault tolerance.</li>
<li>Network bandwidth is scarce resource. (locality optimization).</li>
<li>Redundant execution can be used to reduce the impact of slow machines.</li>
</ol>
]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Concurrency</title>
    <url>/2022/12/15/Go-Concurrency/</url>
    <content><![CDATA[<blockquote>
<p>Materials:</p>
<ul>
<li><a href="https://vimeo.com/49718712">concurrency is not parallelism</a></li>
<li><a href="https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view">rethinking classical concurrency patterns</a></li>
<li><a href="https://pkg.go.dev/sync#pkg-overview">go sync package</a></li>
<li><a href="https://go.dev/talks/2012/concurrency.slide#1">go concurrency patterns</a></li>
<li><a href="https://blogtitle.github.io/categories/concurrency/">go advanced concurrency patterns</a></li>
</ul>
</blockquote>
<h1 id="Concurrency-Overview"><a href="#Concurrency-Overview" class="headerlink" title="Concurrency Overview"></a>Concurrency Overview</h1><p>Why concurrency?</p>
<ul>
<li>I&#x2F;O concurrency (network capacity, disk capacity)</li>
<li>Parallelism (multi-core machine)</li>
<li>Convenience (periodic work)</li>
</ul>
<p>Distinctions between concurrency and parallelism?</p>
<ul>
<li>Parallelism: simultaneous executing of programs, which may be correlated, or not be.</li>
<li>Concurrency:  composition of independent executing programs. <em>it’s not same as parallelism, although it enables parallelism</em>!</li>
</ul>
<p>Essence of concurrency:</p>
<ul>
<li>A complex problem can be broken down into several easy-to-understand components.</li>
<li>The pieces can be composed concurrently.</li>
<li>The result is <strong>scalable, correct and maybe parallel</strong>.</li>
</ul>
<h1 id="Go-Concurrency-Features"><a href="#Go-Concurrency-Features" class="headerlink" title="Go Concurrency Features"></a>Go Concurrency Features</h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>Goroutines</p>
<ul>
<li>It’s independently executing program with its own stack which can shrink and grow automatically</li>
<li>Goroutines are multiplexed dynamically onto threads as needed</li>
</ul>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>Communicating in go?</p>
<ul>
<li>Communicating in golang is through channels, it’s more like via file descriptor;</li>
<li>While in original CSP (Communicating Sequential Processing) is through process name, it’s more like via file</li>
</ul>
<p>Synchronization and Communication:</p>
<ul>
<li>Both send and receive are synchronous</li>
<li>A sender and receiver must both be ready to play their part in the communication. Otherwise we wait until they are.</li>
<li>Thus <strong>channels both communicate and synchronize</strong>.</li>
</ul>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>Buffered channels remove synchronization</p>
<p>It seems like Erlang’s mailbox</p>
<h2 id="The-Go-Approach"><a href="#The-Go-Approach" class="headerlink" title="The Go Approach"></a>The Go Approach</h2><p>Principle: <strong>Don’t communicate by sharing memory (i.e. mutex, locks), share memory by communicating.</strong></p>
<p>Low level concurrency: lock, mutex, condition, waitgroup, pool.</p>
<p>high level concurrency: goroutine, channel.</p>
<p><strong>garbage collector, closure, channel, goroutine, select</strong> – these features just stitch together to make concurrency in go powerful and expressive.</p>
<h1 id="Go-Concurrency-Patterns"><a href="#Go-Concurrency-Patterns" class="headerlink" title="Go Concurrency Patterns"></a>Go Concurrency Patterns</h1><h2 id="Generator-Function-Returns-a-Channel"><a href="#Generator-Function-Returns-a-Channel" class="headerlink" title="Generator : Function Returns a Channel"></a>Generator : Function Returns a Channel</h2><h3 id="Normal-Generator-Model"><a href="#Normal-Generator-Model" class="headerlink" title="Normal Generator Model"></a>Normal Generator Model</h3><p>Channels are first-class values (so as functions).</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := boring(<span class="string">&quot;boring!&quot;</span>) <span class="comment">// Function returning a channel.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;You say: %q\n&quot;</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;You&#x27;re boring; I&#x27;m leaving.&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span><span class="params">(msg <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123; <span class="comment">// Returns receive-only channel of strings.</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// We launch the goroutine from inside the function.</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">            c &lt;- fmt.Sprintf(<span class="string">&quot;%s %d&quot;</span>, msg, i)</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c <span class="comment">// Return the channel to the caller.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channels-as-a-Handle-on-a-Service"><a href="#Channels-as-a-Handle-on-a-Service" class="headerlink" title="Channels as a Handle on a Service"></a>Channels as a Handle on a Service</h3><p>Our boring function above returns a channel that lets us communicate with the boring service it provides.</p>
<p>We can have more instances of the service.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    joe := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    ann := boring(<span class="string">&quot;Ann&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(&lt;-joe)</span><br><span class="line">        fmt.Println(&lt;-ann)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Multiplexing-Fan-In"><a href="#Multiplexing-Fan-In" class="headerlink" title="Multiplexing (Fan-In)"></a>Multiplexing (Fan-In)</h3><p>These programs make Joe and Ann count in lockstep.  </p>
<p>We can instead use a fan-in function to let whosoever is ready talk.</p>
<p>It uses multi-channels as input and output a channel that receive multi channels’ output in different goroutines.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(input1, input2 &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; c &lt;- &lt;-input1 &#125; &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; c &lt;- &lt;-input2 &#125; &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := fanIn(boring(<span class="string">&quot;Joe&quot;</span>), boring(<span class="string">&quot;Ann&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(&lt;-c)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">input1 --&gt; channel1 --&gt; channel3</span><br><span class="line">input2 --&gt; channel2 --&gt; channel3</span><br><span class="line">channel3 --&gt; output</span><br></pre></td></tr></table></figure>

<h3 id="Restoring-Sequencing"><a href="#Restoring-Sequencing" class="headerlink" title="Restoring Sequencing"></a>Restoring Sequencing</h3><p>Fan-In is useful, but sometimes we want restoring the sequencing of two services.</p>
<p>Idea is <strong>sending a channel on a channel, making goroutines wait its turn</strong></p>
<p>So, first we define a struct that contains a channel for the reply</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    str <span class="type">string</span></span><br><span class="line">    wait <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For receiver who receives message:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    msg1 := &lt;-c</span><br><span class="line">    fmt.Println(msg1)</span><br><span class="line">    msg2 := &lt;-c</span><br><span class="line">    fmt.Println(msg2)</span><br><span class="line">    msg1.wait &lt;- <span class="literal">true</span>	<span class="comment">// unlock the sender which is stalled on &lt;-WaitForIt</span></span><br><span class="line">    msg2.wait &lt;- <span class="literal">true</span>	<span class="comment">// unlock the sender which is stalled on &lt;-WaitForIt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For Sender who sends message:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">WaitForIt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> ExistUnsentMessage() &#123;</span><br><span class="line">    c &lt;- message&#123;<span class="string">&quot;message&quot;</span>, WaitForIt&#125;</span><br><span class="line">    time.Sleep(time.Duration(rand.Intn(<span class="number">2e3</span>)) * time.Millisecond)</span><br><span class="line">    &lt;-WaitForIt		<span class="comment">// get stalled when </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The technique above can restore the sequence of message: for the fact that Sender cannot send message twice to channel <code>c</code> because it will get stalled in <code>&lt;-WaitForIt</code> statement</p>
<blockquote>
<p>Assume sender1 sends on msg1, then it will get stalled on <code>&lt;-WaitForIt</code>, sender2 then can send on msg2, and also get stalled on <code>&lt;-WaitForIt</code>, and because sender1 sent first, so sender1 get stalled on <code>c &lt;- message&#123;...&#125;</code> first, so msg1 is still sender1</p>
</blockquote>
<blockquote>
<p> Assume sender1 sends on msg2, then sender2 sends on msg1, so the same situation as above  </p>
</blockquote>
<h2 id="Select-Statement"><a href="#Select-Statement" class="headerlink" title="Select Statement"></a>Select Statement</h2><h3 id="Fan-In-Using-Select"><a href="#Fan-In-Using-Select" class="headerlink" title="Fan-In Using Select"></a>Fan-In Using Select</h3><p>By using select statement, we only need to start one goroutine to fan-in channels.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(input1, input2 &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input1:  c &lt;- s</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input2:  c &lt;- s</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Timeout-Using-Select"><a href="#Timeout-Using-Select" class="headerlink" title="Timeout Using Select"></a>Timeout Using Select</h3><p>The time.After function returns a channel that blocks for the specified duration.<br>After the interval, the channel delivers the current time, once.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">            fmt.Println(<span class="string">&quot;You&#x27;re too slow.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Timeout-for-Whole-Conversation-Using-Select"><a href="#Timeout-for-Whole-Conversation-Using-Select" class="headerlink" title="Timeout for Whole Conversation Using Select"></a>Timeout for Whole Conversation Using Select</h3><p>Create the timer once, outside the loop, to time out the entire conversation.<br>While in the previous program, we had a timeout for each message.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    timeout := time.After(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">            fmt.Println(<span class="string">&quot;You talk too much.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Receive-on-quit-channel"><a href="#Receive-on-quit-channel" class="headerlink" title="Receive on quit channel"></a>Receive on quit channel</h3><p>When it want to quit a goroutine, send message on quit channel</p>
<p><code>case &lt;-quit</code> will do cleanup (like remove a temporary file), and tell back that it had quit (<strong>round-trip quit, in case that main goroutine quit before cleanup had been done</strong>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">c := boring(<span class="string">&quot;Joe&quot;</span>, quit)</span><br><span class="line"><span class="keyword">for</span> i := rand.Intn(<span class="number">10</span>); i &gt;= <span class="number">0</span>; i-- &#123; fmt.Println(&lt;-c) &#125;</span><br><span class="line">quit &lt;- <span class="string">&quot;Bye!&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Joe says: %q\n&quot;</span>, &lt;-quit)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- fmt.Sprintf(<span class="string">&quot;%s: %d&quot;</span>, msg, i):</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">    cleanup()</span><br><span class="line">    quit &lt;- <span class="string">&quot;See you!&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Daisy-Chain"><a href="#Daisy-Chain" class="headerlink" title="Daisy Chain"></a>Daisy Chain</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	routine1 --&gt; routine2 --left channel--&gt; routine3 --right channel--&gt; routine4 --&gt; routine5 --&gt; routine...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(left, right <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    left &lt;- <span class="number">1</span> + &lt;-right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="number">10000</span></span><br><span class="line">    leftmost := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    right := leftmost</span><br><span class="line">    left := leftmost</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        right = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> f(left, right)</span><br><span class="line">        left = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123; c &lt;- <span class="number">1</span> &#125;(right)</span><br><span class="line">    fmt.Println(&lt;-leftmost)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Rethinking-Classical-Concurrent-Patterns"><a href="#Rethinking-Classical-Concurrent-Patterns" class="headerlink" title="Rethinking Classical Concurrent Patterns"></a>Rethinking Classical Concurrent Patterns</h1><p>Two principles in go:</p>
<ol>
<li>Start goroutines when you have concurrent work</li>
<li>Share by communicating</li>
</ol>
<p>Other principles in go:</p>
<ol>
<li>Make concurrency internal detail.</li>
<li>Add concurrency on the caller side of the API.</li>
<li>Concurrency is not asynchronicity.</li>
</ol>
<h2 id="Asynchronous-API"><a href="#Asynchronous-API" class="headerlink" title="Asynchronous API"></a>Asynchronous API</h2><p>Concurrency is not asynchronicity.</p>
<p>An asynchronous API returns to the caller <strong>before its result is ready</strong>.</p>
<p>An asynchronous program is not necessarily concurrent: a program could call an asynchronous function and then sit idle waiting for the results.</p>
<p>There are several asynchronous patterns:</p>
<ul>
<li>asynchronous callback (deprecated)</li>
<li>future</li>
<li>producer-consumer queue</li>
</ul>
<h3 id="Asynchronous-Callback"><a href="#Asynchronous-Callback" class="headerlink" title="Asynchronous Callback"></a>Asynchronous Callback</h3><p>A callback is a simple function that’s passed as a value to another function, and will only be executed when the event happens.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetch immediately returns, then fetches the item and </span></span><br><span class="line"><span class="comment">// invokes f in a goroutine when the item is available. </span></span><br><span class="line"><span class="comment">// If the item does not exist,</span></span><br><span class="line"><span class="comment">// Fetch invokes f on the zero Item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>, f <span class="keyword">func</span>(Item)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        […]</span><br><span class="line">        f(item)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>In the Future pattern, instead of returning the result, the function returns a proxy object that allows the caller to wait for the result at some later point.</p>
<p>The Go analogue to a <strong>Future</strong> is a <strong>single-element buffered channel</strong>.</p>
<p>To use Futures for concurrency, the caller must <strong>set up concurrent work before retrieving results</strong>.</p>
<p>If they retrieve the results too early, the program executes <em>sequentially instead of concurrently</em>.</p>
<p>the channel pattern seems to be more common than the function-based alternative</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: API, channel-based</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch immediately returns a channel, then fetches </span></span><br><span class="line"><span class="comment">// the requested item and sends it on the channel. </span></span><br><span class="line"><span class="comment">// If the item does not exist,</span></span><br><span class="line"><span class="comment">// Fetch closes the channel without sending.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        […]</span><br><span class="line">        c &lt;- item</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: The precise way, function-based</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">()</span></span> Item) &#123;</span><br><span class="line">    item := <span class="built_in">new</span>(Item)</span><br><span class="line">    ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    […]</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> Item &#123;</span><br><span class="line">        &lt;-ready</span><br><span class="line">        <span class="keyword">return</span> *item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: caller side</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Right</span></span><br><span class="line">a := Fetch(<span class="string">&quot;a&quot;</span>) </span><br><span class="line">b := Fetch(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">consume(&lt;-a, &lt;-b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// False</span></span><br><span class="line">a := &lt;-Fetch(<span class="string">&quot;a&quot;</span>) <span class="comment">// routine get stalled on this line, so will lose concurrency</span></span><br><span class="line">b := &lt;-Fetch(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">consume(a, b)</span><br></pre></td></tr></table></figure>

<h3 id="Producer–Consumer-Queue"><a href="#Producer–Consumer-Queue" class="headerlink" title="Producer–Consumer Queue"></a>Producer–Consumer Queue</h3><p>A producer–consumer queue also returns a channel, but the <strong>channel receives any number of results and is typically unbuffered</strong>.</p>
<p>A channel fed by one goroutine and read by another <strong>acts as a queue</strong>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Glob finds all items with names matching pattern</span></span><br><span class="line"><span class="comment">// and sends them on the returned channel.</span></span><br><span class="line"><span class="comment">// It closes the channel when all items have been sent. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(pattern <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">        <span class="keyword">for</span> […] &#123;</span><br><span class="line">            […]</span><br><span class="line">            c &lt;- item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Producer-Consumer Queue: caller side</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> Glob(<span class="string">&quot;[ab]*&quot;</span>) &#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Analysis-of-Asynchronous-API"><a href="#Analysis-of-Asynchronous-API" class="headerlink" title="Analysis of Asynchronous API"></a>Analysis of Asynchronous API</h3><p>Classical Benefit:</p>
<ul>
<li>Responsiveness : Avoid blocking UI and network threads<ul>
<li>Most other languages don’t multiplex across OS threads, and kernel schedulers can be unpredictable. So some popular languages and frameworks keep all of the UI or network logic on a single thread. If that thread makes a call that blocks for too long, the UI becomes choppy, or network latency spikes.</li>
<li>Since calls to asynchronous APIs by definition don’t block, they help to keep single-threaded programs responsive.</li>
<li>For go, goroutines are managed by go-runtime, not by kernel scheduler, so the first benefit doesn’t apply to go.</li>
</ul>
</li>
<li>Efficiency : Reduce  idle threads<ul>
<li>Threads are expensive</li>
<li>Languages that don’t multiplex over threads can use asynchronous APIs to keep threads busy, reducing the total number of threads — and context-switches</li>
<li>For go, goroutine is lightweight, it doesn’t spend too much on context switch.</li>
</ul>
</li>
<li>Efficiency : Reclaim stack frames<ul>
<li>Save frame space for other purpose.</li>
<li>For go, runtime resize and reallocate stack as needed. Besides, <strong>the storage location chosen by implementation is irrelevant to the semantics of the language</strong>.</li>
</ul>
</li>
<li>Concurrency : Initiate concurrent work<ul>
<li>Can be important for network RPCs</li>
</ul>
</li>
</ul>
<p>Classical Problems:</p>
<ul>
<li>Caller-Side Ambiguity</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	kind <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = <span class="keyword">map</span>[<span class="type">string</span>]Item&#123;</span><br><span class="line">	<span class="string">&quot;a&quot;</span>: Item&#123;<span class="string">&quot;gopher&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;b&quot;</span>: Item&#123;<span class="string">&quot;rabbit&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSlowThing</span><span class="params">()</span></span> &#123; time.Sleep(<span class="number">10</span> * time.Millisecond) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(a, b Item)</span></span> &#123;</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		item := items[name]</span><br><span class="line">		c &lt;- item</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glob finds all items with names matching pattern</span></span><br><span class="line"><span class="comment">// and sends them on the returned channel.</span></span><br><span class="line"><span class="comment">// It closes the channel when all items have been sent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(pattern <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">		<span class="keyword">for</span> name, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">			<span class="keyword">if</span> ok, _ := filepath.Match(pattern, name); !ok &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			c &lt;- item</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> Glob(<span class="string">&quot;[ab]*&quot;</span>) &#123;</span><br><span class="line">		fmt.Println(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Condition-Variable"><a href="#Condition-Variable" class="headerlink" title="Condition Variable"></a>Condition Variable</h2><h3 id="Condition-Variable-Analysis"><a href="#Condition-Variable-Analysis" class="headerlink" title="Condition Variable Analysis"></a>Condition Variable Analysis</h3><p>Problems:</p>
<ul>
<li>Spurious wakeups: Signal some or the threads are hard.</li>
<li>Forgotten signals: Forget to signal some threads when programming.</li>
<li>Starvation: long-running threads will get starved.</li>
<li>Unresponsive cancellation: While waiting for a condition, it may miss other event.</li>
</ul>
<p>Fundamentally, <strong>condition variables rely on communicating by sharing memory</strong>: they signal that a change has occurred, but leave it up to the signalled goroutine to check other shared variables to figure out what. On the other hand, the <strong>Go approach is to share by communicating</strong>.</p>
<h3 id="Semaphore-Sharing-by-Communicating"><a href="#Semaphore-Sharing-by-Communicating" class="headerlink" title="Semaphore : Sharing by Communicating"></a>Semaphore : Sharing by Communicating</h3><p>Go Benefits:</p>
<ul>
<li>Indicate the existence of new data.</li>
<li>Share data by communicating data.</li>
<li>Share things by communicating things.</li>
<li>Metadata are data too!</li>
<li>Mark transitions: mark that a broadcast by close a channel.</li>
</ul>
<p>Buffered channels –&gt; Semaphore pattern</p>
<h2 id="Worker-Pool"><a href="#Worker-Pool" class="headerlink" title="Worker Pool"></a>Worker Pool</h2><p>Benefits:</p>
<ul>
<li>Distribute work across threads<ul>
<li>Threads are heavyweight, worker pool allow reusing threads</li>
<li>Goroutines are lightweight, so it doesn’t apply to go</li>
</ul>
</li>
<li>Limit work in flight</li>
</ul>
<p>Principles:</p>
<ul>
<li><p>Start your goroutine only when you have concurrent work to do now</p>
</li>
<li><p>WaitGroup is enough –&gt; semaphore patterns</p>
</li>
</ul>
<h1 id="Go-Advanced-Concurrency-Patterns"><a href="#Go-Advanced-Concurrency-Patterns" class="headerlink" title="Go Advanced Concurrency Patterns"></a>Go Advanced Concurrency Patterns</h1><h2 id="Timeout-and-Multi-channels"><a href="#Timeout-and-Multi-channels" class="headerlink" title="Timeout and Multi-channels"></a>Timeout and Multi-channels</h2><h3 id="Timed-Channel-Operations"><a href="#Timed-Channel-Operations" class="headerlink" title="Timed Channel Operations"></a>Timed Channel Operations</h3><p>Keep trying doing something, but drop the ball when timeout</p>
<ul>
<li><code>context</code> implementation (more idiomatic)</li>
<li><code>time</code> implementation</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// context impl.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChanTimedContext</span><span class="params">(ctx context.Context, d time.Duration, message Type, c <span class="keyword">chan</span>&lt;- Type)</span></span> (written <span class="type">bool</span>) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(ctx, d)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// time impl.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChanTimedTimer</span><span class="params">(d time.Duration, message Type, c <span class="keyword">chan</span>&lt;- Type)</span></span> (written <span class="type">bool</span>) &#123;</span><br><span class="line">	t := time.NewTimer(d)</span><br><span class="line">	<span class="keyword">defer</span> t.Stop()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="First-in-First-Served"><a href="#First-in-First-Served" class="headerlink" title="First in First Served"></a>First in First Served</h3><p>Sometimes you want to write the same message to many channels, writing to whichever is available first, but <strong>never writing the same message twice</strong> on the same channel.</p>
<ul>
<li>Use <code>select</code> statement to achieve so.</li>
<li>Use goroutines and waits</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// select statement</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServeSelect</span><span class="params">(message Type, a, b <span class="keyword">chan</span> Type)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> a &lt;- message:</span><br><span class="line">            a = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> b &lt;- message:</span><br><span class="line">            b = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// goroutine</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServeGoroutine</span><span class="params">(message Type, a, b <span class="keyword">chan</span> Type)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a &lt;- message; wg.Done() &#125; ()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; b &lt;- message; wg.Done() &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this case performance might matter, and at the time of writing the solution that spawns goroutines takes almost 4 times more than the one with <code>select</code>.</p>
<p>If the amount of channels is not known at compile time, the first solution becomes trickier, but it is still possible, while the second one stays basically unchanged.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServedGoroutinesVariadic</span><span class="params">(message Type, chs ...<span class="keyword">chan</span>&lt;- Type)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(chs))</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> chs &#123;</span><br><span class="line">		c := c</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- message; wg.Done() &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServedSelectVariadic</span><span class="params">(message Type, chs ...<span class="keyword">chan</span>&lt;- Type)</span></span> &#123;</span><br><span class="line">	cases := <span class="built_in">make</span>([]reflect.SelectCase, <span class="built_in">len</span>(chs))</span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> chs &#123;</span><br><span class="line">		cases[i] = reflect.SelectCase&#123;</span><br><span class="line">			Dir:  reflect.SelectSend,</span><br><span class="line">			Chan: reflect.ValueOf(ch),</span><br><span class="line">			Send: reflect.ValueOf(message),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(chs); i++ &#123;</span><br><span class="line">		chosen, _, _ := reflect.Select(cases)</span><br><span class="line">		cases[chosen].Chan = reflect.ValueOf(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The solution using reflection is almost two orders of magnitude slower than the one with goroutines and unreadable.</p>
<h3 id="First-in-First-Serve-with-Timeout"><a href="#First-in-First-Serve-with-Timeout" class="headerlink" title="First in First Serve with Timeout"></a>First in First Serve with Timeout</h3><p>There are two solutions in case you want to try a several sends and abort if it takes too long.</p>
<ul>
<li><code>time + select</code> : better if account of channels are known at compile time.</li>
<li><code>context + go</code> : channels are unknown at compile time.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// time + select</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChansTimedTimerSelect</span><span class="params">(d time.Duration, message Type, a, b <span class="keyword">chan</span> Type)</span></span> (written <span class="type">int</span>) &#123;</span><br><span class="line">	t := time.NewTimer(d)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> a &lt;- message:</span><br><span class="line">			a = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> b &lt;- message:</span><br><span class="line">			b = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t.Stop()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// context + go</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChansTimedContextGoroutines</span><span class="params">(ctx context.Context, d time.Duration, message Type, ch ...<span class="keyword">chan</span> Type)</span></span> (written <span class="type">int</span>) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(ctx, d)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		wr <span class="type">int32</span></span><br><span class="line">		wg sync.WaitGroup</span><br><span class="line">	)</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(ch))</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		c := c</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">				atomic.AddInt32(&amp;wr, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(wr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><h3 id="time-Ticker"><a href="#time-Ticker" class="headerlink" title="time.Ticker"></a>time.Ticker</h3><p>NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. </p>
<p>The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. </p>
<p>Stop the ticker to release associated resources.</p>
<p>Some caveats:</p>
<ul>
<li><strong>Sends will drop all unread values if <code>C</code> already has one message in it</strong>.</li>
<li>It <strong>must be stopped</strong>: the GC will not collect it otherwise.</li>
<li>Setting <code>C</code> is useless: <strong>messages will still be sent on the original channel</strong>.</li>
</ul>
<h3 id="time-Tick"><a href="#time-Tick" class="headerlink" title="time.Tick"></a>time.Tick</h3><p>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only.</p>
<p>But this is something that should never be used unless you plan to carry the returned <code>chan</code> around and keep using it for the <strong>entire lifetime of the program</strong>.</p>
<p><strong>Because the underlying Ticker cannot be recovered by the garbage collector; it “leaks”</strong>.</p>
<h3 id="time-Timer"><a href="#time-Timer" class="headerlink" title="time.Timer"></a>time.Timer</h3><p>The Timer type represents a single event. <em>When the Timer expires, the current time will be sent on C</em>, unless the Timer was created by AfterFunc. <em><strong>A Timer must be created with NewTimer or AfterFunc</strong></em>.</p>
<p><code>Reset</code> changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.</p>
<p><em><strong>For a Timer created with NewTimer, Reset should be invoked only on stopped or expired timers with drained channels</strong></em>.</p>
<p>Some caveat:</p>
<ul>
<li><code>C</code> cannot be set by user although it is exported.</li>
<li><code>Timer</code> returned by <code>AfterFunc</code> doesn’t use <code>C</code> at all.</li>
<li><code>C</code> will not be closed even after Stop the Timer</li>
<li><code>Stop</code> is safe only after <code>New</code> and <code>Reset</code>.</li>
<li><code>Reset</code> is only valid after <code>Stop</code>.</li>
<li>Received value is valid only if channel is drained after each <code>Stop</code>.</li>
<li>The channel should be drained if and only if the channel has not been read yet.</li>
</ul>
<p><code>time.Afterfunc</code>:</p>
<ul>
<li>AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that <strong>can be used to cancel the call using its Stop method</strong>.</li>
<li>when calling <code>Stop</code>, if <code>false</code> is returned, it means that stopping failed and the function was already started.</li>
</ul>
<p><code>time.NewTimer</code>:</p>
<ul>
<li><p>NewTimer creates a new Timer that will send the current time on its channel after at least duration d.</p>
</li>
<li><p>This means that there is no way to construct a valid <code>Timer</code> without starting it. If you need to construct one for future re-use, you either do it lazily or you have to create and stop it, which can be done with this code:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.NewTimer(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> !t.Stop() &#123;</span><br><span class="line">	&lt;-t.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>time.Stop</code>:</p>
<ul>
<li><p>Stop prevents the Timer from firing. It returns <strong>true</strong> if the <strong>call stops the timer</strong>, <strong>false</strong> if the timer has <em><strong>already expired</strong></em> <strong>or</strong> <em><strong>been stopped</strong></em>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//* not thread safe</span></span><br><span class="line"><span class="keyword">if</span> !t.Stop() &#123;</span><br><span class="line">	&lt;-t.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>time.Reset</code>:</p>
<ul>
<li>Note that it is not possible to use Reset’s return value correctly, as there is a race condition between draining the channel and the new timer expiring. <strong>Reset should always be invoked on stopped or expired channels</strong>.</li>
<li>You cannot use <code>Stop</code> nor <code>Reset</code> concurrently <em>with other receives from the channel</em>, and in order for the value sent on <code>C</code> to be valid, <strong><code>C</code> should be drained exactly once before each <code>Reset</code></strong>.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Timer API</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">	C &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span></span>) *Timer</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span></span> *Timer</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Timer)</span></span> Stop(<span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Timer)</span></span> Reset(d Duration) <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_images\image-20221216234927956.png" alt="image-20221216234927956"></p>
<h3 id="time-After"><a href="#time-After" class="headerlink" title="time.After"></a>time.After</h3><p>This is basically the same concept of <code>Tick</code> but instead of hiding a <code>Ticker</code>, hides a <code>Timer</code>. This is slightly better because once the timer will fire, it will be collected. Please note that timers use 1-buffered channels, so they can fire even if no one is receiving.</p>
<p>But if you care about performance and you want to be able to cancel the call, you should not use <code>After</code>.</p>
<h2 id="Some-Tricks"><a href="#Some-Tricks" class="headerlink" title="Some Tricks"></a>Some Tricks</h2><ul>
<li>For-select loop</li>
<li>Service channel, reply channels (channel of channel)</li>
<li><code>nil</code> channel for select cases</li>
</ul>
<h1 id="Example-Search-Engine"><a href="#Example-Search-Engine" class="headerlink" title="Example : Search Engine"></a>Example : Search Engine</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	res <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Search <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FakeSearch</span><span class="params">(kind <span class="type">string</span>)</span></span> Search &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line">		<span class="keyword">return</span> Result&#123;fmt.Sprintf(<span class="string">&quot;%v returns %v&quot;</span>, kind, query)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	Web    = FakeSearch(<span class="string">&quot;Web&quot;</span>)</span><br><span class="line">	Image  = FakeSearch(<span class="string">&quot;Image&quot;</span>)</span><br><span class="line">	Video  = FakeSearch(<span class="string">&quot;Video&quot;</span>)</span><br><span class="line">	Web1   = FakeSearch(<span class="string">&quot;Web&quot;</span>)</span><br><span class="line">	Image1 = FakeSearch(<span class="string">&quot;Image&quot;</span>)</span><br><span class="line">	Video1 = FakeSearch(<span class="string">&quot;Video&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Generator</span><span class="params">(query <span class="type">string</span>)</span></span> <span class="keyword">chan</span> Result &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Web(query) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Image(query) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Video(query) &#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">timeout edition of google search engine</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoogleTimeout</span><span class="params">(query <span class="type">string</span>)</span></span> []Result &#123;</span><br><span class="line">	results := <span class="built_in">make</span>([]Result, <span class="number">0</span>)</span><br><span class="line">	ch := Generator(query)</span><br><span class="line">	timeout := time.After(<span class="number">80</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">			results = <span class="built_in">append</span>(results, res)</span><br><span class="line">			fmt.Println(res)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">			<span class="keyword">return</span> results</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchWithReplicas</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">for</span> _, search := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(search <span class="keyword">func</span>(query <span class="type">string</span>)</span></span> Result) &#123;</span><br><span class="line">			ch &lt;- search(query)</span><br><span class="line">		&#125;(search)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Google</span><span class="params">(query <span class="type">string</span>)</span></span> []Result &#123;</span><br><span class="line">	<span class="keyword">var</span> results []Result</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Web, Web1) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Image, Image1) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Video, Video1) &#125;()</span><br><span class="line">	timeout := time.After(time.Duration(<span class="number">80</span>) * time.Millisecond)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">			results = <span class="built_in">append</span>(results, res)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">			<span class="comment">// return results</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	start := time.Now()</span><br><span class="line">	results := Google(<span class="string">&quot;who are you?&quot;</span>)</span><br><span class="line">	elapsed := time.Since(start)</span><br><span class="line">	fmt.Println(elapsed)</span><br><span class="line">	fmt.Println(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Example-Load-Balancer"><a href="#Example-Load-Balancer" class="headerlink" title="Example : Load Balancer"></a>Example : Load Balancer</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">this is a pseudo code for load balancer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Requester</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> <span class="comment">// the operation to perform</span></span><br><span class="line">	c  <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// the channel to return results</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requester</span><span class="params">(works <span class="keyword">chan</span> Request)</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(<span class="number">80</span>)) * time.Millisecond) <span class="comment">//* to emulate load time</span></span><br><span class="line">		works &lt;- Request&#123;workFn, c&#125;</span><br><span class="line">		result := &lt;-c</span><br><span class="line">		futherProcess(result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Worker</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	requests <span class="keyword">chan</span> Request</span><br><span class="line">	pending  <span class="type">int</span></span><br><span class="line">	index    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> work(done <span class="keyword">chan</span> *Worker) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		req := &lt;-w.requests</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(req Request)</span></span> &#123;</span><br><span class="line">			req.c &lt;- req.fn()</span><br><span class="line">			done &lt;- w</span><br><span class="line">		&#125;(req)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Balacer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool []*Worker</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Balancer <span class="keyword">struct</span> &#123;</span><br><span class="line">	pool Pool</span><br><span class="line">	done <span class="keyword">chan</span> *Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> balancer(work <span class="keyword">chan</span> Request) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> req := &lt;-work:</span><br><span class="line">			b.dispatch(req)</span><br><span class="line">		<span class="keyword">case</span> w := &lt;-b.done:</span><br><span class="line">			b.complete(w)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> dispatch(req Request) &#123;</span><br><span class="line">	w := heap.Pop(&amp;b.pool).(*Worker)</span><br><span class="line">	w.requests &lt;- req</span><br><span class="line">	w.pending++</span><br><span class="line">	heap.Push(&amp;b.pool, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> complete(w *Worker) &#123;</span><br><span class="line">	w.pending--</span><br><span class="line">	heap.Remove(&amp;b.pool, w.index)</span><br><span class="line">	heap.Push(&amp;b.pool, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> poolSize = <span class="number">30</span></span><br><span class="line">	<span class="keyword">var</span> requests <span class="keyword">chan</span> Request = <span class="built_in">make</span>(<span class="keyword">chan</span> Request)</span><br><span class="line">	<span class="keyword">go</span> requester(requests) <span class="comment">//* load request and generate work</span></span><br><span class="line">	<span class="keyword">var</span> b Balancer = Balancer&#123;<span class="built_in">make</span>(Pool, <span class="number">0</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> *Worker)&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; poolSize; i++ &#123;</span><br><span class="line">		b.pool = <span class="built_in">append</span>(b.pool, &amp;Worker&#123;requests, <span class="number">0</span>, i&#125;)</span><br><span class="line">		<span class="keyword">go</span> b.pool[i].work(b.done)</span><br><span class="line">	&#125; <span class="comment">//* generate workers</span></span><br><span class="line"></span><br><span class="line">	b.balancer(requests) <span class="comment">//* do load balance things</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>RISC-V</title>
    <url>/2022/11/17/RISC-V/</url>
    <content><![CDATA[<h1 id="机器的特权状态"><a href="#机器的特权状态" class="headerlink" title="机器的特权状态"></a>机器的特权状态</h1><p>CSR (Control and Status Registers) : 64bits</p>
<table>
<thead>
<tr>
<th>register</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>mscratch</td>
<td>Machine Scratch。保存机器模式的栈顶指针，这一点在离开机器模式进入低特权级模式（如监管模式）时非常重要，因为一旦在低特权级模式发生异常，将可能会回到机器模式处理，这时机器模式需要有自己的栈来保存M模式下的执行所调用的函数参数和返回地址。</td>
</tr>
<tr>
<td>mstatus</td>
<td>Machine Status。保存机器状态的寄存器。</td>
</tr>
<tr>
<td>mtvec</td>
<td>Machine Trap Vector。指向中断处理函数的入口地址。</td>
</tr>
<tr>
<td>mepc</td>
<td>Machine Exception PC。指向发生异常的那条指令的地址。</td>
</tr>
<tr>
<td>mcause</td>
<td>Machine Cause。发生中断的原因，如果发生的中断是异常，其最高位为0，低位为异常编号；如果发生的是其他类型的中断，则其最高位为1，低位为中断编号。</td>
</tr>
<tr>
<td>mtval</td>
<td>Machine Trap Value。异常发生时，附带的参数值。例如，当缺页异常发生时，mtval的值就是程序想要访问的虚地址。</td>
</tr>
<tr>
<td>mie</td>
<td>Machine Interrupt Enable。中断开启寄存器。</td>
</tr>
<tr>
<td>mip</td>
<td>Machine Interrupt Pending。中断等待寄存器。</td>
</tr>
<tr>
<td>mideleg</td>
<td>Machine Interrupt Delegation Registers。中断代理寄存器。</td>
</tr>
<tr>
<td>medeleg</td>
<td>Machine Exception Delegation Registers。异常代理寄存器。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>sscratch</td>
<td>Supervisor Scratch。保存监管模式的栈顶指针，这一点在离开机器模式进入低特权级模式（如用户模式）时非常重要，因为一旦在低特权级模式发生异常，将可能会回到监管模式处理（假设已通过异常授权），这时监管模式需要用自己的栈保存程序执行的返回地址等。</td>
</tr>
<tr>
<td>sstatus</td>
<td>Supervisor Status。保存监管状态的寄存器。</td>
</tr>
<tr>
<td>stvec</td>
<td>Supervisor Trap Vector。指向监管模式中断处理函数的入口地址。</td>
</tr>
<tr>
<td>sepc</td>
<td>Supervisor Exception PC。指向发生异常的那条指令的地址。</td>
</tr>
<tr>
<td>scause</td>
<td>Supervisor Cause。发生中断的原因，如果发生的中断是异常，其最高位为0，低位为异常编号；如果发生的是其他中断其最高位为1，低位为中断编号。</td>
</tr>
<tr>
<td>stval</td>
<td>Supervisor Trap Value。异常发生时，附带的参数值。例如，当缺页异常发生时，mtval的值就是程序想要访问的虚地址。</td>
</tr>
<tr>
<td>sie</td>
<td>Supervisor Interrupt Enable。中断开启寄存器。</td>
</tr>
<tr>
<td>sip</td>
<td>Supervisor Interrupt Pending。中断等待寄存器。</td>
</tr>
<tr>
<td>sideleg</td>
<td>Supervisor Interrupt Delegation Registers。中断代理寄存器。</td>
</tr>
<tr>
<td>sedeleg</td>
<td>Supervisor Exception Delegation Registers。异常代理寄存器。</td>
</tr>
</tbody></table>
<p>CSR 读写指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>csrr rd, csr</td>
<td>Control and Status Register Read，<strong>读</strong>CSR指令。 把csr寄存器中的值写入到rd寄存器中。</td>
</tr>
<tr>
<td>csrw csr, rs1</td>
<td>Control and Status Register Write，<strong>写</strong>CSR指令。 把rs1的值写到csr寄存器中。</td>
</tr>
<tr>
<td>csrs csr, rs1</td>
<td>Control and Status Register Set，<strong>设置</strong>CSR指令。 对于rs1中每一个为1的位，将csr寄存器中对应位置位。</td>
</tr>
<tr>
<td>csrc csr, rs1</td>
<td>Control and Status Register Clear，<strong>清除</strong>CSR指令。 对于rs1中每一个为1的位，将csr寄存器中对应位清零。</td>
</tr>
<tr>
<td>csrrs rd, csr, rs1</td>
<td>Control and Status Register Read and Set，<strong>读后置位</strong>CSR指令。 记控制寄存器中的值为t，把t和寄存器rs1按位或的结果写入csr寄存器，再把t写入rd寄存器。</td>
</tr>
<tr>
<td>csrrc rd, csr, rs1</td>
<td>Control and Status Register Read and Clear，<strong>读后清除</strong>CSR指令。 记控制寄存器中的值为t，把t和寄存器rs1中的值按位与的结果写入csr寄存器，再把t写入rd寄存器。</td>
</tr>
<tr>
<td>csrrw rd, csr, rs1</td>
<td>Control and Status Register Read and Write，<strong>读后写</strong>CSR指令。 记控制寄存器中的值为t，把寄存器rs1的值写入csr寄存器，再把t写入rd寄存器。</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>RISC-V</tag>
      </tags>
  </entry>
</search>
