<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>gin</title>
    <url>/2023/03/03/gin/</url>
    <content><![CDATA[<h1 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h1><h2 id="template基本语法"><a href="#template基本语法" class="headerlink" title="template基本语法"></a>template基本语法</h2><h3 id="模板的定义与加载"><a href="#模板的定义与加载" class="headerlink" title="模板的定义与加载"></a>模板的定义与加载</h3><ul>
<li>使用 <code>loadHTMLGlob</code> 函数加载一个文件夹，<code>*</code>匹配所有文件,<code>**</code>匹配一个文件夹</li>
<li><code>&#123;&#123; define "admin/default.html" &#125;&#125;</code> <code>&#123;&#123; end &#125;&#125;</code> 指定模板的名称</li>
</ul>
<span id="more"></span>

<h3 id="打印变量"><a href="#打印变量" class="headerlink" title="打印变量"></a>打印变量</h3><ul>
<li><code>&#123;&#123; .variable_name &#125;&#125;</code> 打印变量</li>
<li><code>&#123;&#123; $obj = .name &#125;&#125;</code> 定义变量</li>
<li><code>&#123;&#123; $obj &#125;&#125;</code> 打印定义的变量</li>
<li><code>&#123;&#123; .struct.member &#125;&#125;</code> 打印结构体的变量</li>
<li><code>&#123;&#123;- .name -&#125;&#125;</code> 左边的 <code>-</code> 表示去掉左边的空格, 右边的 <code>-</code> 表示去掉右边的空格</li>
</ul>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><ul>
<li><code>&#123;&#123; if ... &#125;&#125;</code> <code>&#123;&#123; else if ... &#125;&#125;</code> <code>&#123;&#123; else &#125;&#125;</code> <code>&#123;&#123; end &#125;&#125;</code> 条件判断<ul>
<li>通过 <code>gt</code>, <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>ge</code> 等进行比较</li>
<li>eg, <code>gt .name 70</code></li>
</ul>
</li>
<li><code>&#123;&#123; range $key,$value := .obj &#125;&#125;</code> <code>&#123;&#123; end &#125;&#125;</code> 进行循环遍历<ul>
<li><code>&#123;&#123; range $key,$value := .obj &#125;&#125;</code> <code>&#123;&#123; else &#125;&#125;</code> <code>&#123;&#123; end &#125;&#125;</code> 增加了else</li>
</ul>
</li>
<li><code>&#123;&#123;with .obj&#125;&#125;</code> <code>&#123;&#123; end &#125;&#125;</code> 进行结构体的解构</li>
</ul>
<h3 id="预定义模板函数"><a href="#预定义模板函数" class="headerlink" title="预定义模板函数"></a>预定义模板函数</h3><ul>
<li><code>&#123;&#123; and .x .y &#125;&#125;</code> 等价于 <code>if x then y else y</code> 返回第一个empty参数或最后一个参数</li>
<li><code>&#123;&#123; or .x .y &#125;&#125;</code> 等价于 <code>if x then x else y</code> 返回第一个非empty参数或最后一个参数</li>
<li><code>&#123;&#123; not .x &#125;&#125;</code></li>
<li><code>&#123;&#123; len .x &#125;&#125;</code></li>
</ul>
<h3 id="自定义模板函数"><a href="#自定义模板函数" class="headerlink" title="自定义模板函数"></a>自定义模板函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(timestamp <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    t := time.Unix(<span class="type">int64</span>(timestamp), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放在加载模板函数前</span></span><br><span class="line">r.SetFuncMap(template.FuncMap&#123;</span><br><span class="line">    <span class="string">&quot;UnixToTime&quot;</span>: UnixToTime   </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.LoadHTMLGlob(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="嵌套template"><a href="#嵌套template" class="headerlink" title="嵌套template"></a>嵌套template</h3><ul>
<li><code>&#123;&#123;template "template_name.html" .&#125;&#125;</code></li>
</ul>
<h3 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h3><ul>
<li><code>r.Static(&quot;/static&quot;, &quot;./static&quot;)</code> 第一个参数表示路由, 第二个参数表示映射的目录</li>
</ul>
<h2 id="获取GET和POST的请求数据"><a href="#获取GET和POST的请求数据" class="headerlink" title="获取GET和POST的请求数据"></a>获取GET和POST的请求数据</h2><h3 id="GET请求中的数据"><a href="#GET请求中的数据" class="headerlink" title="GET请求中的数据"></a>GET请求中的数据</h3><ul>
<li>通过<code>c.Query()</code>函数进行请求</li>
<li>通过<code>c.ShouldBind()</code>或<code>c.Bind()</code>函数将其绑定到结构体, 其中结构体有 <code>form:&quot;xxx&quot;</code> 的tag</li>
</ul>
<h3 id="POST请求中的数据"><a href="#POST请求中的数据" class="headerlink" title="POST请求中的数据"></a>POST请求中的数据</h3><ul>
<li>通过<code>c.PostForm()</code>函数进行请求</li>
<li>通过<code>c.ShouldBind()</code>或<code>c.Bind()</code>函数将其绑定到结构体, 其中结构体有 <code>form:&quot;xxx&quot;</code> 的tag</li>
<li>通过<code>c.GetRawData()</code>获取请求体中的信息, 然后再进行解析</li>
</ul>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul>
<li>通过<code>c.Param()</code>函数获取</li>
<li>通过<code>c.BindUri</code>或<code>c.ShouldBindUri()</code>函数将其绑定到结构体, 其中结构体有 <code>uri:&quot;xxx&quot; binding:&quot;xxx&quot;</code> 的tag</li>
</ul>
<h2 id="路由分组和控制器分组"><a href="#路由分组和控制器分组" class="headerlink" title="路由分组和控制器分组"></a>路由分组和控制器分组</h2><h3 id="路由分组"><a href="#路由分组" class="headerlink" title="路由分组"></a>路由分组</h3><p>用Group函数组织</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">defaultRouter := r.Group(<span class="string">&quot;/admin&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    defaultRouter.GET(<span class="string">&quot;/list&quot;</span>, GetList)</span><br><span class="line">    defaultRouter.POST(<span class="string">&quot;/putlist&quot;</span>, PutList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="控制器分组"><a href="#控制器分组" class="headerlink" title="控制器分组"></a>控制器分组</h3><p>用结构体组织</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> adminController <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con adminController)</span></span> UserIndex(c *gin.Context) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con adminController)</span></span> UserAdd(c *gin.Context) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con adminController)</span></span> UserDelete(c *gin.Context) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制器可以”继承”</p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="中间件执行流程"><a href="#中间件执行流程" class="headerlink" title="中间件执行流程"></a>中间件执行流程</h3><p><code>c.Next()</code> 会继续之后的请求</p>
<p><code>c.Abort()</code> 会中止调用该请求的剩余程序</p>
<h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><p><code>r.Use()</code></p>
<h3 id="路由中使用中间件"><a href="#路由中使用中间件" class="headerlink" title="路由中使用中间件"></a>路由中使用中间件</h3><ul>
<li><code>r.Group(&quot;/&quot;, middleware)</code>中使用中间件</li>
<li><code>defaultRouter.Use(middleware)</code>中使用中间件</li>
</ul>
<h3 id="中间件中传递数据"><a href="#中间件中传递数据" class="headerlink" title="中间件中传递数据"></a>中间件中传递数据</h3><ul>
<li>通过<code>c.Set(string1, string2)</code>设置数据</li>
<li>通过<code>c.Get(string1)</code>使用在别的中间件中设置的数据, 注意<code>c.Get()</code>得到的数据为<code>any</code>类型</li>
</ul>
<h3 id="默认中间件"><a href="#默认中间件" class="headerlink" title="默认中间件"></a>默认中间件</h3><p><code>gin.Default()</code>会默认使用<code>Logger</code>和<code>Recovery</code>中间件</p>
<ul>
<li><code>Logger</code>中间件会将日志写入<code>gin.DefaultWriter</code></li>
<li><code>Recovery</code>中间件会recovery任何panic, 如果有panic, 写入500状态码</li>
</ul>
<p><code>gin.New()</code>创建不带任何中间件的路由</p>
<h3 id="中间件中使用goroutine"><a href="#中间件中使用goroutine" class="headerlink" title="中间件中使用goroutine"></a>中间件中使用goroutine</h3><p>在handler中启动新的goroutine时, 不能使用c(*gin.Context), 需要使用<code>c.Copy()</code></p>
<p>gin中不需要使用WaitGroup, 因为<code>gin.Run()</code>主程序永远不会退出</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="单文件"><a href="#单文件" class="headerlink" title="单文件"></a>单文件</h3><p><code>r.MaxMultipartMemory = 8 &lt;&lt; 20</code> 将内存限制设置为8MB, 默认为32MB</p>
<p><code>file, err := c.FileForm(&quot;file&quot;)</code>, 返回一个<code>*multipart.FileHeader</code>类型的<code>file</code>.</p>
<p><code>c.SaveUploadedFile(file, dst)</code> 将文件存入到对印的路径</p>
<h3 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h3><p><code>r.MaxMultipartMemory = 8 &lt;&lt; 20</code> 将内存限制设置为8MB, 默认为32MB</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">form, err := c.MultipartForm()</span><br><span class="line">files := form.File[<span class="string">&quot;upload[]&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">    dst := path.Join(<span class="string">&quot;./&quot;</span>, file.Filename)</span><br><span class="line">    c.SaveUploadedFile(file, dst))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h3><p>通过<code>gin.SetCookie(name, value, maxAge, path, domain, secure, httpOnly)</code>函数进行设置Cookie</p>
<ul>
<li>name 表示 key</li>
<li>value 表示 value</li>
<li>maxAge 表示过期时间, 如果小于等于0, 怎表示删除该 Cookie</li>
<li>path 表示 cookie 的路径, 表示什么路径可以访问该 Cookie</li>
<li>domain 表示 cookie 路径的 domain 作用域, 本地可为 localhost, 线上环境为域名</li>
<li>secure 为 true 表示在 HTTP 中无效</li>
<li>httpOnly 为 true 表示在程序(JS脚本, applet等)中无效, 防止 XSS 攻击</li>
</ul>
<h3 id="二级域名共享Cookie"><a href="#二级域名共享Cookie" class="headerlink" title="二级域名共享Cookie"></a>二级域名共享Cookie</h3><p>在设置domain的时候省略最后一级作用域</p>
<p>例如: a.anyu.com 和 b.anyu.com 共享时, 只需要将 domain 设置为 <code>.anyu.com</code> 即可</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="Session中间件"><a href="#Session中间件" class="headerlink" title="Session中间件"></a>Session中间件</h3><p>需要通过 github.com&#x2F;gin-contrib&#x2F;sessions 中的第三方的 Session 中间件完成</p>
<p><code>github.com/gin-contrib/sessions</code> 中支持的存储引擎: </p>
<ul>
<li>cookie</li>
<li>memstore</li>
<li>redis</li>
<li>memcached</li>
<li>mongodb</li>
<li>gorm</li>
<li>postgresql</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建基于cookie的存储引擎, 并指定加密用的密钥</span></span><br><span class="line">store := cookie.NewStore([]<span class="type">byte</span>&#123;<span class="string">&quot;your_secret_key&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 配置session的中间件, 指定存储引擎</span></span><br><span class="line">r.Use(sessions.Sessions(<span class="string">&quot;mysession&quot;</span>, store)) <span class="comment">// mysession 为cookie中的key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// session的设置</span></span><br><span class="line">session := sessions.Default(c)</span><br><span class="line">session.Set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;information&quot;</span>)</span><br><span class="line">session.Save()	<span class="comment">// 必须调用Save才能保存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// session的使用</span></span><br><span class="line">username := session.Get(<span class="string">&quot;username&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><p>使用Redis作为存储引擎</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置Redis存储引擎并配置Session </span></span><br><span class="line">store, _ := redis.NewStore(<span class="number">10</span>, <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;addr:port&quot;</span>, <span class="string">&quot;password&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;secret_key&quot;</span>))</span><br><span class="line">r.Use(sessions.Sessions(<span class="string">&quot;mysession&quot;</span>, store))</span><br><span class="line"></span><br><span class="line">session := sessions.Default(c)</span><br><span class="line"><span class="comment">// 设置 session 的过期时间</span></span><br><span class="line">session.Options(session.Options&#123;</span><br><span class="line">    MaxAge: <span class="number">3600</span> * <span class="number">6</span> <span class="comment">// 6 hours</span></span><br><span class="line">&#125;)</span><br><span class="line">session.Set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;information&quot;</span>)</span><br><span class="line">session.Save()	<span class="comment">// 必须调用Save才能保存</span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang</title>
    <url>/2023/03/02/Golang/</url>
    <content><![CDATA[<h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><h2 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h2><p>在Go 1.18以前: 当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的 <code>1.25</code> 倍。</p>
<p>Go 1.18及以后: 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的 <code>2</code> 倍；原 slice 容量大于 <code>256</code>，新slice 容量 <code>newcap = oldcap+(oldcap+3*256)/4</code> (threadhold &#x3D; 256)</p>
<p><strong>其中最后会对内存进行对齐操作</strong></p>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go 1.18 src/runtime/slice.go:178</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                <span class="comment">// Transition from growing 2x for small slices</span></span><br><span class="line">				<span class="comment">// to growing 1.25x for large slices. This formula</span></span><br><span class="line">				<span class="comment">// gives a smooth-ish transition between the two.</span></span><br><span class="line">				newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">    </span><br><span class="line">	capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">	newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _MaxSmallSize = <span class="number">32768</span></span><br><span class="line"><span class="keyword">const</span> smallSizeMax = <span class="number">1024</span></span><br><span class="line"><span class="keyword">const</span> smallSizeDiv = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">roundupsize</span><span class="params">(size <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> size &lt; _MaxSmallSize &#123;</span><br><span class="line">		<span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">uintptr</span>(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">uintptr</span>(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> size+_PageSize &lt; size &#123;</span><br><span class="line">		<span class="keyword">return</span> size</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> alignUp(size, _PageSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Map-的数据结构设计"><a href="#Map-的数据结构设计" class="headerlink" title="Map 的数据结构设计"></a>Map 的数据结构设计</h2><h3 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h3><p>map 设计的关键点: map 是由 <code>key-value</code> 对组成的；<code>key</code> 只会出现一次。</p>
<ul>
<li>Hash Table 实现<ul>
<li>Chaining Scheme 或 Open Addressing Scheme 实现 Hash Table</li>
<li>平均操作时间 O(1), 最差时间复杂度 O(n)</li>
</ul>
</li>
<li>Search Tree 实现<ul>
<li>AVL tree 或 Red-Black Tree 实现 Search Tree</li>
<li>平均操作时间&#x2F;最差时间复杂度均为 O(log n)</li>
</ul>
</li>
</ul>
<h3 id="Go-hmap-数据结构"><a href="#Go-hmap-数据结构" class="headerlink" title="Go hmap 数据结构"></a>Go hmap 数据结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 元素个数，调用 len(map) 时，直接返回此值</span></span><br><span class="line">	count     <span class="type">int</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// buckets 的对数 log_2</span></span><br><span class="line">	B         <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// overflow 的 bucket 近似数</span></span><br><span class="line">	noverflow <span class="type">uint16</span></span><br><span class="line">	<span class="comment">// 计算 key 的哈希的时候会传入哈希函数</span></span><br><span class="line">	hash0     <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 指向 buckets 数组，大小为 2^B</span></span><br><span class="line">    <span class="comment">// 如果元素个数为0，就为 nil</span></span><br><span class="line">	buckets    unsafe.Pointer</span><br><span class="line">	<span class="comment">// 等量扩容的时候，buckets 长度和 oldbuckets 相等</span></span><br><span class="line">	<span class="comment">// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍</span></span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line">	<span class="comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buckets长度为 $2^B$, 因此 B 每增加 1 表示 buckets 扩容一倍, buckets 指向的是一个结构体, 结构体的结构如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示一个桶</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    <span class="comment">// 以下成员经过编译器扩充才有</span></span><br><span class="line">    keys 	 [<span class="number">8</span>]keytype</span><br><span class="line">    values 	 [<span class="number">8</span>]valuetype</span><br><span class="line">    pad   	 <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>keytype 放在一起, valuetype 也放在一起, 这样减少了不必要的 padding.</li>
<li>HOB Hash 表示 top hash, hash值的前八位.</li>
</ul>
<p><strong>当 map 的 key 和 value 都不是指针，并且 size 都小于 128 字节的情况下，会把 bmap 标记为不含指针，这样可以避免 gc 时扫描整个 hmap, 但是，我们看 bmap 其实有一个 overflow 的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把 overflow 移动到 extra 字段来。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// overflow contains overflow buckets for hmap.buckets.</span></span><br><span class="line">	<span class="comment">// oldoverflow contains overflow buckets for hmap.oldbuckets.</span></span><br><span class="line">	overflow    *[]*bmap</span><br><span class="line">	oldoverflow *[]*bmap</span><br><span class="line"></span><br><span class="line">	<span class="comment">// nextOverflow 包含空闲的 overflow bucket，这是预分配的 bucket</span></span><br><span class="line">	nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map-的创建"><a href="#Map-的创建" class="headerlink" title="Map 的创建"></a>Map 的创建</h3><p>map的创建底层调用的 <code>makemap</code> 函数, 主要工作包含</p>
<ul>
<li>初始化 hmap 结构的字段, 例如计算B的大小, 设置哈希种子 hash0 等</li>
<li>B 的计算: 负载因子不能超过 6.5 </li>
<li><strong>最后返回的结果为</strong> <code>*hmap</code><ul>
<li>因此map作为函数参数的时候, 对map的修改会影响到map自身,</li>
<li>而slice是一个结构体, 修改与自身无关</li>
</ul>
</li>
</ul>
<p>	</p>
<h3 id="Hash-函数的选择"><a href="#Hash-函数的选择" class="headerlink" title="Hash 函数的选择"></a>Hash 函数的选择</h3><p>Hash函数通常分为加密型(md5, sha1, sha256, aes256等)和非加密型(一般用于查找). 查找型(map)需要考虑的点为: 性能和碰撞率</p>
<p>在程序启动时，会检测 cpu 是否支持 <em>aes</em>，如果支持，则使用 <em>aes hash</em>，否则使用 <em>memhash</em>。</p>
<p>表示类型的结构体<code>_type</code>中会有一个<code>alg</code>字段, 其结构为<code>*typeAlg</code>, hash 用于计算类型的哈希值, 而 equal 函数计算两个类型是否哈希相等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line">   	<span class="comment">// (ptr to object, seed) -&gt; hash</span></span><br><span class="line">	hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span></span><br><span class="line">	<span class="comment">// (ptr to object A, ptr to object B) -&gt; ==?</span></span><br><span class="line">	equal <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map-的操作设计"><a href="#Map-的操作设计" class="headerlink" title="Map 的操作设计"></a>Map 的操作设计</h2><h3 id="Key-的寻找"><a href="#Key-的寻找" class="headerlink" title="Key 的寻找"></a>Key 的寻找</h3><p>一个hash函数得到的结果为64位数据, 其中低B位作为桶的索引(<strong>位运算比取余的开销要小得多</strong>). 高八位存储在tophash中.</p>
<p>通过key寻找的时候:</p>
<ul>
<li>首先需要判断是在 oldbuckets 里面找还是 buckets 里面找<ul>
<li>需要判断 oldbuckets 中的数据是否被迁移完毕. 判断的主要依据为根据tophash[0]的值标志的状态判断.</li>
<li><code>minTopHash=4</code>，用来表示状态的值有 <strong>0, 1, 2, 3</strong>. 因此为了区分正常计算出的hash值和表示状态的值, 正常计算出的小于 4 的 hash 值都会加上一个 minTopHash(4). 这样正常计算出来的hash值均大于等于4, 而小于4的表示迁移状态.</li>
</ul>
</li>
<li>通过低 B 位找到 bucket, 然后比较高8位和 bucket 中的 tophash 是否相同. 最后比较 key 是否相同, 相同则找到.</li>
<li>如果在一个 bucket 中没有找到, 且存在 overflow, 则需要再在 overflow 中比较.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空的 cell，也是初始时 bucket 的状态</span></span><br><span class="line">empty          = <span class="number">0</span></span><br><span class="line"><span class="comment">// 空的 cell，表示 cell 已经被迁移到新的 bucket</span></span><br><span class="line">evacuatedEmpty = <span class="number">1</span></span><br><span class="line"><span class="comment">// key,value 已经搬迁完毕，但是 key 都在新 bucket 前半部分，</span></span><br><span class="line"><span class="comment">// 后面扩容部分会再讲到。</span></span><br><span class="line">evacuatedX     = <span class="number">2</span></span><br><span class="line"><span class="comment">// 同上，key 在后半部分</span></span><br><span class="line">evacuatedY     = <span class="number">3</span></span><br><span class="line"><span class="comment">// tophash 的最小正常值</span></span><br><span class="line">minTopHash     = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><img src="https://golang.design/go-questions/map/assets/2.png" alt="mapacess"></p>
<h3 id="Get-的两种实现"><a href="#Get-的两种实现" class="headerlink" title="Get 的两种实现"></a>Get 的两种实现</h3><p>comma-ok模式和直接取变量的模式. 例如: <code>age1 := ageMap[&quot;stefno&quot;]</code>和<code>age2, ok := ageMap[&quot;stefno&quot;]</code>.</p>
<p>这其实是由编译器实现的: 分析代码后，将两种语法对应到底层两个不同的函数。</p>
<p>同时, 根据key的不同类型, 编译器还会将查找, 插入, 删除函数用更加具体的函数替换, 以优化效率</p>
<h3 id="遍历过程"><a href="#遍历过程" class="headerlink" title="遍历过程"></a>遍历过程</h3><p><em>Strawman Idea</em>: 直接遍历所有的bucket, 对每一个bucket及其overflow, 遍历每个cell即可</p>
<p>Problem: map的遍历中如果存在扩容过程, 就会涉及到遍历老的bucket的过程</p>
<p>真实遍历过程:</p>
<ul>
<li>map的遍历是随机的, 这是因为遍历的起始位置(起始bucket和起始cell)是通过随机数产生的</li>
<li>选定遍历位置之后, 如果当前不处于扩容状态, 则直接遍历即可. 如果处于扩容状态, 则需要考虑oldbucket中的元素.</li>
<li>对于新 buckets 中的每一个 bucket, 其都是由 oldbuckets 中的每一个 bucket 分裂而来(类似于 extendible hash table), 因此在遍历新 bucket 之前, 需要判断对应的 oldbucket 是否迁移完毕. <ul>
<li>如果迁移完毕, 则直接遍历新的 bucket 即可</li>
<li>如果还没有迁移完毕, <strong>则遍历 oldbucket 中迁移后属于当前 bucket 的元素</strong>.</li>
</ul>
</li>
</ul>
<p><img src="https://golang.design/go-questions/map/assets/6.png" alt="img"></p>
<h3 id="赋值过程"><a href="#赋值过程" class="headerlink" title="赋值过程"></a>赋值过程</h3><p>插入或修改 key 在汇编层面都是调用了函数 mapassign.</p>
<ul>
<li>首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行写操作，进而导致程序 panic</li>
<li>根据 key 计算 hash 值, 然后分别遍历所有的 overflow bucket, 以及 bucket 中的所有 cell</li>
<li>map 的扩容是渐进式的, 如果 map 正处于扩容过的过程中, 需要先确保该 bucket 对应的老 bucket 迁移完毕(分裂为两个bucket), 才能进行插入或更新的操作</li>
<li><code>inserti</code> 和 <code>insertk</code> 用于指定插入的位置. 在循环过程中, 首先指向第一个发现的空位. 若找到则跳出循环.</li>
<li>在正式放置 key 之前还需要检查是否达到扩容条件, 如果满足条件, 则触发一次扩容操作.</li>
</ul>
<h3 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h3><ul>
<li>计算 key 的哈希, 找到落入的 bucket. 检查此 map 如果正在扩容的过程中, 直接触发一次搬迁操作.</li>
<li>如果找到了, 就对 key 和 value 执行清零操作</li>
</ul>
<h3 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h3><p>扩容时机: 向 map 插入或删除 key 的时候, 会进行条件检查, 满足下面的条件的会触发一次扩容</p>
<ul>
<li>装载因子(loadFactor &#x3D; count &#x2F; 2^B)超过threshold, threshold等于6.5</li>
<li>overflow 的数量过多 <ul>
<li>B 小于 15 的时候, overflow 的数量大于 2^B</li>
<li>B 大于 15 的时候, overflow 的数量大于 2^15</li>
</ul>
</li>
</ul>
<p>扩容原因:</p>
<ul>
<li>第一种情况, 由于每个 bucket 有八个 cell, 装载因子大于 6.5 说明很多 bucket 快要装满了, 会降低查找效率和插入效率. 因此需要进行增量扩容, 使 bucket 不容纳那么多 key.</li>
<li>第二种情况, 负载因子没有超过 6.5 但是 overflow 的数量太多, 说明分配的 overflow bucket 数量太多, 而元素总数较少, 这样也会降低插入和查找效率, 因此可以进行等量扩容, 使 key 的排列更加紧密.<ul>
<li>第二种情况是对第一种情况的补充, 主要是在一直不停的插入和删除元素的时候可能发生.</li>
<li>也有可能数据是非常 skewed, 导致大部分的 key 的 hash 值一样, 这个时候等量扩容并没有解决这个问题.</li>
</ul>
</li>
</ul>
<p>扩容细节:</p>
<ol>
<li><p><code>hasGrow()</code> 函数和调用时机</p>
<ul>
<li><code>hashGrow()</code> 函数并没有真正的进行**搬迁(evacuate函数)**操作, 它只是分配了新的 buckets, 将老的 buckets 挂载到了 oldbuckets 字段上, 并设置了一些标志位. </li>
<li>注意, 如果当前的 iterator 位被设置, 则经过 <code>hasGrow</code> 操作, 标志位被转为 <code>oldIterator</code> </li>
<li><code>hashGrow()</code> 函数的调用发生在 <code>mapassign</code> 中, 是在即将插入之前, 检测到满足扩容条件后执行的. 并且在扩容之后, 需要重新进行一遍寻找 key 的操作, 因为此时进行了扩容, key 的插入操作发生了改变.</li>
</ul>
</li>
<li><p><code>growWork()</code> 函数和调用时机</p>
<ul>
<li><code>growWork()</code> 首先会调用 <code>evacuate()</code> 函数搬迁正在使用的 bucket 对应的老的 bucket.</li>
<li>在搬迁完第一个老 bucket 后, 检查搬迁进程, 如果没有搬迁完, 就会会为了搬迁进度而多搬迁一个 bucket</li>
<li><code>growWork()</code> 函数调用发生在 <code>mapassign</code> 和 <code>mapdelete</code> 中, 发生在进行 key 的查找之前</li>
</ul>
</li>
<li><p><code>evacuate()</code> 函数</p>
<ul>
<li>首先判断当前 bucket 是否被搬迁过, 如果已经被搬迁过, 则直接返回, 如果没有, 则执行下面的操作</li>
<li>定义搬迁的目标位置, 分为 x part 和 y part. x part 用于等量扩容, y part 用于增量扩容</li>
<li>遍历所有的 old bucket(包括overflow bucket), 然后遍历每一个 bucket 中的所有 cell, 将不为空的 cell 搬迁到新的 bucket 中去(<strong>根据是否为等容扩容决定是搬到 x part 或 y part</strong>).</li>
<li>如果 flag 中 oldIterator 字段没有设置, 则说明已经没有协程在访问老的 buckets, 则将 buckets 清除掉以帮助 gc</li>
<li>最后跳出循环之后, 需要更新搬迁进度. 如果所有的bucket都已经被搬迁完毕, 则将 oldbuckets 设置为 nil, 清除对应的标志位. 最后退出.</li>
</ul>
</li>
<li><p><code>evacuated()</code> 函数和 <code>growing()</code> 函数</p>
<ul>
<li><pre><code class="go">func (h *hmap) growing() bool &#123;
    return h.oldbuckets != nil
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 因为扩容完毕之后 oldbuckets 会被置为 nil</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  empty = 0</span><br><span class="line">  evacuatedEmpty = 1</span><br><span class="line">  evacuatedX = 2</span><br><span class="line">  evacuatedY = 3</span><br><span class="line">  minTopHash = 4</span><br><span class="line">  </span><br><span class="line">  func evacuated(b *bmap) bool &#123;</span><br><span class="line">  	h := b.tophash[0]</span><br><span class="line">  	return h &gt; empty &amp;&amp; h &lt; minTopHash</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>因为 <code>evacuate</code> 操作是以 bucket 为单位的, 所以如果某一个 bucket 的第 0 位被搬迁了, 则说明整个 bucket 都被搬迁了</p>
<ul>
<li>evacuatedEmpty 表示被搬迁之前的 cell 为空, evacuatedX 表示被搬到了 x part, evacuatedY 表示被搬到了 y part.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Map-的特殊情况"><a href="#Map-的特殊情况" class="headerlink" title="Map 的特殊情况"></a>Map 的特殊情况</h2><h3 id="float类型作为map的key"><a href="#float类型作为map的key" class="headerlink" title="float类型作为map的key"></a>float类型作为map的key</h3><p>float64 作为 key 的时候会被自动转换为 uint64 类型</p>
<p>NaN 的定义中: <code>NaN != NaN</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">uvnan = <span class="number">0x7FF8000000000001</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NaN</span><span class="params">()</span></span> <span class="type">float64</span> &#123; <span class="keyword">return</span> Floats64frombits(uvnan)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f64hash</span><span class="params">(p unsafe.Pointer, h <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">	f := *(*<span class="type">float64</span>)(p)</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> c1 * (c0 ^ h) <span class="comment">// +0, -0</span></span><br><span class="line">    <span class="comment">// 针对 NaN</span></span><br><span class="line">	<span class="keyword">case</span> f != f:</span><br><span class="line">		<span class="keyword">return</span> c1 * (c0 ^ h ^ <span class="type">uintptr</span>(fastrand())) <span class="comment">// any kind of NaN</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> memhash(p, h, <span class="number">8</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此, 由于 NaN 的特性, 有 <code>NaN != NaN</code>, <code>hash(NaN) != hash(NaN)</code></p>
<h3 id="边遍历边删除"><a href="#边遍历边删除" class="headerlink" title="边遍历边删除"></a>边遍历边删除</h3><p>map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</p>
<p>如果在同一个协程内边遍历边删除，并不会检测到同时读写。但是，遍历的结果就可能不会是相同的了，有可能结果遍历结果集中包含了删除的 key，也有可能不包含，这取决于删除 key 的时间：是在遍历到 key 所在的 bucket 时刻前或者后。</p>
<h3 id="无法对map元素取地址"><a href="#无法对map元素取地址" class="headerlink" title="无法对map元素取地址"></a>无法对map元素取地址</h3><p>对 map 元素取地址会引发编译错误</p>
<p>且即使取出了地址, 也会因为扩容等因素而失效</p>
<h3 id="比较两个map相等"><a href="#比较两个map相等" class="headerlink" title="比较两个map相等"></a>比较两个map相等</h3><p><code>==</code> 只能用于比较 map 是否为 nil</p>
<p><code>m == n</code> 不能通过编译</p>
<h1 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h1><h2 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h2><p><code>Duck Typing</code>, 鸭子类型, 是动态编程语言的一种对象推断策略, 它更关注对象能如何被使用, 而不是对象的类型本身. Go 语言作为一门静态语言, 它通过通过接口的方式完美支持鸭子类型。</p>
<p>鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它<strong>当前方法和属性的集合</strong>决定。Go 作为一种静态语言，通过接口实现了<code>鸭子类型</code>，实际上是 Go 的编译器在其中作了隐匿的转换工作。</p>
<h2 id="值-x2F-指针接收者和类型本质"><a href="#值-x2F-指针接收者和类型本质" class="headerlink" title="值&#x2F;指针接收者和类型本质"></a>值&#x2F;指针接收者和类型本质</h2><p>实现了接收者是值类型的方法，相当于自动(隐含地)实现了接收者是指针类型的方法；</p>
<p>而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法</p>
<p>使用指针作为方法的接收者的理由：</p>
<ul>
<li>方法能够修改接收者指向的值。</li>
<li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li>
</ul>
<p><strong>使用指针方法还是值方法不应该由方法是否修改了被调用者来决定, 而是由被调用者的本质来决定</strong>: </p>
<ul>
<li>如果类型具备”原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</li>
<li>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体(struct File)就不应该被复制，应该只有一份<code>实体</code>。</li>
</ul>
<h2 id="iface-和-eface"><a href="#iface-和-eface" class="headerlink" title="iface 和 eface"></a>iface 和 eface</h2><p><code>iface</code> 描述带方法的接口, <code>eface</code> 描述空接口 <code>interface&#123;&#125;</code></p>
<h3 id="iface"><a href="#iface" class="headerlink" title="iface"></a>iface</h3><p>iface 维护两个指针, 分别指向 itab 和 data. </p>
<p>itab 中</p>
<ul>
<li>_type 描述了实体的类型(包含内存对齐方式, 大小等)</li>
<li>inter 字段则描述了接口的类型</li>
<li>fun 字段放置了和接口方法对应的具体数据类型的地址, 实现接口调用方法的动态分派. 一般在接口赋值的时候会更新这个表(如果有 itab 缓存则直接使用 itab 缓存).</li>
</ul>
<p>interfacetype 中</p>
<ul>
<li>typ 字段为 _type 类型, _type 描述了 go 语言中各种数据类型的结构体.</li>
<li>_mhdr 字段表示了接口定义的函数列表</li>
<li>pkgpath 记录了接口定义的包名</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter  *interfacetype</span><br><span class="line">	_type  *_type</span><br><span class="line">	link   *itab</span><br><span class="line">	hash   <span class="type">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">	bad    <span class="type">bool</span>   <span class="comment">// type does not implement interface</span></span><br><span class="line">	inhash <span class="type">bool</span>   <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">	unused [<span class="number">2</span>]<span class="type">byte</span></span><br><span class="line">	fun    [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgpath name</span><br><span class="line">	mhdr    []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://golang.design/go-questions/interface/assets/0.png" alt="iface 结构体全景"></p>
<h3 id="eface"><a href="#eface" class="headerlink" title="eface"></a>eface</h3><p>eface 中:</p>
<ul>
<li>_type 维护了空接口承载的实体类型</li>
<li>data 描述具体的值</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iface-x2F-eface-的组装"><a href="#iface-x2F-eface-的组装" class="headerlink" title="iface&#x2F;eface 的组装"></a>iface&#x2F;eface 的组装</h3><p>通过以下两个函数, 将实体的值和类型值组装成 interface</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2E64</span><span class="params">(t *_type, elem unsafe.Pointer)</span></span> (e eface)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span></span> (i iface)</span><br></pre></td></tr></table></figure>

<p>如下函数所示, 将 <code>tab</code> 赋值给了 <code>iface</code> 的 <code>tab</code> 字段, <code>data</code> 字段则是在堆上申请了内存, 然后将 <code>elem</code> 中的值拷贝过去. 这样就组装好了 <code>iface</code>.</p>
<p>动态生成的 itab 是通过一个全局的哈希表来缓存和查找的. 哈希表的键是一个包含接口类型和具体类型的结构体, 值是对应的 itab 指针。每次运行时需要创建一个新的 itab 时, 都会先在哈希表中查找是否已经存在相同的键, 如果存在就直接返回对应的值, 如果不存在就创建一个新的 itab 并插入到哈希表中. 这样可以避免重复创建相同的 itab, 提高性能。</p>
<p>需要在实现的时候动态组装 <code>itab</code> 的原因: 不可能在编译之前就确定完所有可能的 <code>itab</code> 并全部创建. 因此需要在运行的时候动态维护 <code>itab</code> 的 hash 表. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I64</span><span class="params">(tab *itab, elem unsafe.Pointer)</span></span> (i iface) &#123;</span><br><span class="line">	t := tab._type</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> *(*<span class="type">uint64</span>)(elem) == <span class="number">0</span> &#123;</span><br><span class="line">		x = unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x = mallocgc(<span class="number">8</span>, t, <span class="literal">false</span>)</span><br><span class="line">		*(*<span class="type">uint64</span>)(x) = *(*<span class="type">uint64</span>)(elem)</span><br><span class="line">	&#125;</span><br><span class="line">	i.tab = tab</span><br><span class="line">	i.data = x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-结构体"><a href="#type-结构体" class="headerlink" title="_type 结构体"></a>_type 结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 类型大小</span></span><br><span class="line">	size       <span class="type">uintptr</span></span><br><span class="line">    ptrdata    <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// 类型的 hash 值</span></span><br><span class="line">    hash       <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 类型的 flag，和反射相关</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    <span class="comment">// 内存对齐相关</span></span><br><span class="line">    align      <span class="type">uint8</span></span><br><span class="line">    fieldalign <span class="type">uint8</span></span><br><span class="line">    <span class="comment">// 类型的编号，有bool, slice, struct 等等等等</span></span><br><span class="line">	kind       <span class="type">uint8</span></span><br><span class="line">	alg        *typeAlg</span><br><span class="line">	<span class="comment">// gc 相关</span></span><br><span class="line">	gcdata    *<span class="type">byte</span></span><br><span class="line">	str       nameOff</span><br><span class="line">	ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上, 增加一些额外的字段来进行管理的, 且这些类型的实现是反射的基础</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> arraytype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ   _type</span><br><span class="line">	elem  *_type</span><br><span class="line">	slice *_type</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  _type</span><br><span class="line">	elem *_type</span><br><span class="line">	dir  <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  _type</span><br><span class="line">	elem *_type</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> structtype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgPath name</span><br><span class="line">	fields  []structfield</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口的动态类型和动态值"><a href="#接口的动态类型和动态值" class="headerlink" title="接口的动态类型和动态值"></a>接口的动态类型和动态值</h2><p>从源码里可以看到: <code>iface</code>包含两个字段: <code>tab</code> 是接口表指针, 指向类型信息; <code>data</code> 是数据指针, 则指向具体的数据. 它们分别被称为<strong>动态类型</strong>和<strong>动态值</strong>. 而接口值包括<strong>动态类型</strong>和<strong>动态值</strong>.</p>
<p>接口值和 <code>nil</code> 的比较: 当接口值和接口类型都为 <code>nil</code> 的时候, 接口值才会被认为 <code>nil</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span></span> code() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s is coding\n&quot;</span>, g.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Coder</span><br><span class="line">	fmt.Println(c == <span class="literal">nil</span>)  			<span class="comment">// true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;c: %T, %v\n&quot;</span>, c, c) <span class="comment">// c: &lt;nil&gt;, &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> g *Gopher</span><br><span class="line">	fmt.Println(g == <span class="literal">nil</span>)			<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	c = g</span><br><span class="line">	fmt.Println(c == <span class="literal">nil</span>)			<span class="comment">// false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;c: %T, %v\n&quot;</span>, c, c) <span class="comment">// c: *main.Gopher, &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出接口的动态类型和值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	itab, data <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(<span class="literal">nil</span>)</span><br><span class="line">	x := <span class="number">5</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = (*<span class="type">int</span>)(&amp;x)</span><br><span class="line">	</span><br><span class="line">	ia := *(*iface)(unsafe.Pointer(&amp;a))</span><br><span class="line">	ib := *(*iface)(unsafe.Pointer(&amp;b))</span><br><span class="line">	ic := *(*iface)(unsafe.Pointer(&amp;c))</span><br><span class="line"></span><br><span class="line">	fmt.Println(ia, ib, ic)	<span class="comment">// &#123;0 0&#125; &#123;17426912 0&#125; &#123;17426912 842350714568&#125;</span></span><br><span class="line">	fmt.Println(*(*<span class="type">int</span>)(unsafe.Pointer(ic.data))) <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译器检查类型是否实现接口"><a href="#编译器检查类型是否实现接口" class="headerlink" title="编译器检查类型是否实现接口"></a>编译器检查类型是否实现接口</h2><p>通过下面的代码, 可以分别检查 <code>*myWriter</code> 和 <code>myWriter</code> 是否实现了接口 <code>io.Writer</code>. 因为这些赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换和类型断言"><a href="#类型转换和类型断言" class="headerlink" title="类型转换和类型断言"></a>类型转换和类型断言</h2><p><strong>类型转换</strong>、<strong>类型断言</strong>本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>对于<strong>类型转换</strong>而言，转换前后的两个类型要相互兼容才行</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>接口断言的时候会发生赋值操作</p>
<h2 id="接口转换的原理"><a href="#接口转换的原理" class="headerlink" title="接口转换的原理"></a>接口转换的原理</h2><p>生成一个 <code>itab</code> 同时需要接口的类型(inter *interface)和实体(typ _type)的类型.</p>
<p>当判定一种类型是否满足某个接口时, Go 使用类型的方法集和接口所需要的方法集进行匹配, 如果类型的方法集完全包含接口的方法集, 则可认为该类型实现了该接口.</p>
<p>例如某类型有 <code>m</code> 个方法, 某接口有 <code>n</code> 个方法, 则很容易知道这种判定的时间复杂度为 <code>O(mn)</code>, Go 会对方法集的函数按照函数名的字典序进行排序, 所以实际的时间复杂度为 <code>O(m+n)</code>.</p>
<p><code>convI2I</code> 函数真正要做的事: 找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口转换为接口的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convI2I</span><span class="params">(inter *interfacetype, i iface)</span></span> (r iface) &#123;</span><br><span class="line">	tab := i.tab</span><br><span class="line">	<span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tab.inter == inter &#123;</span><br><span class="line">		r.tab = tab</span><br><span class="line">		r.data = i.data</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.tab = getitab(inter, tab._type, <span class="literal">false</span>)</span><br><span class="line">	r.data = i.data</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中在以上的代码中, <code>r.tab</code> 是由转换后的 <code>inter</code> 以及实体的类型 <code>_type</code> 构成的, 通过 <code>getitab</code> 函数组装或从全局哈希表中查询得到的. 其中 <code>getitab</code> 函数如下所示: </p>
<ul>
<li>首先根据 <code>inter</code> 和 <code>typ</code> 计算出 hash 值</li>
<li>不上锁的遍历 hash 表(使用 atomic 保证原子性), 如果找到则直接返回</li>
<li>如果没找到, 则第二次需要上锁后再遍历一遍, 如果依然遍历没有遍历到, 则生成一个新的 itab 并将其加入 hash 表. 这样，其他协程在查找相同的 <code>itab</code> 并且也没有找到时, 第二次查找时, 会被挂住, 之后, 就会查到第一个协程写入哈希表的 <code>itab</code>.</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="type">bool</span>)</span></span> *itab &#123;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 inter, typ 计算出 hash 值</span></span><br><span class="line">	h := itabhash(inter, typ)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// look twice - once without lock, once with.</span></span><br><span class="line">	<span class="comment">// common case will be no lock contention.</span></span><br><span class="line">	<span class="keyword">var</span> m *itab</span><br><span class="line">	<span class="keyword">var</span> locked <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> locked = <span class="number">0</span>; locked &lt; <span class="number">2</span>; locked++ &#123;</span><br><span class="line">		<span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;ifaceLock)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历哈希表的一个 slot</span></span><br><span class="line">		<span class="keyword">for</span> m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != <span class="literal">nil</span>; m = m.link &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）</span></span><br><span class="line">			<span class="keyword">if</span> m.inter == inter &amp;&amp; m._type == typ &#123;</span><br><span class="line">                <span class="comment">// ……</span></span><br><span class="line">                </span><br><span class="line">				<span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">					unlock(&amp;ifaceLock)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> m</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 hash 表中没有找到 itab，那么新生成一个 itab</span></span><br><span class="line">	m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="type">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*sys.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</span><br><span class="line">	m.inter = inter</span><br><span class="line">    m._type = typ</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到全局的 hash 表中</span></span><br><span class="line">	additab(m, <span class="literal">true</span>, canfail)</span><br><span class="line">	unlock(&amp;ifaceLock)</span><br><span class="line">	<span class="keyword">if</span> m.bad &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>add_itab</code> 会检查 <code>itab</code> 中的 <code>interface</code> 和 <code>_type</code> 是否符合, 然后将其添加到 hash 表中</p>
<p><strong>同时会更新 <code>itab</code> 的 <code>fun</code> 数组</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">additab</span><span class="params">(m *itab, locked, canfail <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	inter := m.inter</span><br><span class="line">	typ := m._type</span><br><span class="line">	x := typ.uncommon()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inter 和 typ 的方法都按方法名称进行了排序</span></span><br><span class="line">    <span class="comment">// 并且方法名都是唯一的。所以循环的次数是固定的</span></span><br><span class="line">    <span class="comment">// 只用循环 O(ni+nt)，而非 O(ni*nt)</span></span><br><span class="line">	ni := <span class="built_in">len</span>(inter.mhdr)</span><br><span class="line">	nt := <span class="type">int</span>(x.mcount)</span><br><span class="line">	xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="type">uintptr</span>(x.moff)))[:nt:nt]</span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</span><br><span class="line">		i := &amp;inter.mhdr[k]</span><br><span class="line">		itype := inter.typ.typeOff(i.ityp)</span><br><span class="line">		name := inter.typ.nameOff(i.name)</span><br><span class="line">		iname := name.name()</span><br><span class="line">		ipkg := name.pkgPath()</span><br><span class="line">		<span class="keyword">if</span> ipkg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			ipkg = inter.pkgpath.name()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">			t := &amp;xmhdr[j]</span><br><span class="line">            tname := typ.nameOff(t.name)</span><br><span class="line">            <span class="comment">// 检查方法名字是否一致</span></span><br><span class="line">			<span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">				pkgPath := tname.pkgPath()</span><br><span class="line">				<span class="keyword">if</span> pkgPath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">					pkgPath = typ.nameOff(x.pkgpath).name()</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">					<span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取函数地址，并加入到itab.fun数组中</span></span><br><span class="line">						ifn := typ.textOff(t.ifn)</span><br><span class="line">						*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="type">uintptr</span>(k)*sys.PtrSize)) = ifn</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">goto</span> nextimethod</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        </span><br><span class="line">		m.bad = <span class="literal">true</span>	<span class="comment">// typ 不能包含 inter 中的所有方法</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	nextimethod:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !locked &#123;</span><br><span class="line">		throw(<span class="string">&quot;invalid itab locking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash 值</span></span><br><span class="line">    h := itabhash(inter, typ)</span><br><span class="line">    <span class="comment">// 加到Hash Slot链表中</span></span><br><span class="line">	m.link = hash[h]</span><br><span class="line">	m.inhash = <span class="literal">true</span></span><br><span class="line">	atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabhash</span><span class="params">(inter *interfacetype, typ *_type)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">	h := inter.typ.hash</span><br><span class="line">	h += <span class="number">17</span> * typ.hash</span><br><span class="line">	<span class="keyword">return</span> h % hashSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更一般的. 当把实体类型赋值给接口的时候, 会调用 <code>conv</code> 系列函数, 例如空接口调用 <code>convT2E</code> 系列, 非空接口调用 <code>convT2I</code> 系列. 这些函数比较相似:</p>
<ol>
<li>具体类型转空接口时, _type 字段直接复制源类型的 _type; 调用 mallocgc 获得一块新内存, 把值复制进去, data 再指向这块新内存.</li>
<li>具体类型转非空接口时, <strong>入参 tab 是编译器在编译阶段预先生成好的</strong>, 新接口 tab 字段直接指向入参 tab 指向的 itab; 调用 mallocgc 获得一块新内存, 把值复制进去, data 再指向这块新内存.</li>
<li>而对于接口转接口, <strong>itab 调用 getitab 函数获取. 只用生成一次, 之后直接从 hash 表中获取</strong>.</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol>
<li>一种类型具有多种类型的能力</li>
<li>允许不同的对象对同一消息做出灵活的反应</li>
<li>以一种通用的方式对待个使用的对象</li>
<li>非动态语言必须通过继承和接口的方式来实现</li>
</ol>
<p>go 通过 interface 实现多态</p>
<p>C++ 和 Go 在定义接口方式上的不同, 也导致了底层实现上的不同. </p>
<ul>
<li>C++ 通过虚函数表来实现基类调用派生类的函数; </li>
<li>而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数. </li>
<li>C++ 中的虚函数表是在编译期生成的; </li>
<li>而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在运行期间动态生成的. </li>
<li>原因在于, Go 中实体类型可能会无意中实现 N 多接口, 很多接口并不是本来需要的, 所以不能为类型实现的所有接口都生成一个 <code>itab</code>, 这也是”非侵入式”带来的影响; </li>
<li>但 C++ 是”侵入式”的, 派生需要显示声明它继承自哪个基类, 因此 C++ 可以编译时就生成虚函数表</li>
</ul>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>CSP 定义了输入输出语句, 用于 processes 间的通信(communication). processes 被认为是需要输入驱动, 并且产生输出, 供其他 processes 消费, processes 可以是进程, 线程, 甚至是代码块. 输入命令是: !, 用来向 processes 写入; 输出是: ?, 用来从 processes 读出.</p>
<h2 id="Channel-数据结构"><a href="#Channel-数据结构" class="headerlink" title="Channel 数据结构"></a>Channel 数据结构</h2><p><em>buf</em> 为底层循环数组, 只有缓冲型的 channel 才有; <em>sendx</em> 和 <em>recvx</em> 指向底层循环数组, 分别为数组的写端和读端.</p>
<p><em>sendq</em> 和 <em>recvq</em> 表示被阻塞的 goroutine, 这些 goroutine 分别因为发送和接收被阻塞.</p>
<p><em>qcount</em> 和 <em>dataqsiz</em> 分别表示 chan 里元素的数量和总数量.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// chan 里元素数量</span></span><br><span class="line">	qcount   <span class="type">uint</span></span><br><span class="line">	<span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">	dataqsiz <span class="type">uint</span></span><br><span class="line">	<span class="comment">// 指向底层循环数组的指针, 只针对有缓冲的 channel</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	<span class="comment">// chan 中元素大小</span></span><br><span class="line">	elemsize <span class="type">uint16</span></span><br><span class="line">	<span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">	<span class="comment">// chan 中元素类型</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	<span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	<span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	<span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	<span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">	<span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sudog 是对 goroutine 的封装</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Channel-的操作"><a href="#Channel-的操作" class="headerlink" title="Channel 的操作"></a>Channel 的操作</h2><h3 id="Channel-的创建"><a href="#Channel-的创建" class="headerlink" title="Channel 的创建"></a>Channel 的创建</h3><p>创建 channel 的函数为 <code>makechan</code>: </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan</span><br></pre></td></tr></table></figure>

<p>创建的 channel 是一个指针, 因此可以在函数之间直接传递 channel, 而不需要传递 channel 的指针.</p>
<p>其中, 创建channel的时候:</p>
<ul>
<li>如果元素类型不含有指针或 size 大小为 0, 则只进行一次内存分配. 即展开 buf, 将buf所需的内存空间分配在 hchan 数据结构的末尾, 不另外分配 buf. 最后再让 buf 指向那个位置即可(类似于variable-sized array的思想)</li>
<li>其他情况下, 需要正常分配数据, 即先为 hchan 分配内存, 再为 hchan 中的 buf 分配内存.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="type">uintptr</span>(-<span class="type">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略了检查 channel size，align 的代码</span></span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="comment">// 如果元素类型不含指针, 或者 size 大小为 0(无缓冲类型), 则只进行一次内存分配</span></span><br><span class="line">	<span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素</span></span><br><span class="line">		<span class="comment">// 只分配 &quot;hchan 结构体大小 + 元素大小*个数&quot; 的内存</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+<span class="type">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct&#123;&#125;）</span></span><br><span class="line">		<span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">			c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// race detector uses this location for synchronization</span></span><br><span class="line">			<span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">			<span class="comment">// 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处</span></span><br><span class="line">			<span class="comment">// 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct&#123;&#125;，也无影响</span></span><br><span class="line">			<span class="comment">// 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）</span></span><br><span class="line">			c.buf = unsafe.Pointer(c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 进行两次内存分配操作</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = newarray(elem, <span class="type">int</span>(size))</span><br><span class="line">	&#125;</span><br><span class="line">	c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	<span class="comment">// 循环数组长度</span></span><br><span class="line">	c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 hchan 指针</span></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel-的发送"><a href="#Channel-的发送" class="headerlink" title="Channel 的发送"></a>Channel 的发送</h3><p>channel 发送的流程如下:</p>
<ol>
<li><p>检查发送是否合法操作</p>
<ul>
<li><p>如果 channel 为 nil, 直接返回 false</p>
</li>
<li><p>如果 channel 已关闭, 向关闭的 channel 发送消息会导致 panic</p>
</li>
<li><p>如果(没有关闭的) channel 的 send 操作处于<strong>非阻塞模式</strong>, 且发生了下面的情况, 则直接返回 false, 因为如果发生了下面的情况, 就需要阻塞才能完成发送, 这里直接判断并快速返回节省了时间.</p>
<ul>
<li>channel 是非缓冲型的, 但是等待接收队列里没有 goroutine</li>
<li>channel 是缓冲型的，但循环数组已经装满了元素</li>
</ul>
</li>
</ul>
</li>
<li><p>发送数据且没有阻塞</p>
<ul>
<li><p>接下来如果接收队列不为空的话, 就从接收队列取出一个 goroutine 并向其发送数据, 最后返回 true.</p>
</li>
<li><p>如果接收队列为空, 但是缓冲区还没有满, 则向缓冲区写入一个数据.</p>
</li>
</ul>
</li>
<li><p>如果需要阻塞时</p>
<ul>
<li>block 为 false 时, 表示不需要阻塞, 这个时候直接返回 false 表示发送失败.</li>
<li>构造一个 sudog 用来表示当前的 goroutine</li>
<li>将当前的 sudog 加入等待发送队列 sendq, 挂起当前的 goroutine</li>
</ul>
</li>
<li><p>挂起的 goroutine 被唤醒后</p>
<ul>
<li>发送元素</li>
<li>如果此时 channel 被关闭了则 panic</li>
</ul>
</li>
</ol>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 如果 channel 是 nil</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 不能阻塞，直接返回 false，表示未发送成功</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">&quot;chan send (nil chan)&quot;</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略 debug 相关……</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于不阻塞的 send，快速检测失败场景</span></span><br><span class="line">	<span class="comment">// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：</span></span><br><span class="line">	<span class="comment">// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine</span></span><br><span class="line">	<span class="comment">// 2. channel 是缓冲型的，但循环数组已经装满了元素</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">		(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 锁住 channel，并发安全</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 channel 关闭了</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="comment">// 直接 panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于缓冲型的 channel，如果还有缓冲空间</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// qp 指向 buf 的 sendx 位置</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将数据从 ep 处拷贝到 qp</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		<span class="comment">// 发送游标值加 1</span></span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="comment">// 如果发送游标值等于容量值，游标值归 0</span></span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 缓冲区的元素数量加一</span></span><br><span class="line">		c.qcount++</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不需要阻塞，则直接返回错误</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// channel 满了，发送方会被阻塞。接下来会构造一个 sudog</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前 goroutine 的指针</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 goroutine 进入发送等待队列</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">&quot;chan send&quot;</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从这里开始被唤醒了（channel 有机会可以发送了）</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 被唤醒后，channel 关闭了。坑爹啊，panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 去掉 mysg 上绑定的 channel</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中, 下面的判断语句是为了在<strong>不阻塞发送</strong>的场景下<strong>快速检测到发送失败</strong>, 好<strong>快速返回</strong>.</p>
<p>这一句话不需要加锁. 这一个判断语句涉及到了 5 个变量: block, c.closed, c.datasiz, c.recv.first, c.qcount. 其中 block 不是共享变量, c.datasiz 是只读变量. 因此真正的共享变量有 c.closed, c.recv.first, c.qcount</p>
<p>这个 if 语句进行了两次 observation: 观测 channel 是否 closed, 以及观测是否 ready for sending. 即使在两次观测之间, channel 被 close 了, 也不会影响这个优化的正确性. 因为 close 一个 channel 不会影响 ready for sending 的性质. 如果我们观察到了 not ready for sending, 我们可以推断 channel 还没有被关闭.</p>
<p>目的: 少获取一次锁, 提升性能.</p>
<blockquote>
<p>这段代码是用来实现 golang channel 的非阻塞发送操作的。它的目的是在不获取锁的情况下，快速判断 channel 是否可以发送数据，如果不可以，就返回 false。这样可以避免频繁地竞争锁，提高性能。</p>
<p>这段代码的关键是利用了两个观察项：channel 是否关闭，和 channel 是否 ready for sending。这两个观察项都是通过读取 channel 的一些字段来判断的，比如 c.closed, c.recvq.first, c.qcount 等。这些字段可能会被其他 goroutine 修改，所以有可能出现观测前后不一致的情况。</p>
<p>但是，作者发现了一个重要的性质：一个 closed channel 不能将 channel 状态从 ‘ready for sending’ 变成 ‘not ready for sending’(<strong>因为不能向关闭的 channel 发送数据</strong>)。也就是说，如果我们先观测到 channel 是未关闭的，并且没有空间或者没有接收者来接收数据（即 not ready for sending），那么即使后来 channel 被关闭了，我们也可以安全地返回 false，因为我们没有错过任何发送数据的机会。</p>
<p>反之，如果我们先观测到 channel 是 ready for sending 的，并且未关闭的，那么即使后来 channel 被关闭了或者变成 not ready for sending 了，我们也可以安全地继续执行发送操作，因为我们已经拿到了发送数据的资格。</p>
<p>所以，在这种情况下，不加锁并不会影响正确性。当然，在其他情况下（比如阻塞发送或者接收操作），还是需要加锁来保证同步和原子性的。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) || (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>goroutine 之间互相发送数据的函数. 这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者, 提高了效率</p>
<p>然后，解锁、唤醒接收者，等待调度器的光临，可以继续执行接收操作之后的代码了。其中待发送的元素的地址位于 sudog 中(sudog.elem 指示了待发送元素的地址), 因此在 recv 函数中会被取出.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// send 函数处理向一个空的 channel 发送操作</span></span><br><span class="line"><span class="comment">// ep 指向被发送的元素，会被直接拷贝到接收的 goroutine</span></span><br><span class="line"><span class="comment">// 之后，接收的 goroutine 会被唤醒</span></span><br><span class="line"><span class="comment">// c 必须是空的（因为等待队列里有 goroutine，肯定是空的）</span></span><br><span class="line"><span class="comment">// c 必须被上锁，发送操作执行完后，会使用 unlockf 函数解锁</span></span><br><span class="line"><span class="comment">// sg 必须已经从等待队列里取出来了</span></span><br><span class="line"><span class="comment">// ep 必须是非空，并且它指向堆或调用者的栈</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 省略一些用不到的</span></span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// sg.elem 指向接收到的值存放的位置，如 val &lt;- ch，指的就是 &amp;val</span></span><br><span class="line">	<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 直接拷贝内存（从发送者到接收者）</span></span><br><span class="line">		sendDirect(c.elemtype, sg, ep)</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// sudog 上绑定的 goroutine</span></span><br><span class="line">	gp := sg.g</span><br><span class="line">	<span class="comment">// 解锁</span></span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">		sg.releasetime = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 唤醒接收的 goroutine. skip 和打印栈相关，暂时不理会</span></span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 向一个非缓冲型的 channel 发送数据、从一个无元素的（非缓冲型或缓冲型但空）的 channel</span></span><br><span class="line"><span class="comment">// 接收数据，都会导致一个 goroutine 直接操作另一个 goroutine 的栈</span></span><br><span class="line"><span class="comment">// 由于 GC 假设对栈的写操作只能发生在 goroutine 正在运行中并且由当前 goroutine 来写</span></span><br><span class="line"><span class="comment">// 所以这里实际上违反了这个假设。可能会造成一些问题，所以需要用到写屏障来规避</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接进行内存&quot;搬迁&quot;</span></span><br><span class="line">	<span class="comment">// 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后</span></span><br><span class="line">	<span class="comment">// 就不能修改真正的 dst 位置的值了</span></span><br><span class="line">	<span class="comment">// 因此需要在读和写之前加上一个屏障</span></span><br><span class="line">	dst := sg.elem</span><br><span class="line">	typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">	memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel-的接收"><a href="#Channel-的接收" class="headerlink" title="Channel 的接收"></a>Channel 的接收</h3><p>根据是否为 <code>comma-ok</code> 的写法, channel 的接收被分别编译为下面两个函数. 如果代码忽略了接受值, 那么 elem 参数为 nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry points for &lt;- c from compiled code</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">	_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>channel 的接收流程如下:</p>
<ol>
<li><h2 id="检查接收是否合法-如果从一个-nil-channel-中接受-不阻塞情况返回-false-false-如果阻塞-则调用-gopark-函数将当前的-goroutine-挂起-在非阻塞情况下-快速检测到失败-直接返回-false-false-失败情况包含"><a href="#检查接收是否合法-如果从一个-nil-channel-中接受-不阻塞情况返回-false-false-如果阻塞-则调用-gopark-函数将当前的-goroutine-挂起-在非阻塞情况下-快速检测到失败-直接返回-false-false-失败情况包含" class="headerlink" title="检查接收是否合法- 如果从一个 nil channel 中接受, 不阻塞情况返回(false, false), 如果阻塞, 则调用 gopark 函数将当前的 goroutine 挂起.- 在非阻塞情况下, 快速检测到失败, 直接返回(false, false)  - 失败情况包含: "></a>检查接收是否合法<br>- 如果从一个 nil channel 中接受, 不阻塞情况返回(false, false), 如果阻塞, 则调用 <code>gopark</code> 函数将当前的 goroutine 挂起.<br>- 在非阻塞情况下, 快速检测到失败, 直接返回(false, false)<br>  - 失败情况包含: </h2></li>
<li>获取锁并尝试获取数据<ul>
<li>如果当前的 channel 被关闭, 且 buf 中没有元素, 则返回(true, false)</li>
<li>sendq 队列中不为空, 则取出一个 goroutine 并从中接收数据最后返回(true, true)</li>
<li>若 buf 不为空, 则从 buf 中取出一个数据并返回(true, true)</li>
</ul>
</li>
<li>如果需要阻塞时<ul>
<li>block 为 false 的时候, 直接返回(false, false)</li>
<li>构造一个 sudog 用来表示当前的 goroutine</li>
<li>将当前的 sudog 加入等待发送队列 recvq, 挂起当前的 goroutine</li>
</ul>
</li>
<li>阻塞被解除时<ul>
<li>释放申请的 sudog</li>
<li>返回 (true, !closed)</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位于 src/runtime/chan.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。</span></span><br><span class="line"><span class="comment">// 如果 ep 是 nil，说明忽略了接收值。</span></span><br><span class="line"><span class="comment">// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)</span></span><br><span class="line"><span class="comment">// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)</span></span><br><span class="line"><span class="comment">// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)</span></span><br><span class="line"><span class="comment">// 如果 ep 非空，则应该指向堆或者函数调用者的栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 省略 debug 内容 …………</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是一个 nil 的 channel</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则，接收一个 nil 的 channel，goroutine 挂起</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">&quot;chan receive (nil chan)&quot;</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		<span class="comment">// 不会执行到这里</span></span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回</span></span><br><span class="line">	<span class="comment">// 当我们观察到 channel 没准备好接收：</span></span><br><span class="line">	<span class="comment">// 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待</span></span><br><span class="line">	<span class="comment">// 2. 缓冲型，但 buf 里没有元素</span></span><br><span class="line">	<span class="comment">// 之后，又观察到 closed == 0，即 channel 未关闭。</span></span><br><span class="line">	<span class="comment">// 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，</span></span><br><span class="line">	<span class="comment">// 因此在这种情况下可以直接宣布接收失败，返回 (false, false)</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">		c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// channel 已关闭，并且循环数组 buf 里没有元素</span></span><br><span class="line">	<span class="comment">// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况</span></span><br><span class="line">	<span class="comment">// 也就是说即使是关闭状态，但在缓冲型的 channel，</span></span><br><span class="line">	<span class="comment">// buf 里有元素的情况下还能接收到元素</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 从一个已关闭的 channel 执行接收操作，且未忽略返回值</span></span><br><span class="line">			<span class="comment">// 那么接收的值将是一个该类型的零值</span></span><br><span class="line">			<span class="comment">// typedmemclr 根据类型清理相应地址的内存</span></span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从一个已关闭的 channel 接收，selected 会返回true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待发送队列里有 goroutine 存在，说明 buf 是满的</span></span><br><span class="line">	<span class="comment">// 这有可能是：</span></span><br><span class="line">	<span class="comment">// 1. 非缓冲型的 channel</span></span><br><span class="line">	<span class="comment">// 2. 缓冲型的 channel，但 buf 满了</span></span><br><span class="line">	<span class="comment">// 针对 1，直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line">	<span class="comment">// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">		<span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">		<span class="comment">// and add sender&#x27;s value to the tail of the queue (both map to</span></span><br><span class="line">		<span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲型，buf 里有元素，可以正常接收</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 直接从循环数组里找到要接收的元素</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// …………</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 代码里，没有忽略要接收的值，不是 &quot;&lt;- ch&quot;，而是 &quot;val &lt;- ch&quot;，ep 指向 val</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		<span class="comment">// 接收游标向前移动</span></span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="comment">// 接收游标归零</span></span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// buf 数组里的元素个数减 1</span></span><br><span class="line">		c.qcount--</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		<span class="comment">// 非阻塞接收，解锁。selected 返回 false，因为没有接收到值</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来就是要被阻塞的情况了</span></span><br><span class="line">	<span class="comment">// 构造一个 sudog</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 待接收数据的地址保存下来</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="comment">// 进入channel 的等待接收队列</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	<span class="comment">// 将当前 goroutine 挂起</span></span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">&quot;chan receive&quot;</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 被唤醒了，接着从这里继续执行一些扫尾工作</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 recv 函数: 如果是非缓冲类型的 channel, 直接将 sender goroutine 中取出元素并赋值给接收变量</p>
<p>如果跟是缓冲类 channel, 则读出 buf 中的一个元素, 再将 sender goroutine 中的元素复制到 buf 中</p>
<p>最后唤醒 sender goroutine.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果是非缓冲型的 channel</span></span><br><span class="line">	<span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			racesync(c, sg)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 未忽略接收的数据</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 直接拷贝数据，从 sender goroutine -&gt; receiver goroutine</span></span><br><span class="line">			recvDirect(c.elemtype, sg, ep)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 缓冲型的 channel，但 buf 已满。</span></span><br><span class="line">		<span class="comment">// 将循环数组 buf 队首的元素拷贝到接收数据的地址</span></span><br><span class="line">		<span class="comment">// 将发送者的数据入队。实际上这时 revx 和 sendx 值相等</span></span><br><span class="line">		<span class="comment">// 找到接收游标</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="comment">// …………</span></span><br><span class="line">		<span class="comment">// 将接收游标处的数据拷贝给接收者</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将发送者数据拷贝到 buf</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">		<span class="comment">// 更新游标值</span></span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.sendx = c.recvx</span><br><span class="line">	&#125;</span><br><span class="line">	sg.elem = <span class="literal">nil</span></span><br><span class="line">	gp := sg.g</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解锁</span></span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">		sg.releasetime = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 唤醒发送的 goroutine。需要等到调度器的光临</span></span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// dst is on our stack or the heap, src is on another stack.</span></span><br><span class="line">	src := sg.elem</span><br><span class="line">	typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">	memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel-的关闭"><a href="#Channel-的关闭" class="headerlink" title="Channel 的关闭"></a>Channel 的关闭</h3><p><code>closechan</code> 函数的过程: </p>
<ul>
<li>如果 channel 是 nil 或 channel 已经被关闭, 则直接 panic</li>
<li>锁住 channel, 然后将 c.closed 设置成 1</li>
<li>将 channel 中的 sendq 和 recvq 队列中的 goroutine 全部取出并放到一个链表中, 之后解锁 channel</li>
<li>将链表中的 sudog 代表的 goroutine 全部唤醒, 其中 sender goroutine 会导致panic, receiver goroutine 则会释放sudog, 并返回(true, false).<ul>
<li>关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接 panic. 所以在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel.</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 关闭一个 nil channel，panic</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上锁</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="comment">// 如果 channel 已经关闭</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="comment">// panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// …………</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改关闭状态</span></span><br><span class="line">	c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> glist *g</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 channel 所有等待接收队列的里 sudog 释放</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 从接收队列里出队一个 sudog</span></span><br><span class="line">		sg := c.recvq.dequeue()</span><br><span class="line">		<span class="comment">// 出队完毕，跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果 elem 不为空，说明此 receiver 未忽略接收数据</span></span><br><span class="line">		<span class="comment">// 给它赋一个相应类型的零值</span></span><br><span class="line">		<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 取出 goroutine</span></span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 相连，形成链表</span></span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 channel 等待发送队列里的 sudog 释放</span></span><br><span class="line">	<span class="comment">// 如果存在，这些 goroutine 将会 panic</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 从发送队列里出队一个 sudog</span></span><br><span class="line">		sg := c.sendq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送者会 panic</span></span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 形成链表</span></span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解锁</span></span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line">	<span class="comment">// 遍历链表</span></span><br><span class="line">	<span class="keyword">for</span> glist != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 取最后一个</span></span><br><span class="line">		gp := glist</span><br><span class="line">		<span class="comment">// 向前走一步，下一个唤醒的 g</span></span><br><span class="line">		glist = glist.schedlink.ptr()</span><br><span class="line">		gp.schedlink = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 唤醒相应 goroutine</span></span><br><span class="line">		goready(gp, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Channel-的特性"><a href="#Channel-的特性" class="headerlink" title="Channel 的特性"></a>Channel 的特性</h2><h3 id="Channel-的优雅关闭"><a href="#Channel-的优雅关闭" class="headerlink" title="Channel 的优雅关闭"></a>Channel 的优雅关闭</h3><p>关于 channel 的使用，有几点不方便的地方:</p>
<ol>
<li>在不改变 channel 自身状态的情况下, <strong>无法获知一个 channel 是否关闭</strong>.</li>
<li>关闭一个 closed channel 会导致 panic. 所以, <strong>如果关闭 channel 的一方在不知道 channel 是否处于关闭状态时就去贸然关闭 channel 是很危险的事情</strong>.</li>
<li>向一个 closed channel 发送数据会导致 panic. 所以, <strong>如果向 channel 发送数据的一方不知道 channel 是否处于关闭状态时就去贸然向 channel 发送数据是很危险的事情</strong>.</li>
</ol>
<p><strong>关闭 channel 的原则</strong>: </p>
<ul>
<li>不要从一个 receiver 侧关闭 channel</li>
<li>不要在有多个 sender 时, 关闭 channel</li>
</ul>
<p>两个关闭 channel 的可行(但不优雅的)方法:</p>
<ul>
<li>使用 defer-recover 机制</li>
<li>使用 sync.Once 保证关闭一次</li>
</ul>
<hr>
<p>优雅的关闭 channel:</p>
<p>根据 sender 和 receiver 的数量可以分为以下四种情况</p>
<ol>
<li>1 sender, 1 receiver</li>
<li>1 sender, n receiver</li>
<li>n sender, 1 receiver</li>
<li>m sender, n receiver</li>
</ol>
<p>对于情况 1, 2: 直接在 sender 侧关闭即可.</p>
<p>对于情况 3: the only receiver says “please stop sending more” <strong>by closing an additional signal channel</strong>.</p>
<p>下面的代码并没有明确关闭 dataCh. 在 Go 语言中, 对于一个 channel, 如果最终没有任何 goroutine 引用它, 不管 channel 有没有被关闭, 最终都会被 gc 回收. 所以, 在这种情形下, 所谓的优雅地关闭 channel 就是不关闭 channel, 让 gc 代劳.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="number">0</span></span><br><span class="line">    numSenders := <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// n senders</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- data:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 receiver</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            fmt.Println(value)</span><br><span class="line">            <span class="keyword">if</span> value == <span class="number">10</span> &#123;</span><br><span class="line">                <span class="built_in">close</span>(stopCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;- time.After(time.Hour):</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于情况 4, 优雅关闭 channel 的方法是: any one of them says “let’s end the game” by notifying a moderator to close an additional signal channel.</p>
<p>和第 3 种情况不同, 这里有 M 个 receiver, 如果直接还是采取第 3 种解决方案, 由 receiver 直接关闭 stopCh 的话, 就会重复关闭一个 channel, 导致 panic. 因此需要增加一个中间人, M 个 receiver 都向它发送关闭 dataCh 的”请求”, 中间人收到第一个请求后, 就会直接下达关闭 dataCh 的指令(通过关闭 stopCh, 这时就不会发生重复关闭的情况, 因为 stopCh 的发送方只有中间人一个). 另外, 这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Max = <span class="number">100000</span></span><br><span class="line">	<span class="keyword">const</span> NumReceivers = <span class="number">10</span></span><br><span class="line">	<span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">	dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// It must be a buffered channel.</span></span><br><span class="line">	toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// if the capacity is set to NumSenders+NumReceivers, </span></span><br><span class="line">    <span class="comment">// then there is no need for select statement when sending message to toStop chanel</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">var</span> stoppedBy <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// moderator (stopCh can only closed by moderator)</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		stoppedBy = &lt;-toStop</span><br><span class="line">		<span class="built_in">close</span>(stopCh)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// senders</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				value := rand.Intn(Max)</span><br><span class="line">				<span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id:</span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// receivers</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">					<span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">						<span class="keyword">select</span> &#123;</span><br><span class="line">						<span class="keyword">case</span> toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id:</span><br><span class="line">						<span class="keyword">default</span>:</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					fmt.Println(value)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;- time.After(time.Hour):</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>principles: </p>
<ul>
<li>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.</li>
<li>don’t close (or send values to) closed channels.</li>
</ul>
<h3 id="Channel-传递数据的本质"><a href="#Channel-传递数据的本质" class="headerlink" title="Channel 传递数据的本质"></a>Channel 传递数据的本质</h3><p>Remember all transfer of value on the go channels happens with the copy of value.</p>
<h3 id="Channel-引发-Goroutine-泄露"><a href="#Channel-引发-Goroutine-泄露" class="headerlink" title="Channel 引发 Goroutine 泄露"></a>Channel 引发 Goroutine 泄露</h3><p>泄漏的原因是 goroutine 操作 channel 后, 处于发送或接收阻塞状态, 而 channel 处于满或空的状态, 一直得不到改变.</p>
<p>原因是 goroutine 被 channel 引用, 因此得不到释放, channel所在的 goroutine 也被阻塞, channel 也不会被释放.</p>
<h3 id="Channel-中的-happen-before"><a href="#Channel-中的-happen-before" class="headerlink" title="Channel 中的 happen-before"></a>Channel 中的 happen-before</h3><p>send, send-finished, receive, receive-finished 存在下面的关系:</p>
<ol>
<li>第 n 个 <code>send</code> 一定 <code>happened before</code> 第 n 个 <code>receive finished</code>, 无论是缓冲型还是非缓冲型的 channel.</li>
<li>对于容量为 m 的缓冲型 channel, 第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n+m 个 <code>send finished</code>.</li>
<li>对于非缓冲型的 channel, 第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n 个 <code>send finished</code>.</li>
<li>channel close 一定 <code>happened before</code> receiver 得到通知</li>
</ol>
<h2 id="Channel-的应用"><a href="#Channel-的应用" class="headerlink" title="Channel 的应用"></a>Channel 的应用</h2><h3 id="停止信号"><a href="#停止信号" class="headerlink" title="停止信号"></a>停止信号</h3><p>同 “Channel 的优雅关闭” 一节</p>
<h3 id="任务定时"><a href="#任务定时" class="headerlink" title="任务定时"></a>任务定时</h3><p>超时控制</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">    <span class="keyword">case</span> &lt;-stopc:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.Ticker(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker:</span><br><span class="line">            fmt.Println(<span class="string">&quot;do work&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解耦生产方和消费方"><a href="#解耦生产方和消费方" class="headerlink" title="解耦生产方和消费方"></a>解耦生产方和消费方</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	taskCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(taskCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 塞任务</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		taskCh &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 1 小时 </span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Hour):</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(taskCh &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> N = <span class="number">5</span></span><br><span class="line">	<span class="comment">// 启动 5 个工作协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				task := &lt;- taskCh</span><br><span class="line">				fmt.Printf(<span class="string">&quot;finish task: %d by worker %d\n&quot;</span>, task, id)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h3><p>limit 放在函数内的原因:</p>
<ul>
<li>如果在外层, 就是控制系统 goroutine 的数量, 可能会阻塞 for 循环, 影响业务逻辑.</li>
<li>limit 与逻辑无关, 而只是性能调优, 放在外层和内层的语义不一样.</li>
</ul>
<p>注意: 如果 <code>w()</code> 发生 panic, 则 limit 则收不回去了, 需要通过defer来保证一定会收回去.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            limit &lt;- <span class="number">1</span></span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-limit &#125;() <span class="comment">// 防止 panic</span></span><br><span class="line">            w()</span><br><span class="line">            <span class="comment">// &lt;-limit</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><h2 id="Context-的作用"><a href="#Context-的作用" class="headerlink" title="Context 的作用"></a>Context 的作用</h2><p>context 主要用来在 goroutine 之间传递上下文信息, 包括取消信号, 超时时间, 截止时间, k-v 等</p>
<p>context.Context 类型的值可以协调多个 groutine 中的代码执行”取消”操作，并且可以存储键值对. 重要的是它是<strong>并发安全</strong>的。</p>
<p>Context的作用: 当<strong>请求被取消或是处理时间太长</strong>, 这有可能是使用者关闭了浏览器或是已经<strong>超过了请求方规定的超时时间</strong>, <strong>请求方直接放弃了这次请求结果</strong>. 这时, 所有正在为这个请求工作的 goroutine 需要快速退出, 因为它们的”工作成果”不再被需要了. 在相关联的 goroutine 都退出后, 系统就可以回收相关的资源.</p>
<p>总结: context 用来解决 goroutine 之间<code>退出通知</code>, <code>元数据传递</code>的功能</p>
<p><img src="https://golang.design/go-questions/stdlib/context/assets/0.png" alt="request"></p>
<h2 id="Context-的使用"><a href="#Context-的使用" class="headerlink" title="Context 的使用"></a>Context 的使用</h2><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><p>创建根节点的函数 <code>Background()</code>, background 是一个空的 context, 它不能被取消, 没有值, 没有超时时间.</p>
<p>创建子节点的函数有以下四个: </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure>

<p>使用 Context 的四条建议: </p>
<ol>
<li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx.</li>
<li>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use.</li>
<li>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</li>
<li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</li>
</ol>
<h3 id="传递共享的数据"><a href="#传递共享的数据" class="headerlink" title="传递共享的数据"></a>传递共享的数据</h3><p>对于 Web 服务端开发, 往往希望将一个请求处理的整个过程串起来, 这就非常依赖于 Thread Local(对于 Go 可理解为单个协程所独有, 而不需要依赖全局变量或参数传递)的变量, 而在 Go 语言中并没有这个概念, 因此需要在函数调用的时候传递 context(将 context 用于传递协程内定义的局部变量).</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRequestID</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        reqID := r.Header().Get(<span class="string">&quot;X-Request-ID&quot;</span>)</span><br><span class="line">        ctx := context.WithValue(r.Context(), requestIDKey, reqID)</span><br><span class="line">        r := r.WithContext(ctx)</span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRequestID</span><span class="params">(ctx context.Context)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.Value(requestIDKey).(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    reqID := GetRequestID(r.Context())</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := WithRequestID(Handle)</span><br><span class="line">    http.ListenAndServer(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消-goroutine"><a href="#取消-goroutine" class="headerlink" title="取消 goroutine"></a>取消 goroutine</h3><p>WithTimeOut 函数返回的 context 和 cancelFun 是分开的. context 本身并没有取消函数, 这样做的原因是取消函数只能由外层函数调用, 防止子节点 context 调用取消函数, 从而严格控制信息的流向: <strong>由父节点 context 流向子节点 context</strong></p>
<h3 id="防止-goroutine-泄露"><a href="#防止-goroutine-泄露" class="headerlink" title="防止 goroutine 泄露"></a>防止 goroutine 泄露</h3><p>下面的程序会一直产生自然数. 如果我们只在取它产生的前 5 个数, 就会产生 goroutine 泄露.</p>
<p>当 n &#x3D;&#x3D; 5 的时候, 直接 break 掉. 那么 gen 函数的协程就会执行无限阻塞, 无法被 gc 回收. 发生了 goroutine 泄漏.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- n</span><br><span class="line">			n++</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> gen() &#123;</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止 goroutine 泄露, 就需要使用 context 改进, 用 context 传递取消信息.</p>
<p>注意: 重复调用 <code>cancel</code> 函数不影响, 因此可以用 <code>defer cancel()</code> 实现 defensive programming.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            	<span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> ch &lt;- n:</span><br><span class="line">                n++</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancel() <span class="comment">// 避免其他地方忘记 cancel，且重复调用不影响</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">			cancel()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="context-Value-查找过程"><a href="#context-Value-查找过程" class="headerlink" title="context.Value 查找过程"></a>context.Value 查找过程</h2><h3 id="valueCtx-的结构"><a href="#valueCtx-的结构" class="headerlink" title="valueCtx 的结构"></a>valueCtx 的结构</h3><p>valueCtx 只实现了 <code>Done()</code> 和 <code>String()</code> 两个函数, 但是它内嵌了一个 Context 结构体, 因此继承了 Context 的方法, 因此 valueCtx 也实现了 Context 接口.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    </span><br><span class="line">    key, value any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="valueCtx-的创建"><a href="#valueCtx-的创建" class="headerlink" title="valueCtx 的创建"></a>valueCtx 的创建</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="value-的查找"><a href="#value-的查找" class="headerlink" title="value 的查找"></a>value 的查找</h3><p>递归查找: 首先在本届点查找, 如果没有查找到, 则递归向父结点查找. 类似一个反向的链表的查找过程.</p>
<p><img src="https://golang.design/go-questions/stdlib/context/assets/2.png" alt="valueCtx"></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Context-包设计"><a href="#Context-包设计" class="headerlink" title="Context 包设计"></a>Context 包设计</h2><h3 id="Context-中的接口"><a href="#Context-中的接口" class="headerlink" title="Context 中的接口"></a>Context 中的接口</h3><p>Context 的类图如下所示:</p>
<ul>
<li>Context 是一个接口, 四个方法都是<code>幂等</code>的<ul>
<li><code>Done()</code> 返回一个 receive-only channel, channel 被关闭的时候, 说明这个 context 被取消了.</li>
<li><code>Err()</code> 返回一个error, 表示 channel 被关闭的原因, 如超时, 被取消等等.</li>
<li><code>Deadline()</code> 返回 context 的截止时间, 通过此时间, 函数就可以决定是否进行接下来的操作, 如果时间太短, 就可以不往下做了, 否则浪费系统资源. 当然, 也可以用这个 deadline 来设置一个 I&#x2F;O 操作的超时时间.</li>
<li><code>Value()</code> 获取之前设置的 key 对应的 value.</li>
</ul>
</li>
<li>canceler 是一个接口, 实现它的数据类型是可取消的. <code>*cancelCtx</code> 和 <code>*timerCtx</code> 实现了 canceler.</li>
</ul>
<p><img src="https://golang.design/go-questions/stdlib/context/assets/4.png" alt="classes"></p>
<p>设计的原因:</p>
<ul>
<li>“取消”操作应该是建议性，而非强制性<ul>
<li>caller 只向 callee 传递取消的信息, 而不强制性取消 callee</li>
</ul>
</li>
<li>“取消”操作应该可传递<ul>
<li>使用关闭 channel 的方式进行广播消息.</li>
</ul>
</li>
</ul>
<h3 id="Context-中的结构体"><a href="#Context-中的结构体" class="headerlink" title="Context 中的结构体"></a>Context 中的结构体</h3><p><strong>emptyCtx</strong>: 空的 context, 永远不会被 cancel, 不会超时, 也不存储值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)	<span class="comment">// returned by Background()</span></span><br><span class="line">    todo  	   = <span class="built_in">new</span>(emptyCtx)	<span class="comment">// returned by TODO()</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>cancelCtx</strong>: 可取消的 context, 实现了 canceler 接口, 且存在内嵌 Context.</p>
<p>Done 会返回一个 channel, 直接调用读这个 channel, 协程会被 block 住. 一般通过搭配 select 来使用. 一旦关闭, 就会立即读出零值.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex <span class="comment">// 保护之后的字段</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	err      <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazily initialize c.done channel </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    d := c.done</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来看, <code>cancel()</code> 方法的功能:</p>
<ul>
<li>关闭 channel, c.done;</li>
<li>递归地取消它的所有子节点;</li>
<li>从父节点从删除自己.</li>
</ul>
<p>达到的效果是通过关闭 channel, 将取消信号传递给了它的所有子节点. </p>
<p>goroutine 接收到取消信号的方式就是 select 语句中的 <code>&lt;-c.done</code> 被选中.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 必须要传 err</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 已经被其他协程取消</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 给 err 字段赋值</span></span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="comment">// 关闭 channel，通知其他协程</span></span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan	<span class="comment">// closedchan 是一个已经被关闭了的 channel</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历它的所有子节点</span></span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">	    <span class="comment">// 递归地取消所有子节点</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将子节点置空</span></span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">	    <span class="comment">// 从父节点中移除自己 </span></span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	p, ok := parentCancelCtx(parent)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(p.children, child)</span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建cancelCtx. 注意: WithCancel 中的 c.cancel 参数需要为 true, 但是在 cancel 函数中, 取消子节点的时候, 参数需要为false. 这是因为在 cancel 函数中, 直接将 c.children 设置为了 nil, 就不需要一个个从子节点中删除父结点中的子节点. 且边遍历边删除也可能会引发问题.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> cancelCtx &#123;</span><br><span class="line">	<span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到了可取消的父结点, 且父结点还没有取消, 将父结点的 children 集合中加上子节点.</span></span><br><span class="line"><span class="comment">// 如果没有找到可取消的父结点, 新启动一个协程监控父节点或子节点取消信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 父节点是个空节点</span></span><br><span class="line">	<span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到可以取消的父 context</span></span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 父节点已经被取消了，本节点（子节点）也要取消</span></span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 父节点未取消</span></span><br><span class="line">			<span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">				p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// &quot;挂到&quot;父节点上</span></span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果没有找到可取消的父 context。新启动一个协程监控父节点或子节点取消信号</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> c := parent.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *cancelCtx:</span><br><span class="line">			<span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> *timerCtx:</span><br><span class="line">			<span class="keyword">return</span> &amp;c.cancelCtx, <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> *valueCtx:</span><br><span class="line">			parent = c.Context</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>propagateCancel 方法的作用就是向上寻找可以”挂靠”的”可取消”的 context, 并且”挂靠”上去. 这样, 调用上层 cancel 方法的时候, 就可以层层传递, 将那些挂靠的子 context 同时”取消”.</p>
<p>propagateCancel 中如果没有找到可取消的父 context, 需要新启动一个协程监控父节点或子节点取消信号. 这是因为parentCancelCtx 函数只会识别 <code>*cancelCtx</code>, <code>*timerCtx</code> 和 <code>*valueCtx</code> 三种类型, 因此如果使用了一个结构体包装了 Context 类型, 则识别不出来. 因此如果把 ctx 强行塞进一个结构体, 并用它作为父节点, 调用 WithCancel 函数构建子节点 context 的时候, Go 会新启动一个协程来监控取消信号. 这样浪费了协程资源, 因此一般不建议把 Context 放到结构体中, 而是直接传递参数.</p>
<p><strong>timerCtx</strong>: 基于 cancelCtx, 仅仅多了 deadline 和 timer. timer 会在 deadline 到来的时候自动取消 context.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取消 timerCtx 的方法: 注意如果定时器不为 nil, 需要关闭定时器, 并将定时器设置为 nil.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 直接调用 cancelCtx 的取消方法</span></span><br><span class="line">	c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		<span class="comment">// 从父节点中删除子节点</span></span><br><span class="line">		removeChild(c.cancelCtx.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 关掉定时器，这样，在deadline 到来时，不会再次取消</span></span><br><span class="line">		c.timer.Stop()</span><br><span class="line">		c.timer = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 timerCtx 的方法:</p>
<ul>
<li>如果 deadline 晚于父结点的 deadline, 则直接返回 WithCancel(parent).</li>
<li>之后创建 timerCtx 并挂靠到父结点上.</li>
<li>如果已经超过 deadline, 则直接返回, 否则, 启动一个定时器 timer, 到达 deadline 后自动执行 cancel 函数.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(deadline) &#123;</span><br><span class="line">		<span class="comment">// 如果父节点 context 的 deadline 早于指定时间。直接构建一个可取消的 context。</span></span><br><span class="line">		<span class="comment">// 原因是一旦父节点超时，自动调用 cancel 函数，子节点也会随之取消。</span></span><br><span class="line">		<span class="comment">// 所以不用单独处理子节点的计时器时间到了之后，自动调用 cancel 函数</span></span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构建 timerCtx</span></span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  deadline,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 挂靠到父节点上</span></span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算当前距离 deadline 的时间</span></span><br><span class="line">	d := time.Until(deadline)</span><br><span class="line">	<span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 直接取消</span></span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// d 时间后，timer 会自动调用 cancel 函数。自动取消</span></span><br><span class="line">		c.timer = time.AfterFunc(d, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h3 id="Reflect-简介"><a href="#Reflect-简介" class="headerlink" title="Reflect 简介"></a>Reflect 简介</h3><p>反射是指计算机程序在运行时(Runtime)可以访问, 检测和修改它本身状态或行为的一种能力. 反射的本质是程序在运行期探知对象的类型信息和内存结构. 不用反射其实也可以实现: 使用汇编语言，直接和内层打交道，可以获取任何信息. 但是, 当编程迁移到高级语言上来之后, 就不行了, 只能通过<code>反射</code>来达到此项技能.</p>
<p>Go 语言提供了一种机制在运行时更新变量和检查它们的值, 调用它们的方法, 但是在编译时并不知道这些变量的具体类型, 这称为反射机制.</p>
<p>使用反射的场景:</p>
<ol>
<li>不能明确接口调用哪个函数, 需要根据传入的参数在运行时决定</li>
<li>不能明确传入函数的参数类型, 需要在运行时处理任意对象</li>
</ol>
<p>反射的缺点:</p>
<ul>
<li>与反射相关的代码, 经常是难以阅读的</li>
<li>Go 语言作为一门强类型静态语言, 编码过程中, 编译器能提前发现一些类型错误, 但是对于反射代码是无能为力的</li>
<li>反射对性能影响比较大, 比正常代码运行速度慢一到两个数量级</li>
</ul>
<h2 id="Go-语言反射实现"><a href="#Go-语言反射实现" class="headerlink" title="Go 语言反射实现"></a>Go 语言反射实现</h2><p>当向接口变量赋予一个实体类型的时候, 接口会存储实体的类型信息, 反射就是通过接口的类型信息实现的, 反射建立在类型的基础上.</p>
<h3 id="type-和-interface"><a href="#type-和-interface" class="headerlink" title="type 和 interface"></a>type 和 interface</h3><p>Go 语言中, 每个变量都有一个静态类型, 在编译阶段就确定了的, 比如 <code>int, float64, []int</code> 等等. 注意, 这个类型是声明时候的类型, 不是底层数据类型.</p>
<p>断言能否成功取决于动态类型是否满足.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/Users/qcrao/Desktop/test&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r = tty</span><br><span class="line"><span class="keyword">var</span> w io.Writer = r.(io.Writer)</span><br></pre></td></tr></table></figure>

<h3 id="reflect-Type"><a href="#reflect-Type" class="headerlink" title="reflect.Type"></a>reflect.Type</h3><p>reflect 包中: </p>
<ul>
<li><code>reflect.Type</code> 是一个接口, 主要提供类型相关的信息, 它和 <code>_type</code> 联系紧密</li>
<li><code>reflect.Value</code> 是一个结构体, 结合了 <code>_type</code> 和 <code>data</code> 两者, 可以通过它来修改值</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype	<span class="comment">// *rtype 实现了 Type 接口</span></span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// emptyInterface 基本上和 eface 相同.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// toType 仅仅做了类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span></span> Type &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Type 定义了很多方法:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 所有的类型都可以调用下面这些函数</span></span><br><span class="line">	<span class="comment">// 此类型的变量对齐后所占用的字节数</span></span><br><span class="line">	Align() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 如果是 struct 的字段，对齐后占用的字节数</span></span><br><span class="line">	FieldAlign() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回类型方法集里的第 `i` (传入的参数)个方法</span></span><br><span class="line">	Method(<span class="type">int</span>) Method</span><br><span class="line">	<span class="comment">// 通过名称获取方法</span></span><br><span class="line">	MethodByName(<span class="type">string</span>) (Method, <span class="type">bool</span>)</span><br><span class="line">	<span class="comment">// 获取类型方法集里导出的方法个数</span></span><br><span class="line">	NumMethod() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 类型名称</span></span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line">	<span class="comment">// 返回类型所在的路径，如：encoding/base64</span></span><br><span class="line">	PkgPath() <span class="type">string</span></span><br><span class="line">	<span class="comment">// 返回类型的大小，和 unsafe.Sizeof 功能类似</span></span><br><span class="line">	Size() <span class="type">uintptr</span></span><br><span class="line">	<span class="comment">// 返回类型的字符串表示形式</span></span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">	<span class="comment">// 返回类型的类型值</span></span><br><span class="line">	Kind() Kind</span><br><span class="line">	<span class="comment">// 类型是否实现了接口 u</span></span><br><span class="line">	Implements(u Type) <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 是否可以赋值给 u</span></span><br><span class="line">	AssignableTo(u Type) <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 是否可以类型转换成 u</span></span><br><span class="line">	ConvertibleTo(u Type) <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 类型是否可以比较</span></span><br><span class="line">	Comparable() <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 下面这些函数只有特定类型可以调用</span></span><br><span class="line">	<span class="comment">// 如：Key, Elem 两个方法就只能是 Map 类型才能调用</span></span><br><span class="line">	<span class="comment">// 类型所占据的位数</span></span><br><span class="line">	Bits() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回通道的方向，只能是 chan 类型调用</span></span><br><span class="line">	ChanDir() ChanDir</span><br><span class="line">	<span class="comment">// 返回类型是否是可变参数，只能是 func 类型调用</span></span><br><span class="line">	<span class="comment">// 比如 t 是类型 func(x int, y ... float64)</span></span><br><span class="line">	<span class="comment">// 那么 t.IsVariadic() == true</span></span><br><span class="line">	IsVariadic() <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用</span></span><br><span class="line">	Elem() Type</span><br><span class="line">	<span class="comment">// 返回结构体类型的第 i 个字段，只能是结构体类型调用</span></span><br><span class="line">	<span class="comment">// 如果 i 超过了总字段数，就会 panic</span></span><br><span class="line">	Field(i <span class="type">int</span>) StructField</span><br><span class="line">	<span class="comment">// 返回嵌套的结构体的字段</span></span><br><span class="line">	FieldByIndex(index []<span class="type">int</span>) StructField</span><br><span class="line">	<span class="comment">// 通过字段名称获取字段</span></span><br><span class="line">	FieldByName(name <span class="type">string</span>) (StructField, <span class="type">bool</span>)</span><br><span class="line">	<span class="comment">// FieldByNameFunc returns the struct field with a name</span></span><br><span class="line">	<span class="comment">// 返回名称符合 func 函数的字段</span></span><br><span class="line">	FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">bool</span>) (StructField, <span class="type">bool</span>)</span><br><span class="line">	<span class="comment">// 获取函数类型的第 i 个参数的类型</span></span><br><span class="line">	In(i <span class="type">int</span>) Type</span><br><span class="line">	<span class="comment">// 返回 map 的 key 类型，只能由类型 map 调用</span></span><br><span class="line">	Key() Type</span><br><span class="line">	<span class="comment">// 返回 Array 的长度，只能由类型 Array 调用</span></span><br><span class="line">	Len() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回类型字段的数量，只能由类型 Struct 调用</span></span><br><span class="line">	NumField() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回函数类型的输入参数个数</span></span><br><span class="line">	NumIn() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回函数类型的返回值个数</span></span><br><span class="line">	NumOut() <span class="type">int</span></span><br><span class="line">	<span class="comment">// 返回函数类型的第 i 个值的类型</span></span><br><span class="line">	Out(i <span class="type">int</span>) Type</span><br><span class="line">    <span class="comment">// 返回类型结构体的相同部分</span></span><br><span class="line">	common() *rtype</span><br><span class="line">	<span class="comment">// 返回类型结构体的不同部分</span></span><br><span class="line">	uncommon() *uncommonType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>Type</code> 方法集的倒数第二个方法 <code>common</code> 返回的 <code>rtype</code> 类型, 它和上一篇文章讲到的 <code>_type</code> 是一回事, 而且源代码里也注释了, 两边要保持同步.</p>
<p><code>Type</code> 接口实现了 <code>String()</code> 函数, 满足 <code>fmt.Stringer</code> 接口, 因此使用 <code>fmt.Println</code> 打印的时候, 输出的是 <code>String()</code> 的结果. 另外, <code>fmt.Printf()</code> 函数, 如果使用 <code>%T</code> 来作为格式参数, 输出的是 <code>reflect.TypeOf</code> 的结果, 也就是动态类型.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rtype must be kept in sync with ../runtime/type.go:/^type._type.</span></span><br><span class="line"><span class="keyword">type</span> rtype <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="type">uintptr</span></span><br><span class="line">	ptrdata    <span class="type">uintptr</span></span><br><span class="line">	hash       <span class="type">uint32</span></span><br><span class="line">	tflag      tflag</span><br><span class="line">	align      <span class="type">uint8</span></span><br><span class="line">	fieldAlign <span class="type">uint8</span></span><br><span class="line">	kind       <span class="type">uint8</span></span><br><span class="line">	alg        *typeAlg</span><br><span class="line">	gcdata     *<span class="type">byte</span></span><br><span class="line">	str        nameOff</span><br><span class="line">	ptrToThis  typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arrayType represents a fixed array type.</span></span><br><span class="line"><span class="keyword">type</span> arrayType <span class="keyword">struct</span> &#123;</span><br><span class="line">	rtype <span class="string">`reflect:&quot;array&quot;`</span></span><br><span class="line">	elem  *rtype <span class="comment">// array element type</span></span><br><span class="line">	slice *rtype <span class="comment">// slice type</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chanType represents a channel type.</span></span><br><span class="line"><span class="keyword">type</span> chanType <span class="keyword">struct</span> &#123;</span><br><span class="line">	rtype <span class="string">`reflect:&quot;chan&quot;`</span></span><br><span class="line">	elem  *rtype  <span class="comment">// channel element type</span></span><br><span class="line">	dir   <span class="type">uintptr</span> <span class="comment">// channel direction (ChanDir)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reflect-Value"><a href="#reflect-Value" class="headerlink" title="reflect.Value"></a>reflect.Value</h3><p>通过 <code>reflect.ValueOf()</code> 函数获取 interface{} 里的实际变量, 返回结构体 <code>reflect.Value</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ValueOf returns a new Value initialized to the concrete value</span></span><br><span class="line"><span class="comment">// stored in the interface i. ValueOf(nil) returns the zero Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i any)</span></span> Value &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Maybe allow contents of a Value to live on the stack.</span></span><br><span class="line">	<span class="comment">// For now we make the contents always escape to the heap. It</span></span><br><span class="line">	<span class="comment">// makes life easier in a few places (see chanrecv/mapassign</span></span><br><span class="line">	<span class="comment">// comment below).</span></span><br><span class="line">	escapes(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// emptyInterface is the header for an interface&#123;&#125; value.</span></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// typ holds the type of the value represented by a Value.</span></span><br><span class="line">	typ *rtype</span><br><span class="line">	<span class="comment">// Pointer-valued data or, if flagIndir is set, pointer to data.</span></span><br><span class="line">	ptr unsafe.Pointer</span><br><span class="line">	<span class="comment">// flag holds metadata about the value.</span></span><br><span class="line">	flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unpackEface converts a empty interface to Value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">	e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"></span><br><span class="line">	t := e.typ</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	f := flag(t.Kind())</span><br><span class="line">	<span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">		f |= flagIndir</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interface 和 Value 可以互相转换, Interface 和 Value 均可以获取 Type.</p>
<p><img src="https://golang.design/go-questions/stdlib/reflect/assets/6.png" alt="三者关系"></p>
<p>下图中, <code>rtype</code> 实现了 <code>Type</code> 接口, 是所有类型的公共部分. emptyface 结构体和 eface 其实是一个东西, 而 rtype 其实和 _type 是一个东西, 只是一些字段稍微有点差别, 比如 emptyface 的 word 字段和 eface 的 data 字段名称不同, 但是数据型是一样的.</p>
<p><img src="https://golang.design/go-questions/stdlib/reflect/assets/7.png" alt="value rtype"></p>
<h3 id="反射三定律"><a href="#反射三定律" class="headerlink" title="反射三定律"></a>反射三定律</h3><ol>
<li>Reflection goes from interface value to reflection object.</li>
<li>Reflection goes from reflection object to interface value.</li>
<li>To modify a reflection object, the value must be settable.<ul>
<li>反射变量可设置的本质是它存储了原变量本身, 这样对反射变量的操作, 就会反映到原变量本身;</li>
<li>反之, 如果反射变量不能代表原变量, 那么操作了反射变量 ,不会对原变量产生任何影响. 这种情况在语言层面不被允许</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure>

<p>执行上述代码会 panic 的原因是, ValueOf 中的参数 x 是一个拷贝, 反射变量 v 不能代表 x 本身.</p>
<p>因此需要操作引用变量或者传递指针才行. 或者对引用变量进行操作.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type of p:&quot;</span>, p.Type())			 <span class="comment">// type of p: *float64</span></span><br><span class="line">fmt.Println(<span class="string">&quot;settability of p:&quot;</span>, p.CanSet()) <span class="comment">// settability of p: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p 还不是代表 x, p.Elem() 才真正代表 x, 因此使用 p.Elem() 才能真正操作 x:</span></span><br><span class="line">v := p.Elem()	<span class="comment">// will panic if p is not pointer or interface</span></span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br><span class="line">fmt.Println(v.Interface()) <span class="comment">// 7.1</span></span><br><span class="line">fmt.Println(x) <span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure>

<p>反射的应用: IDE 代码补全功能, 对象序列化(encoding&#x2F;json), fmt相关函数, ORM…</p>
<h3 id="reflect-DeepEqual"><a href="#reflect-DeepEqual" class="headerlink" title="reflect.DeepEqual()"></a>reflect.DeepEqual()</h3><p>如果是不同的类型, 即使是底层类型相同, 相应的值也相同, 那么两者也不是”深度”相等. </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>深度相等情形</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>相同索引处的元素“深度”相等</td>
</tr>
<tr>
<td>Struct</td>
<td>相应字段，包含导出和不导出，“深度”相等</td>
</tr>
<tr>
<td>Func</td>
<td>只有两者都是 nil 时</td>
</tr>
<tr>
<td>Interface</td>
<td>两者存储的具体值“深度”相等</td>
</tr>
<tr>
<td>Map</td>
<td>1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等</td>
</tr>
<tr>
<td>Pointer</td>
<td>1、使用 &#x3D;&#x3D; 比较的结果相等；2、指向的实体“深度”相等</td>
</tr>
<tr>
<td>Slice</td>
<td>1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &amp;x[0] &#x3D;&#x3D; &amp;y[0] 或者 相同索引处的元素“深度”相等</td>
</tr>
<tr>
<td>numbers, bools, strings, and channels</td>
<td>使用 &#x3D;&#x3D; 比较的结果为真</td>
</tr>
</tbody></table>
<p>一般情况下, DeepEqual 的实现只需要递归地调用 &#x3D;&#x3D; 就可以比较两个变量是否是真的”深度”相等. </p>
<p>但是, 有一些异常情况, 比如: </p>
<ul>
<li>func 类型是不可比较的类型, 只有在两个 func 类型都是 nil 的情况下, 才是”深度”相等;</li>
<li>float 类型, 由于精度的原因, 也是不能使用 &#x3D;&#x3D; 比较的;</li>
<li>包含 func 类型或者 float 类型的 struct, interface, array 等;</li>
<li>对于指针而言, 当两个值相等的指针就是”深度”相等, 因为两者指向的内容是相等的, 即使两者指向的是 func 类型或者 float 类型, 这种情况下不关心指针所指向的内容.</li>
<li>对于指向相同 slice, map 的两个变量也是”深度”相等的, 不关心 slice, map 具体的内容.</li>
<li>对于”有环”的类型, 比如循环链表, 比较两者是否”深度”相等的过程中, 需要对已比较的内容作一个标记, 一旦发现两个指针之前比较过, 立即停止比较, 并判定二者是深度相等的. 以及时停止比较, 避免陷入无限循环.</li>
</ul>
<p>核心的比较代码在 <code>deepValueEqual</code> 中, 核心是一个 switch 语句, 识别输入参数的不同类型, 分别递归调用 deepValueEqual 函数, 一直递归到最基本的数据类型, 可以直接得出 true 或者 false, 再一层层地返回, 最终得到”深度”相等的比较结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> || y == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x == y</span><br><span class="line">	&#125;</span><br><span class="line">	v1 := ValueOf(x)</span><br><span class="line">	v2 := ValueOf(y)</span><br><span class="line">	<span class="keyword">if</span> v1.Type() != v2.Type() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> deepValueEqual(v1, v2, <span class="built_in">make</span>(<span class="keyword">map</span>[visit]<span class="type">bool</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h2><h3 id="Go-指针和-unsafe"><a href="#Go-指针和-unsafe" class="headerlink" title="Go 指针和 unsafe"></a>Go 指针和 unsafe</h3><p><strong>Go 语言的指针</strong>存在很多限制:</p>
<ol>
<li>Go 的指针不能进行数学运算</li>
<li>不同类型的指针不能互相转换</li>
<li>不同类型的指针不能通过 <code>==</code> 或 <code>!=</code> 进行比较<ul>
<li>只有在两个指针类型相同或者可以相互转换的情况下, 才可以对两者进行比较. </li>
<li>另外, 指针可以通过 <code>==</code> 和 <code>!=</code> 直接和 <code>nil</code> 作比较.</li>
</ul>
</li>
<li>不同类型的指针变量不能相互赋值</li>
</ol>
<p><strong>unsafe 中的 Pointer</strong>: Pointer 可以指向任何类型, 其类似于 C 语言中的 void*</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure>

<p>unsafe 包提供了两点重要的能力:</p>
<ol>
<li>任意类型的指针都可以和 unsafe.Pointer 互相转换</li>
<li>uintptr 类型和 unsafe.Pointer 可以互相转换</li>
</ol>
<p><img src="https://golang.design/go-questions/stdlib/unsafe/assets/0.png" alt="type pointer uintptr"></p>
<p><strong>unsafe.Pointer 并没有数学运算的能力, 但是可以将其转换为 uintptr 之后再进行数学运算, 再转换为 unsafe.Pointer类型.</strong></p>
<p><strong>uintptr 没有指针的语义, 因此 uintptr 指向的对象会被 gc 回收(这点在map 的 extra 字段和 overflow 字段中也有所体现)</strong></p>
<p><strong>unsafe 包中的几个函数都是在编译期间执行完毕</strong></p>
<h3 id="unsafe-修改私有成员"><a href="#unsafe-修改私有成员" class="headerlink" title="unsafe 修改私有成员"></a>unsafe 修改私有成员</h3><p>对于一个结构体, 通过 offset 函数可以获取结构体成员的偏移量, 进而获取成员的地址, 读写该地址的内存, 就可以达到改变成员值的目的. 这里有一个内存分配相关的事实: 结构体会被分配一块连续的内存, 结构体的地址也代表了第一个成员的地址.</p>
<h3 id="字符串和-byte-切片之间的无拷贝转换"><a href="#字符串和-byte-切片之间的无拷贝转换" class="headerlink" title="字符串和 byte 切片之间的无拷贝转换"></a>字符串和 byte 切片之间的无拷贝转换</h3><p>首先需要直到字符串和 byte 切片的数据结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="type">uintptr</span></span><br><span class="line">	Len  <span class="type">int</span></span><br><span class="line">	Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要共享底层的 Data 和 Len 就可以实现 <em>zero-copy</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2string</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hashing</title>
    <url>/2023/02/21/Hashing/</url>
    <content><![CDATA[<h1 id="Hash-Collision"><a href="#Hash-Collision" class="headerlink" title="Hash Collision"></a>Hash Collision</h1><ul>
<li>Open Addressing Scheme<ul>
<li>Linear Probing Hashing</li>
<li>Quadratic Probing Hashing</li>
<li>Double Hashing</li>
<li>Robin Hood Hashing</li>
<li>Hopscotch Hashing</li>
<li>Cuckoo Hashing</li>
</ul>
</li>
<li>Chaining Scheme<ul>
<li>Separate Chaining Hashing</li>
</ul>
</li>
</ul>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>ClickHouse</title>
    <url>/2023/02/19/ClickHouse/</url>
    <content><![CDATA[<h1 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h1><h2 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h2><p>数据库: 结构化的信息，数据的集合，存储在存储介质中，可以通过查询语言查询信息</p>
<ul>
<li><p>关系型数据库: 数据以表形式存储，存储结构化信息</p>
</li>
<li><p>非关系型数据库: 存储半结构化或非结构化信息</p>
</li>
<li><p>单机数据库</p>
</li>
<li><p>分布式数据库</p>
</li>
<li><p>OLAP 数据库</p>
</li>
<li><p>OLTP 数据库</p>
</li>
<li><p>HTAP 数据库</p>
</li>
</ul>
<span id="more"></span>

<p>OLAP 数据库的应用场景:</p>
<ul>
<li>大量数据的读写，PB级别存储</li>
<li>多维分析，复杂的聚合函数</li>
<li>窗口函数，UDF(User Defined Function)</li>
<li>离线&#x2F;实时分析</li>
</ul>
<h2 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h2><p><img src="D:\Blog\source_images\image-20230219101529473.png" alt="img"></p>
<p>parser: 词法分析和语法分析，生成AST树 (Abstract Syntax Tree)</p>
<p>analyzer: 变量绑定，类型推导，语义检查，安全、权限校验、完整性检查等；为生成计划做准备</p>
<p>optimizer: 为查询生成性能最优的执行计划，进行代价评估；并将AST翻译成可执行算子</p>
<p>executor: 将执行计划翻译成可执行的物理计划并驱动其执行</p>
<p>Storage engine: </p>
<ol>
<li>管理内存数据结构<ul>
<li>index</li>
<li>内存数据</li>
<li>缓存</li>
<li>Query cache、Data cache、Index cache</li>
</ul>
</li>
<li>管理磁盘数据<ul>
<li>磁盘数据的文件格式</li>
<li>磁盘数据的增删查改</li>
</ul>
</li>
<li>读写算子<ul>
<li>数据写入逻辑</li>
<li>数据读取逻辑</li>
</ul>
</li>
</ol>
<h1 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h1><p>列式存储的优点:</p>
<ul>
<li>数据压缩<ul>
<li>LZ4, run-length encoding, Delta encoding</li>
</ul>
</li>
<li>数据选择<ul>
<li>可以选择特定的列而不需要读取所有的列</li>
<li>对聚合计算更友好</li>
</ul>
</li>
<li>延迟物化<ul>
<li>缓存友好</li>
<li>CPU&#x2F;内存带宽友好</li>
<li>利用执行计划和算子的优化，如filter</li>
</ul>
</li>
<li>向量化<ul>
<li>SIMD(single instruction multiple data), 有SSE和AVX系列, 处理能力和寄存器宽度有关<ul>
<li>数据需要是连续内存</li>
<li>数据需要按批读取</li>
<li>数据的调用需要明确数据类型</li>
</ul>
</li>
</ul>
</li>
<li>统计分析类查询和即时查询</li>
</ul>
<h1 id="ClickHouse的存储设计"><a href="#ClickHouse的存储设计" class="headerlink" title="ClickHouse的存储设计"></a>ClickHouse的存储设计</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>表定义和结构</p>
<p><img src="D:\Blog\source_images\image-20230219104429473.png" alt="img"></p>
<p>集群架构</p>
<p>distributed_table是一个逻辑上的表，其负责选择shard和replica</p>
<p><img src="D:\Blog\source_images\image-20230219104529473.png" alt="img"></p>
<p>引擎架构</p>
<p><img src="D:\Blog\source_images\image-20230219024129473.png" alt="img"></p>
<h2 id="存储架构"><a href="#存储架构" class="headerlink" title="存储架构"></a>存储架构</h2><p>ClickHouse文件组织，其中part由定义表时的PARTITION BY指定</p>
<p>PARTITION为逻辑结构</p>
<p>每一个part文件夹下有多个column的bin文件</p>
<p><img src="D:\Blog\source_images\image-20230219104729473.png" alt="img"></p>
<h2 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h2><h3 id="Hash-Index"><a href="#Hash-Index" class="headerlink" title="Hash Index"></a>Hash Index</h3><p>Key 通过 HashFunc 之后映射到 Bucket 上，然后找到存储位置</p>
<p>不适合大范围聚合查询</p>
<h3 id="B-x2F-B-Tree"><a href="#B-x2F-B-Tree" class="headerlink" title="B&#x2F;B+ Tree"></a>B&#x2F;B+ Tree</h3><p>适合点查和范围查找</p>
<h3 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM Tree"></a>LSM Tree</h3><p>对于OLAP数据库，其他数据结构存在的问题</p>
<ul>
<li>对于大数据量，B&#x2F;B+ Tree深度太高</li>
<li>索引数据量太大，多个列如何平衡查询和存储</li>
</ul>
<p>LSM Tree: Log-Structured Merge-Tree</p>
<ul>
<li>着重优化顺序写入</li>
<li>主要数据结构<ul>
<li>SSTable</li>
<li>Memtable</li>
</ul>
</li>
</ul>
<p>SStable</p>
<ol>
<li>Key按顺序存储到文件中，称为segment</li>
<li>SStable包含多个segment</li>
<li>每个segment写入到磁盘之后都是不可更改的，新加的数据只能生成新的segment</li>
</ol>
<p>Memtable</p>
<ul>
<li>在内存中的数据存储在memtable中，大多数都是实现一颗Binary Search Tree</li>
<li>当memable存储的数据到达一定的阈值的时候，就会顺序的写入磁盘</li>
</ul>
<p>数据查询</p>
<ul>
<li>从最新的segment开始遍历每一个key</li>
<li>为每一个segment建立一个sparse index，由于segment的有序性，sparse index支持二分查找，如果在sparse index中没有查找到，还可以根据offset在segment中进行小范围的查找</li>
</ul>
<p>SSTable还具有Compaction的过程</p>
<ul>
<li>将多个segments合并为一个segment的过程</li>
<li>一般由一个后台线程完成</li>
<li>新segment可见之前，旧segment保持不可见</li>
</ul>
<p>数据被划分为granules</p>
<ol>
<li>granules是数据的最小读取单元</li>
<li>不同的granules可以并行读取</li>
<li>一个granules通常为8192 rows</li>
</ol>
<p>每个granule都对应primary.idx中的一行，表示一个mark。最后一个mark保存的是granule的最大值</p>
<p>mark(.mrk)文件保存了granules的物理地址，每一列都有一个字节的mark文件，包含block_offset和granule_offset</p>
<p>在其他列上建立二级索引</p>
<h1 id="ClickHouse应用场景"><a href="#ClickHouse应用场景" class="headerlink" title="ClickHouse应用场景"></a>ClickHouse应用场景</h1><h2 id="大宽表查询"><a href="#大宽表查询" class="headerlink" title="大宽表查询"></a>大宽表查询</h2><p>大宽表的存储和查询</p>
<ul>
<li>可以建立很多列</li>
<li>可以增加，删除，清空每一列的数据</li>
<li>查询时可快速选择需要的列</li>
<li>将列涉及到的过滤条件推到存储层而加速查询</li>
</ul>
<p>动态表结构</p>
<ol>
<li>map中的每个key都是一列</li>
<li>map中的每一列都可以单独的查询</li>
<li>使用方式同普通列，可以做任何计算</li>
</ol>
<h2 id="离线数据分析"><a href="#离线数据分析" class="headerlink" title="离线数据分析"></a>离线数据分析</h2><p>数据导入</p>
<ul>
<li>spark生成</li>
<li>hdfs上由hive2ch导入工具完成</li>
<li>数据直接导入到物理节点</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230219120429473.png" alt="img"></p>
<p>数据按列导入</p>
<ul>
<li>保证查询可以及时访问已有数据</li>
<li>可以按需加载需要的列</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230219120529473.png" alt="img"></p>
<h2 id="实时数据分析"><a href="#实时数据分析" class="headerlink" title="实时数据分析"></a>实时数据分析</h2><p>使用memtable减少part数量</p>
<ul>
<li>数据先缓存在内存中</li>
<li>到达一定阈值再写到磁盘</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230219121829473.png" alt="img"></p>
<h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h2><ol>
<li>bitmap index</li>
<li>bimap64</li>
<li>lowcardinality<ol>
<li>对<strong>低基数列</strong>使用<strong>字典编码</strong></li>
<li>减少数据存储和<strong>读写的IO</strong>使用</li>
<li>可以做运行时的<strong>压缩</strong>数据过滤</li>
<li>有时候也不需要解压，直接对position进行计算</li>
<li>存储时只存储position，另外存储dict和revdict的元数据</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>ClickHouse是列式存储</li>
<li>存储设计是LSM-Tree架构</li>
<li>使用稀疏索引加速查询</li>
<li>梅格列都有丰富的压缩算法和索引结构</li>
<li>基于列存设计的高效数据处理逻辑，延迟物化</li>
</ol>
]]></content>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/02/18/Redis/</url>
    <content><![CDATA[<h1 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h1><h2 id="为什么需要Redis"><a href="#为什么需要Redis" class="headerlink" title="为什么需要Redis"></a>为什么需要Redis</h2><ul>
<li>数据从单表演进成了分库分表</li>
<li>MySQL由单机演化为了集群<ul>
<li>数据量增长</li>
<li>读写数据压力增加</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p><img src="D:\Blog\source_images\image-20230218200050157.png" alt="image-20230218200050157"></p>
<p>数据分为冷数据和热数据</p>
<p>将热数据存储到内存中</p>
<h2 id="Redis基本工作原理"><a href="#Redis基本工作原理" class="headerlink" title="Redis基本工作原理"></a>Redis基本工作原理</h2><p>数据从内存中读写</p>
<p>数据保存到硬盘防止重启数据丢失</p>
<ul>
<li>增量数据保存到AOF文件</li>
<li>全量数据保存到RDB文件</li>
</ul>
<p>单线程处理所有操作命令</p>
<p><img src="D:\Blog\source_images\image-20230218200347244.png" alt="image-20230218200347244"></p>
<h1 id="Redis-应用案例"><a href="#Redis-应用案例" class="headerlink" title="Redis 应用案例"></a>Redis 应用案例</h1><h2 id="连续签到"><a href="#连续签到" class="headerlink" title="连续签到"></a>连续签到</h2><p>Redis可以设置过期时间</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String数据结构: </p>
<ul>
<li>可以存储字符串、数字、二进制数据</li>
<li>通常和expire一起配合使用</li>
<li>场景: 存储计数，Session</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230218201011218.png" alt="image-20230218201011218"></p>
<h2 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h2><p>用list作为消息队列</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List数据结构QuickList</p>
<p>QuickList由一个双向链表和listpack实现</p>
<p>listpack: 一个entry存储了多个元素</p>
<ul>
<li>tot-bytes: 32 bits</li>
<li>num-elements: 16 bits</li>
<li>element-N: variable length<ul>
<li>encoding-type: 编码类型和data长度</li>
<li>element-data: 实际数据</li>
<li>element-tot-len: 元素总长度 type+data，从左往右遍历时不需要，主要在从右往左遍历时使用</li>
</ul>
</li>
<li>listpack-end-byte: 8 bits, value of 255</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230218201637692.png" alt="image-20230218201637692"></p>
<h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>使用hash数据结构进行技术</p>
<p>一次性Set多个key或Get多个key的时候可以使用<strong>Pipeline</strong>功能</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>和Golang中map的实现类似</p>
<p>当负载因子大于1的时候触发rehash</p>
<p>ht[0] 表示原 hash table，ht[1] 表示新 hash table</p>
<p>每次用户访问都会迁移少量数据，以amortize rehash的性能损耗</p>
<p><img src="D:\Blog\source_images\image-20230218203133638.png" alt="image-20230218203133638"></p>
<h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><p>积分变化时，排名需要实时更新</p>
<p>使用ZSet数据结构实现</p>
<h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><p>ZSet数据结构 ZSkipList</p>
<p><img src="D:\Blog\source_images\image-20230218204022883.png" alt="image-20230218204022883"></p>
<p>Redis使用了SkipList和Hash的结构</p>
<p>通过backward可以轻易实现倒排</p>
<p>可以通过hash进行反查SkipList的节点</p>
<p><img src="D:\Blog\source_images\image-20230218214135362.png" alt="image-20230218214135362"></p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>要求1s内放行的请求为N，超过N则禁止访问</p>
<p>key: comment_freq_limit_1671356046，其中1671356046表示时间戳，每访问一次都对这个key调用INCR，超过N则禁止访问。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>并发场景下，要求一次只有一个协程执行。执行完成后，其中等待中的协程才能执行</p>
<p>Redis实现分布式锁的特性:</p>
<ul>
<li>Redis核心是单线程</li>
<li>SETNX只有未设置过的才能成功</li>
</ul>
<p>Redis实现的分布式锁不是高可用的分布式锁，存在的问题:</p>
<ul>
<li>业务超时解锁，导致解锁时业务未完成</li>
<li>主备切换的临界点，主节点持有的锁未同步到新的主节点，而另一个从节点可以获取到锁</li>
<li>Redis集群出现脑裂，导致出现多个主节点，多个主节点同时持有锁</li>
</ul>
<h1 id="Redis使用注意事项"><a href="#Redis使用注意事项" class="headerlink" title="Redis使用注意事项"></a>Redis使用注意事项</h1><h2 id="大Key"><a href="#大Key" class="headerlink" title="大Key"></a>大Key</h2><p>什么样的Key属于大Key</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>临界点</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>value的字节数大于10KB</td>
</tr>
<tr>
<td>Hash&#x2F;Set&#x2F;Zset&#x2F;List等复杂数据结构</td>
<td>元素个数大于5000个或总value大于10KB</td>
</tr>
</tbody></table>
<p>大Key的危害</p>
<ul>
<li>读取成本高</li>
<li>容易导致慢查询(过期，删除)</li>
<li>主从复制异常，服务阻塞，无法正常响应请求</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230218220800118.png" alt="image-20230218220800118"></p>
<p>消除大Key的办法:</p>
<ol>
<li>压缩: 使用gzip，snappy，lz4等压缩算法压缩。如果是JSON字符串，可以考虑MessagePack进行序列化，主要需要考虑解压缩的时间</li>
<li>拆分: 将大Key拆分为小Key</li>
<li>对集合类结构hash，list，set，zset等<ol>
<li>拆分: 可以使用hash取余，以位掩码的方式决定存放在哪个key中</li>
<li>区分冷热: 如榜单列表使用zset，只缓存前10页数据，之后的数据走db</li>
</ol>
</li>
</ol>
<p><img src="D:\Blog\source_images\image-20230218221153202.png" alt="image-20230218221153202"></p>
<h2 id="热Key"><a href="#热Key" class="headerlink" title="热Key"></a>热Key</h2><p>什么是热Key: 用户访问一个Key的QPS特别高，导致Server实例出现CPU负载突增或不均的情况</p>
<p>热Key没有明确的定义，QPS超过500一般认为为热Key</p>
<p>如何解决热Key:</p>
<ol>
<li>设置Local Cache<ul>
<li>在访问Redis之前，在业务服务侧设置LocalCache，降低Redis的QPS，LocalCache缓存过期或未命中，将Redis中的数据更新到LocalCache。例如Golang的Bigcache。</li>
<li>缓存过期管理</li>
<li>缓存分片</li>
<li>本机内存</li>
</ul>
</li>
<li>拆分<ul>
<li>将key:value这一个热Key写入多份，例如key1:value, key2:value，访问的时候访问多个Key，但是value是同一个，以此将QPS分散到Redis集群中不同的实例上。但是更新时需要更新多个Key，而且存在数据短暂不一致的风险</li>
</ul>
</li>
<li>使用Redis代理的热Key承载能力<ul>
<li>Redis访问代理具有热Key承载能力。本质上结合了热Key发现和LocalCache两个功能</li>
<li>Redis访问代理相当于Redis的路由</li>
</ul>
</li>
</ol>
<p><img src="D:\Blog\source_images\image-20230218222629473.png" alt="image-20230218222629473"></p>
<h2 id="慢查询场景"><a href="#慢查询场景" class="headerlink" title="慢查询场景"></a>慢查询场景</h2><p>容易导致慢查询的操作:</p>
<ol>
<li>批量操作一次传入过多的key&#x2F;value，如mset&#x2F;hmset&#x2F;sadd&#x2F;zadd等O(n)操作，但此操作单批次不要超过100</li>
<li>zset大部分命令都是O(log(n))，带下不要超过5000</li>
<li>操作的单个value是大Key</li>
<li>对大Key的delete&#x2F;expire操作</li>
</ol>
<h2 id="缓存穿透、缓存雪崩"><a href="#缓存穿透、缓存雪崩" class="headerlink" title="缓存穿透、缓存雪崩"></a>缓存穿透、缓存雪崩</h2><p>缓存穿透: 热点数据查询绕过缓存，直接查询数据库</p>
<p>缓存雪崩: 大量缓存同时过期</p>
<p>危害:</p>
<ol>
<li>查询一个一定不存在的数据: 通常不会缓存不存在的数据，这类请求会查询db。这类查询多时可能会导致db响应慢甚至宕机</li>
<li>缓存过期时: 在高并发下，如果一个热Key过期，会有大量请求到db，影响db。同一时间有大量db过期也会导致大量请求到db上</li>
</ol>
<p>减少缓存穿透:</p>
<ol>
<li>缓存空值: 如果某个值在db中不存在，则缓存一个空值</li>
<li>bloom filter: 利用bloom filter判断某个值是否存在</li>
</ol>
<p>减少缓存雪崩:</p>
<ol>
<li>分散缓存失效时间。例如在原有失效时间加上一个随机值。热点数据过期时间设置长一点，冷门数据过期时间设置短一点</li>
<li>使用缓存集群，避免单机宕机造成的缓存雪崩</li>
</ol>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2023/02/13/RPC/</url>
    <content><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC需要解决的问题:</p>
<ul>
<li>函数映射问题</li>
<li>数据转换为字节流</li>
<li>数据的网络传输</li>
</ul>
<span id="more"></span>

<h2 id="RPC-模型"><a href="#RPC-模型" class="headerlink" title="RPC 模型"></a>RPC 模型</h2><p>RPC 由五个模型组成</p>
<ol>
<li>User</li>
<li>User-Stub</li>
<li>RPC-Runtime</li>
<li>Server-Stub</li>
<li>Server</li>
</ol>
<p><img src="D:\Blog\source_images\image-20230218155944161.png" alt="image-20230218155944161"></p>
<h2 id="RPC-框架"><a href="#RPC-框架" class="headerlink" title="RPC 框架"></a>RPC 框架</h2><ol>
<li>IDL文件: 描述接口，可跨语言、跨平台</li>
<li>生成代码: 将IDL文件转换为对应语言的静态库</li>
<li>编解码: 内存中的表示和字节序列之间的转换为编解码</li>
<li>通信协议: 网络传输协议</li>
<li>网络传输: 通常基于成熟的网络库，如TCP&#x2F;UDP</li>
</ol>
<p><img src="C:\Users\Anyu\AppData\Roaming\Typora\typora-user-images\image-20230218160113958.png" alt="image-20230218160113958"></p>
<p>RPC优点:</p>
<ul>
<li>单一职责，有利于分工协作和运维开发</li>
<li>可扩展性强，资源使用率更优</li>
<li>故障隔离，服务的可靠性更高</li>
</ul>
<h2 id="RPC-分层设计"><a href="#RPC-分层设计" class="headerlink" title="RPC 分层设计"></a>RPC 分层设计</h2><h3 id="RPC框架架构"><a href="#RPC框架架构" class="headerlink" title="RPC框架架构"></a>RPC框架架构</h3><p>Apache Thrift架构如下: </p>
<p><img src="D:\Blog\source_images\image-20230218164643012.png" alt="image-20230218164643012"></p>
<h3 id="编解码层"><a href="#编解码层" class="headerlink" title="编解码层"></a>编解码层</h3><p>数据格式:</p>
<ul>
<li>语言特定的格式，通常与编程语言绑定</li>
<li>文本格式，如JSON，XML，CSV等格式</li>
<li>二进制编码，跨语言、高性能</li>
</ul>
<p>TLV编码: TLV :&#x3D; Tag | Length | Value (Value can also be TLV)</p>
<p>Varint编码</p>
<h3 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h3><p>常见的协议:</p>
<ul>
<li>特殊结束符: 通过一个特殊字符作为协议单元结束的标志</li>
<li>变长协议: 定长部分加变长部分，通常定长部分需要描述变长部分的长度</li>
</ul>
<h3 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h3><p>Socket API，连接管理和事件分发</p>
<p>性能: 高性能定时器、对象池等</p>
<h2 id="RPC-关键指标"><a href="#RPC-关键指标" class="headerlink" title="RPC 关键指标"></a>RPC 关键指标</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>降级措施:</p>
<ul>
<li>熔断: 保护调用方，防止被调用的服务出现问题而影响整个链路</li>
<li>限流: 保护被调用方，防止大流量把服务压垮</li>
<li>超时控制: 避免浪费资源在不可用节点上</li>
</ul>
<p>请求成功率:</p>
<ul>
<li>负载均衡</li>
<li>重试: 多次失败才表示真正的失败</li>
</ul>
<p>长尾请求:</p>
<ul>
<li>Backup Request: 未超时的时候就发送额外的请求</li>
</ul>
<p>框架通过<strong>注册中间件</strong>的方式来实现上述措施:</p>
<ul>
<li>WithCircuitBreaker: 熔断</li>
<li>WithRateLimiter: 限流</li>
<li>WithTimeout: 超时控制</li>
<li>WithLoadBalancer: 负载均衡</li>
<li>WithRetry: 重试</li>
<li>WithBackupRequest: Backup Request</li>
</ul>
<h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><p>开箱即用: 合理的默认参数选项(熔断、限流、降级等)，丰富的文档</p>
<p>生成代码工具，脚手架工具</p>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>Middleware</p>
<p>Option</p>
<p>编解码层</p>
<p>协议层</p>
<p>网络传输层</p>
<p>代码生成工具插件拓展</p>
<p><img src="D:\Blog\source_images\image-20230218172303486.png" alt="image-20230218172303486"></p>
<h3 id="观测性"><a href="#观测性" class="headerlink" title="观测性"></a>观测性</h3><p>RPC框架往往内置观测服务</p>
<ul>
<li>Log: Events</li>
<li>Metric: Aggregatable</li>
<li>Tracing: Request Scoped</li>
</ul>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>目标: </p>
<ul>
<li>高吞吐</li>
<li>低延迟</li>
</ul>
<p>手段:</p>
<ul>
<li>连接池</li>
<li>多路复用</li>
<li>高性能编解码协议</li>
<li>高性能网络库</li>
</ul>
<h2 id="RPC-框架实现"><a href="#RPC-框架实现" class="headerlink" title="RPC 框架实现"></a>RPC 框架实现</h2><h3 id="Netpoll"><a href="#Netpoll" class="headerlink" title="Netpoll"></a>Netpoll</h3><p>网络库Netpoll的背景:</p>
<ul>
<li>原生库net无法感知连接状态，可能存在无效连接</li>
<li>原生库存在goroutine暴涨的风险</li>
</ul>
<p>改进:</p>
<ul>
<li>引入epoll主动监听机制，感知连接状态</li>
<li>建立goroutine池，复用goroutine</li>
<li>引入Nocopy Buffer，编解码层实现零拷贝</li>
</ul>
<h3 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h3><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Interaction</td>
<td>Ping-Pong&#x2F;Streaming&#x2F;Oneway</td>
</tr>
<tr>
<td>Codec</td>
<td>Thrift&#x2F;Protobuf</td>
</tr>
<tr>
<td>Application Layer Protocol</td>
<td>TTheader&#x2F;Http2</td>
</tr>
<tr>
<td>Transport Layer</td>
<td>TCP&#x2F;UDP&#x2F;RDMA</td>
</tr>
</tbody></table>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>网络库优化:</p>
<ul>
<li>调度优化<ul>
<li>epoll_wait 在调度上的控制</li>
<li>gopool重用</li>
</ul>
</li>
<li>LinkBuffer<ul>
<li>读写并行无锁，支持nocopy进行流式读写</li>
<li>高效扩缩容</li>
<li>Nocopy Buffer池化，减少GC开销</li>
</ul>
</li>
<li>Pool<ul>
<li>引入内存池和对象池，减少GC开销</li>
</ul>
</li>
</ul>
<p>编解码优化: </p>
<ul>
<li>Codegen<ul>
<li>预计算并分配内存，减少内存操作次数</li>
<li>Inline减少函数调用次数和不必要的反射</li>
</ul>
</li>
<li>JIT (Just In Time)<ul>
<li>无生产代码，将编译过程移到了程序的加载（或首次解析）阶段，可以一次性编译生成对应的 codec 并高效执行</li>
</ul>
</li>
</ul>
<h2 id="部署优化"><a href="#部署优化" class="headerlink" title="部署优化"></a>部署优化</h2><p>问题: 微服务过微，传输和序列化开销增大</p>
<p>解决方案: 将依赖关系较强的服务尽可能地调度到一个物理机，RPC调用优化为本地IPC调用</p>
]]></content>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Message Queue</title>
    <url>/2023/02/13/Message-Queue/</url>
    <content><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>消息队列(MQ): 指保存消息的一个容器，本质上是一个队列，但需要支持<strong>高吞吐，高并发，高可用</strong></p>
<ul>
<li>解耦，例如替代存储业务</li>
<li>削峰，例如限制一个服务的请求量</li>
<li>异步，例如减少一条链路中的长尾效应</li>
<li>日志处理</li>
</ul>
<span id="more"></span>

<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>应用场景:</p>
<ul>
<li>日志信息</li>
<li>Metrics数据</li>
<li>用户行为数据</li>
</ul>
<p>如何使用:</p>
<ol>
<li>创建集群</li>
<li>新增Topic，设置分区数量</li>
<li>编写生产者逻辑</li>
<li>编写消费者逻辑</li>
</ol>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="D:\Blog\source_images\image-20230215151350639.png" alt="image-20230215151350639"></p>
<p>Topic: 逻辑队列，用于不同的业务场景</p>
<p>Cluster: 物理集群，每个集群中可以建立多个不同的Topic</p>
<p>Producer: 生产者，负责将消息发送到Topic之中</p>
<p>Consumer: 消费者，负责消费Topic中的信息</p>
<p>ConsumerGroup: 消费者组，不同的Consumer消费进度互不干涉</p>
<p>Partition: 一个Topic有多个Partition，不同的Partition的消息可以并发处理</p>
<p><img src="D:\Blog\source_images\image-20230215151451171.png" alt="image-20230215151451171"></p>
<p>Offset，消息在Partition中的相对位置信息，可以理解为唯一ID，在Partition内部严格递增</p>
<p>Replica: 每个Partition会有多个Replica，Leader Replica会从ISR(In-Sync Replicas)中选出</p>
<ul>
<li>Leader会从Producer中写数据，被Consumer读数据</li>
<li>Follower从Leader中拉取数据</li>
</ul>
<h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><p>batch发送，批量发送可以减少IO次数，进而增强发送能力</p>
<p>通过压缩，减少消息大小，支持Snappy, Gzip, LZ4, ZSTD压缩算法</p>
<h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>将消息存储到本地磁盘，文件系统如下</p>
<p>顺序写，末尾追加，提升了写入效率</p>
<p><img src="D:\Blog\source_images\image-20230215152320277.png" alt="image-20230215152320277"></p>
<p>Broker如何寻找消息？</p>
<p>Consumer发送FetchRequest请求消息数据，Broker会将指定的Offset处的消息，按照时间窗口和消息大小窗口发送给Consumer。</p>
<p>Broker寻找offset的日志:</p>
<ul>
<li>通过二分法寻找小于目标offset的最大文件</li>
<li>对于偏移量索引文件，先二分，再遍历</li>
<li>对于时间索引文件，先通过时间戳利用二分法在时间索引文件中找到offset，然后根据这个offset二次查询</li>
</ul>
<p>Broker的零拷贝优化:</p>
<p>原路径: file –&gt; Read Buffer –&gt; Application Buffer –&gt; Socket Buffer –&gt; NIC Buffer –&gt; Consumer</p>
<p>优化路径: file –&gt; Read Buffer –&gt; NIC Buffer –&gt; Consumer</p>
<p><img src="D:\Blog\source_images\image-20230215153828661.png" alt="image-20230215153828661"></p>
<h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>Partition在Consumer Group中的分配问题？</p>
<ul>
<li>手动分配，哪一个Consumer消费哪个Partition完全由业务决定<ul>
<li>不能自动容灾，例如某一个Consumer挂掉，则有Partition空闲</li>
<li>扩缩容复杂，如新增一个Consumer需要重新分配</li>
</ul>
</li>
<li>自动分配，在Broker集群中，对每个Consumer Group，选出一个Coordinator，进行Consumer集群的自动分配(Re-balance)</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Kafka用于提高吞吐和稳定性的功能？</p>
<ul>
<li>Producer: 批量发送，数据压缩</li>
<li>Broker: 顺序写，消息索引，零拷贝</li>
<li>Consumer: Rebalance</li>
</ul>
<p>Kafka的缺点</p>
<ul>
<li>重启，替换，扩容，缩容都很复杂</li>
<li>负载不均衡时，解决方案复杂</li>
<li>运维成本高</li>
<li>没有缓存，完全依赖文件系统的Page Cache</li>
<li>Controller 和 Coordinator 和 Broker 在同一进程中，大量IO会导致性能下降</li>
</ul>
<h1 id="BMQ"><a href="#BMQ" class="headerlink" title="BMQ"></a>BMQ</h1><h2 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h2><p>兼容Kafka协议，<strong>存算分离</strong>，云原生消息队列</p>
<p><img src="D:\Blog\source_images\image-20230215160210435.png" alt="image-20230215160210435"></p>
<p>解决了Kafka中的负载均衡的问题 –&gt; 存算分离，利用分布式存储系统让partition的读取负载均衡</p>
<p>解决了Kafka运维成本高和扩缩容复杂的问题 –&gt; Broker-Partition 状态机</p>
<h2 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h2><h3 id="Producer写"><a href="#Producer写" class="headerlink" title="Producer写"></a>Producer写</h3><p><img src="D:\Blog\source_images\image-20230216183002024.png" alt="image-20230216183002024"></p>
<p><img src="D:\Blog\source_images\image-20230216183435666.png" alt="image-20230216183435666"></p>
<p>Failover: DataNode节点挂了导致写文件失败</p>
<h3 id="Consumer读"><a href="#Consumer读" class="headerlink" title="Consumer读"></a>Consumer读</h3><p><img src="D:\Blog\source_images\image-20230216183924456.png" alt="image-20230216183924456"></p>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="泳道消息"><a href="#泳道消息" class="headerlink" title="泳道消息"></a>泳道消息</h3><p>解决了主干泳道流量问题以及用到资源重复创建的问题</p>
<p>主干Topic用于线上环境，另一个Topic用于测试环境，且只需要一个Topic</p>
<p><img src="C:\Users\Anyu\AppData\Roaming\Typora\typora-user-images\image-20230216184839487.png" alt="image-20230216184839487"></p>
<h3 id="Databus"><a href="#Databus" class="headerlink" title="Databus"></a>Databus</h3><p>可以动态配置</p>
<p>对高吞吐支持较好</p>
<h3 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h3><p>通过最终一致性的方式，解决跨 Region 读写问题</p>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>一般: 通过offset或timestamp查询</p>
<p>直接在BMQ中将数据结构化，配置索引DDL，异步建立索引，之后通过Index Query服务读出数据</p>
<h3 id="Parquet"><a href="#Parquet" class="headerlink" title="Parquet"></a>Parquet</h3><p>Apache Parquet 数据存储格式</p>
<p>直接在BMQ中将数据结构化，通过Parquet Engine，以不同的方式构建Parquet格式文件</p>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="架构模型-1"><a href="#架构模型-1" class="headerlink" title="架构模型"></a>架构模型</h2><p>用于低延时场景，和峰值场景</p>
<p><img src="D:\Blog\source_images\image-20230217161020936.png" alt="image-20230217161020936"></p>
<h2 id="高级特性-1"><a href="#高级特性-1" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="事务场景"><a href="#事务场景" class="headerlink" title="事务场景"></a>事务场景</h3><p>RocketMQ支持事务</p>
<p>通过2PC实现</p>
<p><img src="D:\Blog\source_images\image-20230217162544987.png" alt="image-20230217162544987"></p>
<h3 id="延迟发送"><a href="#延迟发送" class="headerlink" title="延迟发送"></a>延迟发送</h3><ol>
<li>通过一个ScheduleTopic的Consumer消费消息，然后将消息送往延迟服务</li>
<li>时间到之后，延迟服务再将消息送回消息队列，让别的Consumer正常消费</li>
</ol>
<p><img src="D:\Blog\source_images\image-20230217162038461.png" alt="image-20230217162038461"></p>
<h3 id="消费重试和死信队列"><a href="#消费重试和死信队列" class="headerlink" title="消费重试和死信队列"></a>消费重试和死信队列</h3><p>消费失败时:</p>
<ul>
<li>没有超过重试次数，发到延时服务，延时投递至Topic进行重试</li>
<li>超过重试次数，发送到死信队列，人工介入</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Distributed Timer</title>
    <url>/2023/02/09/Distributed-Timer/</url>
    <content><![CDATA[<h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><p>定时任务: 实时，延时，或周期性完成任务调度的过程</p>
<p>分布式定时任务: 将分散的、可靠性差的任务纳入一个统一的<strong>平台</strong>，实现集群管理调度和分布式部署的一种定时任务的管理方式</p>
<p>触发时机:</p>
<ul>
<li>定时任务</li>
<li>延时任务</li>
<li>周期任务</li>
</ul>
<p>分布式定时任务: 自动化 + 定时执行 + 海量数据 + 高效稳定</p>
<span id="more"></span>

<h2 id="单机定时任务"><a href="#单机定时任务" class="headerlink" title="单机定时任务"></a>单机定时任务</h2><p>Linux命令: cronjob</p>
<p>Golang: time.Ticker</p>
<p>任务调度: Quartz</p>
<h2 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h2><p>分布式定时任务的执行方式:</p>
<ul>
<li>单机任务: 随机触发一台机器执行任务，使用计算量小，并发度低的任务</li>
<li>广播任务: 广播到所有机器上执行同一个任务，如所有机器一起执行日志</li>
<li>Map任务: 一个任务分为很多个子任务，适用于计算量大，单机无法满足要求的任务</li>
<li>MapReduce任务: 在Map任务的基础上，对子任务的结果进行汇总计算</li>
</ul>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h3><p>分布式定时任务的核心要解决<strong>触发</strong>，<strong>调度</strong>，<strong>执行</strong>三个关键问题。</p>
<ul>
<li>触发器(Trigger): 解析任务，生成触发事件</li>
<li>调度器(Scheduler): 分配任务，管理任务的生命周期</li>
<li>执行器(Executor): 获取执行任务的单元，执行任务逻辑</li>
<li>控制台(Admin): 提供任务管理和干预功能</li>
</ul>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><img src="D:\Blog\source_images\image-20230213180406391.png" alt="image-20230213180406391"></p>
<h3 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h3><p><img src="D:\Blog\source_images\image-20230213180511744.png" alt="image-20230213180511744"></p>
<h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p><img src="D:\Blog\source_images\image-20230213180755438.png" alt="image-20230213180755438"></p>
<p>Job: 任务元数据，一个Job对应多个JobInstance</p>
<p>JobInstance: 任务运行的实例</p>
<p>JobResult: 任务实例运行的结果</p>
<p>JobHistory: 用户可以修改任务信息，JobHistory会记录用户的修改。</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job是用户对任务属性的定义:</p>
<ul>
<li>基础信息 Who</li>
<li>调度时机 When</li>
<li>执行行为 What</li>
<li>执行方式 How</li>
</ul>
<h3 id="JobInstance"><a href="#JobInstance" class="headerlink" title="JobInstance"></a>JobInstance</h3><p>JobInstance是一次确定的Job的一次运行实例:</p>
<ul>
<li>Job_id</li>
<li>触发时间</li>
<li>状态&amp;结果</li>
<li>过程信息</li>
</ul>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>核心职责: 给定一系列任务，解析触发规则，在规定的时间点触发任务的调度</p>
<p>设计约束:</p>
<ul>
<li>需要支持大量任务</li>
<li>需要支持秒级调度</li>
<li>周期任务需要多次执行</li>
<li>需要保证秒级扫描的高性能，并避免资源浪费</li>
</ul>
<h3 id="方案1-定时扫描-延时消息"><a href="#方案1-定时扫描-延时消息" class="headerlink" title="方案1 定时扫描+延时消息"></a>方案1 定时扫描+延时消息</h3><p><img src="D:\Blog\source_images\image-20230213181935384.png" alt="image-20230213181935384"></p>
<h3 id="方案2-时间轮"><a href="#方案2-时间轮" class="headerlink" title="方案2 时间轮"></a>方案2 时间轮</h3><p>链表 –&gt; 最小堆 –&gt; 时间轮 –&gt; 多级时间轮</p>
<p><img src="D:\Blog\source_images\image-20230213182055690.png" alt="image-20230213182055690"></p>
<p><img src="D:\Blog\source_images\image-20230213182441824.png" alt="image-20230213182441824"></p>
<p>时间轮的改进: </p>
<ol>
<li>给任务加上一个count属性，每遍历一次count减一，当count变为0的时候，执行该任务。</li>
<li>多级时间轮，时间复杂度优秀，且可以扩展到天轮，月轮等等</li>
</ol>
<p><img src="D:\Blog\source_images\image-20230213182640729.png" alt="image-20230213182640729"></p>
<h3 id="高可用触发器"><a href="#高可用触发器" class="headerlink" title="高可用触发器"></a>高可用触发器</h3><p>问题：</p>
<ul>
<li>不同业务之间，任务的调度互相影响怎么办</li>
<li>负责扫描和触发的机器挂了怎么办</li>
</ul>
<p>解决思路：</p>
<ul>
<li>存储上，不同国家、业务做资源隔离</li>
<li>运行时，不同国家、业务分开运行</li>
<li>部署时，集群化部署，避免单点故障，通过数据库锁或分布式锁保证任务只执行一次<ul>
<li>数据库行锁模式：触发调度之前，更新数据库JobInstance的状态，成功更新的才能出发调度</li>
<li>触发调度之前，抢占分布式锁，可用Redis锁或Zookeeper锁。性能更高</li>
</ul>
</li>
</ul>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><h3 id="资源来源"><a href="#资源来源" class="headerlink" title="资源来源"></a>资源来源</h3><p>业务系统提供机器资源</p>
<p>定时任务平台提供机器资源</p>
<h3 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h3><ol>
<li>随机节点执行：选择一个可用执行节点执行</li>
<li>广播执行：在集群中的所有执行节点分发调度任务并执行，可用于批量运维</li>
<li>分片执行：按照用户自定义的分片逻辑进行拆分，分发到集群中的不同节点并行执行。</li>
</ol>
<p><img src="D:\Blog\source_images\image-20230213184303603.png" alt="image-20230213184303603"></p>
<p>高级特性：</p>
<ul>
<li>任务编排</li>
<li>故障转移<ul>
<li>通常通过一致性hash策略来分配任务，当某个Executor异常，会将未执行的任务进行<em><strong>re-hash</strong></em>分发到别的Executor</li>
</ul>
</li>
</ul>
<h3 id="高可用调度器"><a href="#高可用调度器" class="headerlink" title="高可用调度器"></a>高可用调度器</h3><p>调度器可以集群部署，因为调度器无状态，靠消息队列的重试机制保证任务一定会被调度</p>
<p><img src="D:\Blog\source_images\image-20230213184809941.png" alt="image-20230213184809941"></p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>在调度中心进行机器注册 –&gt; 执行器的弹性扩缩容</p>
<p>状态检测 –&gt; 定期上报状态</p>
<p><img src="D:\Blog\source_images\image-20230213185010100.png" alt="image-20230213185010100"></p>
]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Distributed System</title>
    <url>/2023/01/31/Distributed-System/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>优势:</p>
<ol>
<li>去中心化</li>
<li>低成本</li>
<li>弹性资源</li>
<li>资源共享</li>
<li>可靠性高</li>
</ol>
<p>挑战:</p>
<ol>
<li>普遍的节点故障</li>
<li>不可靠的网络</li>
<li>异构的机器和环境</li>
<li>安全</li>
</ol>
<span id="more"></span>



<h1 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h1><h1 id="共识和一致性"><a href="#共识和一致性" class="headerlink" title="共识和一致性"></a>共识和一致性</h1><p>Eventually Consistent</p>
<p>Linearizable</p>
<h1 id="时间和时间顺序"><a href="#时间和时间顺序" class="headerlink" title="时间和时间顺序"></a>时间和时间顺序</h1><p>happen before</p>
<p>Lamport逻辑时钟</p>
<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>C: Consistence (Strong consistence)</p>
<p>A: Availability</p>
<p>P: Network Partitioning</p>
<p>CA: 放弃分区容错性，加强一致性和可用性，即传统单机数据库</p>
<p>AP: 放弃一致性，追求一致性和可用性，用于注重用户体验的系统</p>
<p>CP: 放弃可用性，追求一致性和分区容错性，用于数据很关键的系统，例如银行系统</p>
<h2 id="ACID理论"><a href="#ACID理论" class="headerlink" title="ACID理论"></a>ACID理论</h2><p>transaction: 保证一个事务中的所有操作要么所有执行，要么所有不执行</p>
<p>A: Atomic, 所有的操作要么全部成功，要么全部失败回滚。强调<strong>操作</strong>。一定要保证。</p>
<p>C: Consistent, 数据库必须从一致性状态变换到另一个一致性(事务的一致性)状态。强调<strong>状态</strong>。一定要保证。</p>
<p>I: Isolation, 多个用户并发访问的时候，</p>
<p>D: Duration</p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>AP系统: </p>
<p>Basically Available(基本可用):</p>
<p>Soft State(软状态):</p>
<p>Eventually Consistent(最终一致性):</p>
<h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><h2 id="Quorum-NWR"><a href="#Quorum-NWR" class="headerlink" title="Quorum NWR"></a>Quorum NWR</h2><p>N: 在分布式存储系统中有多少个备份 </p>
<p>W: 一次成功的更新有多少次写入成功</p>
<p>R: 一次成功的读操作至少要求有R份数据成功读取</p>
<p>通常用于Append Only系统</p>
<p>Quorum NWR 将CAP的选择交给用户</p>
<h2 id="RAFT协议"><a href="#RAFT协议" class="headerlink" title="RAFT协议"></a>RAFT协议</h2><p>通常一个系统是一个leader和多个follower</p>
<p>Leader:</p>
<p>Follower:</p>
<p>Candidate:</p>
<p>Log: 节点之间的信息同步，之追加写的方式进行同步，解决了数据被覆盖的问题</p>
<p>Term: 单调递增，每个term内只能有一个leader</p>
<p>Committed: 日志被复制到多个节点，即认为Committed</p>
<p>Applied: 日志应用到了本地状态机</p>
<p>Leader选举过程：</p>
<ul>
<li>初始全部为Follower</li>
<li>Current Term + 1</li>
<li>选举自己</li>
<li>向其它参与者发起RequestVote请求，retry直到<ul>
<li>收到多数派请求，成为Leader，并发送心跳</li>
<li>收到其它Leader的请求，转为Follower，更新自己的Term</li>
<li>收到部分，但未达到多数派，选举超时，随机timeout开始下一轮</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Memory Model</title>
    <url>/2023/01/31/Go-Memory-Model/</url>
    <content><![CDATA[<h1 id="Memory-Model"><a href="#Memory-Model" class="headerlink" title="Memory Model"></a>Memory Model</h1><p>One example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> done <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">42</span></span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> setup()</span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>The example above may have 3 possibilities:</p>
<ul>
<li>print 42</li>
<li>never return</li>
<li>print 0</li>
</ul>
<p>Why:</p>
<ul>
<li><em>Reordering</em><ul>
<li>Compiler and Processor can reorder the instructions</li>
</ul>
</li>
<li><em>Memory Visibility</em><ul>
<li>Registers; L1, L2, shared L3 cache; CPU sockets</li>
</ul>
</li>
</ul>
<p><em>Go Concurrency Primitives</em>: Goroutines, Channels</p>
<p><em>Go memory model</em>: specifies the conditions under which read of a variable in one goroutine can observe values produced by writes to the same variable in another goroutine.</p>
<p><em>Data race</em>: write to a <em>memory location</em> happening <em>concurrently</em> with another <strong>read</strong> or <strong>write</strong> to that same location. Unless all the accesses involved are <strong>atomic</strong>.</p>
<h2 id="Within-a-Single-Goroutine"><a href="#Within-a-Single-Goroutine" class="headerlink" title="Within a Single Goroutine"></a>Within a Single Goroutine</h2><ul>
<li>Reads and writes must behave as if they <strong>executed in the order specified by the program</strong>.</li>
<li><strong>Compiler can reorder</strong> as long as it doesn’t change the behavior defined in the language specification.</li>
<li><strong>Order observed by one goroutine may differ from order perceived by another</strong>.<ul>
<li>goroutine 1 sets <code>a=1, b=2</code>, but goroutine 2 may see <code>b=2</code> first, and later see <code>a=1</code>.</li>
</ul>
</li>
</ul>
<h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h2><ul>
<li>Happens-Before is <strong>partial ordering of operations</strong></li>
<li>Happens-Before is <strong>transitive</strong></li>
<li>Within a single goroutine, happens-before order is the order expressed by program</li>
<li><strong>To guarantee a read of a variable observes a write to the same variable, the write must happen before the read</strong></li>
<li><strong>If two operation don’t have happen-before relation, they happen concurrently</strong></li>
<li><strong>Certain operation creates happen-before relation: lock, etc</strong></li>
</ul>
<h2 id="What-creates-happens-before"><a href="#What-creates-happens-before" class="headerlink" title="What creates happens-before"></a>What creates happens-before</h2><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>Program initialization runs in a single goroutine, but that goroutine may create other goroutines, which run concurrently.</p>
<p><em>If a package</em> <code>p</code> <em>imports package</em> <code>q</code><em>, the completion of</em> <code>q</code><em>‘s</em> <code>init</code> <em>functions happens before the start of any of</em> <code>p</code><em>‘s.</em></p>
<p><em>The completion of all</em> <code>init</code> <em>functions is synchronized before the start of the function</em> <code>main.main</code><em>.</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for example, if q import p, </span></span><br><span class="line"><span class="comment">// then p.init-&gt;q.init-&gt;main.main</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// q.go</span></span><br><span class="line"><span class="keyword">package</span> q</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;p&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p.go</span></span><br><span class="line"><span class="keyword">package</span> p</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Goroutine-Creation"><a href="#Goroutine-Creation" class="headerlink" title="Goroutine Creation"></a>Goroutine Creation</h3><p>The go statement that start a new goroutine <strong>happens before</strong> the goroutine’s execution begins</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span> <span class="comment">// happens before print statement</span></span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Goroutine-Destruction"><a href="#Goroutine-Destruction" class="headerlink" title="Goroutine Destruction"></a>Goroutine Destruction</h3><p>The exit of a goroutine is <strong>not guaranteed to be synchronized before any event</strong> in the program.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a = <span class="string">&quot;hello world&quot;</span> &#125;() </span><br><span class="line">    <span class="comment">// an aggressive compiler might even delete the entire go statement.</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel-Communication"><a href="#Channel-Communication" class="headerlink" title="Channel Communication"></a>Channel Communication</h3><p>A send on a channel <strong>happens before</strong> the corresponding receive from that channel completes.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span>	<span class="comment">// happens before the print statement</span></span><br><span class="line">    c &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    &lt;-c</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The closing of a channel <strong>happens before</strong> a receive that returns a zero value because the close is closed.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span>	<span class="comment">// happens before the print statement</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    &lt;-c</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A receive from an unbuffered channel <strong>happens before</strong> the send on that channel completes.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span>	<span class="comment">// happens before the print statement</span></span><br><span class="line">    &lt;-c	<span class="comment">// happens before the print statement(where send operation completes)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    c &lt;- <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>The</em> $k$th receive on a channel with capacity $C$ is synchronized before the completion of the $k+C$th send from that channel completes.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        w := w</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c &lt;- <span class="number">0</span></span><br><span class="line">            w()</span><br><span class="line">            &lt;-c</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h3><p><em>For any</em> <code>sync.Mutex</code> <em>or</em> <code>sync.RWMutex</code> <em>variable</em> <code>mu</code> <em>and</em> n &lt; m, call n <em>of</em> <code>mu.Unlock()</code> <em>is synchronized before call</em> m <em>of</em> <code>mu.Lock()</code> <em>returns.</em></p>
<p>For any call to <code>l.RLock</code> on a <code>sync.RWMutex</code> variable <code>l</code>, there is an <em>n</em> such that the <em>n</em>th call to <code>l.Unlock</code> is synchronized before the return from <code>l.RLock</code>, and the matching call to <code>l.RUnlock</code> is synchronized before the return from call <em>n</em>+1 to <code>l.Lock</code>.</p>
<p>A successful call to <code>l.TryLock</code> (or <code>l.TryRLock</code>) is equivalent to a call to <code>l.Lock</code> (or <code>l.RLock</code>). An unsuccessful call has no synchronizing effect at all. As far as the memory model is concerned, <code>l.TryLock</code> (or <code>l.TryRLock</code>) may be considered to be able to return false even when the mutex <em>l</em> is unlocked.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The first call to <code>mu.Unlock()</code> (in <code>f</code>) is synchronized before the second call to <code>mu.Lock()</code> (in <code>main</code>) returns, which is <em>sequenced before</em> the <code>print</code>.</p>
<h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>The <code>sync</code> package provides a safe mechanism for initialization in the presence of multiple goroutines through the use of the <code>Once</code> type. Multiple threads can execute <code>once.Do(f)</code> for a particular <code>f</code>, but only one will run <code>f()</code>, and the other calls block until <code>f()</code> has returned.</p>
<p>A completion of a single call of <code>f()</code> from <code>once.Do(f)</code> <strong>happens before</strong> any call of <code>once.Do(f)</code> returns</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello world&quot;</span>	<span class="comment">//happens before the print</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    once.Do(setup)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Atomic-Values"><a href="#Atomic-Values" class="headerlink" title="Atomic Values"></a>Atomic Values</h3><p>If the effect of an atomic operation <em>A</em> is observed by atomic operation <em>B</em>, then <em>A</em> is synchronized before <em>B</em>. All the atomic operations executed in a program behave as though executed in some sequentially consistent order.</p>
<p>The definition of atomic values has the same semantics as C++’s sequentially consistent atomics and Java’s <code>volatile</code> variables.</p>
<h3 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h3><p>The <a href="https://go.dev/pkg/runtime/"><code>runtime</code></a> package provides a <code>SetFinalizer</code> function that adds a finalizer to be called when the object is no longer reachable by the program. Garbage Collector will clear the association and runs finalizer in a separate goroutine.</p>
<p>A call to <code>SetFinalizer(x, f)</code> is synchronized before the finalization call <code>f(x)</code>.</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><ul>
<li>Functions in the sync package<ul>
<li>Wait Groups</li>
<li>Allocation Pools</li>
<li>Condition Variables</li>
<li>Lock-Free Maps</li>
</ul>
</li>
</ul>
<h2 id="Why-Is-Data-Race-Harmful"><a href="#Why-Is-Data-Race-Harmful" class="headerlink" title="Why Is Data Race Harmful"></a>Why Is Data Race Harmful</h2><p>Data race is not ok, it doesn’t just give you stale values.</p>
<ul>
<li>Memory corruption</li>
<li>Panics<ul>
<li>unexpected fault address: 0x0</li>
<li>fatal error: concurrent map read and write</li>
</ul>
</li>
<li>May be fine now, but cause problems at any time</li>
<li>Program will break when compiler upgrades, switch OS, switch processor.<ul>
<li>compiler optimization strategy</li>
<li>different processors have different reordering strategies</li>
</ul>
</li>
</ul>
<h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">        instance = &amp;singleton&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Problems:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instance = &amp;singleton&#123;3, 4&#125;</span><br></pre></td></tr></table></figure>

<p>to</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := singleton&#123;&#125;</span><br><span class="line">s.x = <span class="number">3</span></span><br><span class="line">s.y = <span class="number">4</span></span><br><span class="line">instance = &amp;s</span><br></pre></td></tr></table></figure>

<p>can be reordered to</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := singleton&#123;&#125;</span><br><span class="line">instance = &amp;s</span><br><span class="line">s.x = <span class="number">3</span></span><br><span class="line">s.y = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>Assume there are 2 goroutines, goroutine 1 is executing <code>instance = &amp;s</code>, and at this point goroutine 2 sees that <code>instance != nil</code>, and returns it, and then get the partially created instance </p>
<p>Essence: synchronize the read and write</p>
<h1 id="Formal-Memory-Model"><a href="#Formal-Memory-Model" class="headerlink" title="Formal Memory Model"></a>Formal Memory Model</h1><h2 id="Memory-Operation"><a href="#Memory-Operation" class="headerlink" title="Memory Operation"></a>Memory Operation</h2><p>A memory operation is modeled by 4 details:</p>
<ul>
<li>its <strong>kind</strong>, indicating whether it is an <em>ordinary data read</em>, an <em>ordinary data write</em>, or a <em>synchronizing operation</em> such as an <em>atomic data access</em>, a <em>mutex operation</em>, or a <em>channel operation</em>,</li>
<li>its <strong>location</strong> in the program,</li>
<li>the <strong>memory location</strong> or variable being accessed,</li>
<li>the <strong>values</strong> read or written by the operation.</li>
</ul>
<p>Read-like operation: read, atomic read, <strong>mutex lock</strong>, and <strong>channel receive</strong>.</p>
<p>Write-like operation: write, atomic write, <strong>mutex unlock</strong>, <strong>channel send</strong>, and <strong>channel close</strong>.</p>
<p>Both read-like and write-like: atomic compare-and-swap.</p>
<p>A goroutine execution is a set of memory operations executed by a single goroutine.</p>
<h2 id="Requirement-of-Memory-Model"><a href="#Requirement-of-Memory-Model" class="headerlink" title="Requirement of Memory Model"></a>Requirement of Memory Model</h2><p>Requirements:</p>
<ol>
<li>The memory operations in each goroutine must correspond to a correct sequential execution of that goroutine. That execution must be consistent with the <em><strong>sequenced before</strong></em> relation.</li>
<li>For a given program execution, the mapping <em>W</em>, when limited to synchronizing operations, must be explainable by some implicit total order of the synchronizing operations that is consistent with sequencing and the values read and written by those operations.</li>
<li>For an ordinary (non-synchronizing) data read <em>r</em> on a memory location <em>x</em>, <em>W</em>(<em>r</em>) must be a write <em>w</em> that is <em>visible</em> to <em>r</em>, where visible means that both of the following hold:<ol>
<li><em>w</em> happens before <em>r</em>.</li>
<li><em>w</em> does not happen before any other write <em>w’</em> (to <em>x</em>) that happens before <em>r</em>.</li>
</ol>
</li>
</ol>
<p>The <em><strong>sequential before</strong></em> relation is the memory operation order within a single goroutine</p>
<p>The <em><strong>synchronized before</strong></em> relation is a partial order on synchronizing memory operations, derived from <em>W</em></p>
<p>The <em><strong>happens before</strong></em> relation is defined as the <strong>transitive closure</strong> of the union of the <strong>sequenced before</strong> and <strong>synchronized before</strong> relations.</p>
<p>A Go <em>program execution</em> is modeled as</p>
<ul>
<li>a set of goroutine executions,</li>
<li>together with a mapping <em>W</em> that specifies the write-like operation that each read-like operation reads from.</li>
</ul>
<h2 id="DRF-SC"><a href="#DRF-SC" class="headerlink" title="DRF-SC"></a>DRF-SC</h2><p><em>DRF-SC</em>: data-race-free programs execute in a sequentially consistent manner.</p>
<p><em>Data races</em>:</p>
<ul>
<li>A <em>read-write data race</em> on memory location <em>x</em> consists of a read-like memory operation <em>r</em> on <em>x</em> and a write-like memory operation <em>w</em> on <em>x</em>, at least one of which is non-synchronizing, which are unordered by happens before (that is, neither <em>r</em> happens before <em>w</em> nor <em>w</em> happens before <em>r</em>).</li>
<li>A <em>write-write data race</em> on memory location <em>x</em> consists of two write-like memory operations <em>w</em> and <em>w’</em> on <em>x</em>, at least one of which is non-synchronizing, which are unordered by happens before.</li>
</ul>
<p>Data-race-free program:</p>
<ul>
<li>A Go program without <em>read-write data race</em> and <em>write-write data race</em> is data-race-free.</li>
<li>It have outcomes explained by some sequentially consistent interleaving of the goroutine executions. </li>
<li>This property is called DRF-SC</li>
</ul>
<h2 id="Implementation-Restrictions-of-Data-Races"><a href="#Implementation-Restrictions-of-Data-Races" class="headerlink" title="Implementation Restrictions of Data Races"></a>Implementation Restrictions of Data Races</h2><p>First, any implementation can, upon detecting a data race, report the race and halt execution of the program. Implementations using ThreadSanitizer (accessed with “<code>go</code> <code>build</code> <code>-race</code>”) do exactly this.</p>
<p>Otherwise, a read <em>r</em> of a memory location <em>x</em> that is not larger than a machine word must observe some write <em>w</em> such that <em>r</em> does not happen before <em>w</em> and there is no write <em>w’</em> such that <em>w</em> happens before <em>w’</em> and <em>w’</em> happens before <em>r</em>. That is, each read must observe a value written by a preceding or concurrent write.</p>
<p>Additionally, observation of acausal and “out of thin air” writes is disallowed.</p>
<p>Reads of memory locations larger than a single machine word are encouraged but not required to meet the same semantics as word-sized memory locations, observing a single allowed write <em>w</em>. For performance reasons, implementations may instead treat larger operations as a set of individual machine-word-sized operations in an unspecified order. This means that races on multiword data structures can lead to inconsistent values not corresponding to a single write. When the values depend on the consistency of internal (pointer, length) or (pointer, type) pairs, as can be the case for interface values, maps, slices, and strings in most Go implementations, such races can in turn lead to arbitrary memory corruption.</p>
<h2 id="Implementation-Restriction-Example"><a href="#Implementation-Restriction-Example" class="headerlink" title="Implementation Restriction Example"></a>Implementation Restriction Example</h2><p>The Go memory model restricts compiler optimizations as much as it does Go programs. Some compiler optimizations that would be valid in single-threaded programs are not valid in all Go programs. </p>
<p>In particular, </p>
<ul>
<li>a compiler <strong>must not introduce writes that do not exist in the original program</strong>, </li>
<li>it <strong>must not allow a single read to observe multiple values</strong>, </li>
<li>and it <strong>must not allow a single write to write multiple values</strong>.</li>
</ul>
<p>Not introducing data races into race-free programs means not moving writes out of conditional statements in which they appear. </p>
<p>Not introducing data races also means not assuming that loops terminate. </p>
<p>Not introducing data races also means not assuming that called functions always return or are free of synchronization operations. </p>
<p>Not allowing a single read to observe multiple values means not reloading local variables from shared memory. </p>
<p>Not allowing a single write to write multiple values also means not using the memory where a local variable will be written as temporary storage before the write.</p>
<p>Note that all these optimizations are permitted in C&#x2F;C++ compilers: a Go compiler sharing a back end with a C&#x2F;C++ compiler must take care to disable optimizations that are invalid for Go.</p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>System Design</title>
    <url>/2023/01/30/System-Design/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><ul>
<li>软件整体结构和组件的抽象描述</li>
<li>用于指导软件系统各个方面的设计</li>
</ul>
<h2 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h2><p>所有功能都实现在一个进程中，并部署在一个机器上</p>
<p>问题：</p>
<ul>
<li>C10K problem</li>
<li>运维需要停服</li>
</ul>
<span id="more"></span>

<h2 id="单体架构-垂直应用架构"><a href="#单体架构-垂直应用架构" class="headerlink" title="单体架构 | 垂直应用架构"></a>单体架构 | 垂直应用架构</h2><p>单体：分布式部署，每个机器都有所有功能</p>
<p>垂直应用：分布式部署，按应用垂直切分的单体</p>
<p>优点：</p>
<ul>
<li>水平扩容</li>
<li>运维不需要停服</li>
</ul>
<p>缺点：</p>
<ul>
<li>职责太多，效率不高</li>
</ul>
<h2 id="SOA架构-微服务架构"><a href="#SOA架构-微服务架构" class="headerlink" title="SOA架构 | 微服务架构"></a>SOA架构 | 微服务架构</h2><p>SOA:</p>
<ul>
<li>将应用的不同功能单元抽象为服务</li>
<li>定义服务之间的通信标准</li>
</ul>
<p>微服务：SOA去中心化</p>
<p>问题：</p>
<ul>
<li>数据一致性</li>
<li>高可用：如何协同合作</li>
<li>治理：服务出错时的容灾</li>
<li>解耦 vs 过微：运维成本上升</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需求量增大 –&gt; 增加机器</p>
<p>需求复杂 –&gt; 分工工作</p>
<p>演进思路：</p>
<ul>
<li>垂直切分</li>
<li>水平切分: 耦合性降低，模块独立性变强</li>
</ul>
<h1 id="架构剖析"><a href="#架构剖析" class="headerlink" title="架构剖析"></a>架构剖析</h1><h2 id="Cloud-Computing"><a href="#Cloud-Computing" class="headerlink" title="Cloud Computing"></a>Cloud Computing</h2><p>云计算：通过<strong>软件自动化管理</strong>，<strong>提供计算资源</strong>的<strong>服务网络</strong></p>
<p>基础：</p>
<ul>
<li>虚拟化技术 - 整租 &amp; 合租</li>
<li>编排方案 - 业主 &amp; 租赁平台</li>
</ul>
<p>架构：</p>
<ul>
<li>IaaS (Infrastructure as a Service) –&gt; 房屋租赁平台 &amp; 买房子(繁琐)</li>
<li>PaaS (Platform as a Service) –&gt; 全包 &amp; 清包(繁琐)</li>
<li>SaaS (Software as a Service) –&gt; 雇佣培训过的师傅 &amp; 从零培训师傅(繁琐)</li>
<li>FaaS (Function as a Service) –&gt; 批量生产 &amp; 手工生产(繁琐)</li>
</ul>
<h2 id="Cloud-Native"><a href="#Cloud-Native" class="headerlink" title="Cloud Native"></a>Cloud Native</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Cloud Native:</p>
<ul>
<li>弹性资源<ul>
<li>虚拟化容器</li>
<li>快速扩缩容</li>
</ul>
</li>
<li>微服务架构<ul>
<li>业务的功能单元解耦</li>
<li>统一的通信标准</li>
</ul>
</li>
<li>DevOps<ul>
<li>Swift Development</li>
<li>CI&#x2F;CD</li>
</ul>
</li>
<li>服务网格<ul>
<li>业务与治理结构</li>
<li>异构系统的治理统一化</li>
<li>复杂治理能力</li>
</ul>
</li>
</ul>
<h3 id="弹性资源"><a href="#弹性资源" class="headerlink" title="弹性资源"></a>弹性资源</h3><p>弹性计算资源分类：</p>
<ul>
<li>服务资源调度 (占用资源量级)<ul>
<li>微服务 (使用量比较低)</li>
<li>大服务 (使用量比较高)</li>
</ul>
</li>
<li>计算资源调度<ul>
<li>在线: 榜单 </li>
<li>离线: 榜单更新</li>
</ul>
</li>
<li>消息队列<ul>
<li>在线: 削峰，解耦</li>
<li>离线: 大数据分析</li>
</ul>
</li>
</ul>
<p>弹性存储资源分类：</p>
<ul>
<li>经典<ul>
<li>对象: 宣传视频等</li>
<li>大数据: 用户消费记录</li>
</ul>
</li>
<li>关系型数据库<ul>
<li>收银记录</li>
</ul>
</li>
<li>元数据<ul>
<li>服务发现</li>
</ul>
</li>
<li>NoSQL<ul>
<li>KV数据</li>
</ul>
</li>
</ul>
<h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>云原生时代软件交付的工具</p>
<p><img src="D:\Blog\source_images\image-20230130173228027.png" alt="image-20230130173228027"></p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>通信标准：</p>
<ul>
<li>HTTP</li>
<li>RPC</li>
</ul>
<p>微服务中间件： RPC or HTTP</p>
<ul>
<li>性能: RPC wins</li>
<li>服务治理: RPC wins</li>
<li>协议可解释性: HTTP wins</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230130173731025.png" alt="image-20230130173731025"></p>
<h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><p>Service Mesh (服务网格)</p>
<ul>
<li>微服务之间通信的中间层</li>
<li>高性能网络代理</li>
<li>业务代码和服务网格解耦</li>
</ul>
<p>对比 RPC&#x2F;HTTP 框架</p>
<ul>
<li>异构系统治理统一化</li>
<li>与业务进程解耦，生命周期易于管理</li>
</ul>
<h2 id="架构挑战"><a href="#架构挑战" class="headerlink" title="架构挑战"></a>架构挑战</h2><ul>
<li>基础设施层面<ul>
<li>物理资源是有限的<ul>
<li>机器是有限的</li>
<li>带宽是有限的</li>
</ul>
</li>
<li>资源利用率受制于部署服务</li>
</ul>
</li>
<li>用户层面<ul>
<li>网络通信开销增大</li>
<li>网络抖动导致运维成本增高</li>
<li>异构环境下，不同实例资源水位不均</li>
</ul>
</li>
</ul>
<h2 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h2><h3 id="离在线资源并池"><a href="#离在线资源并池" class="headerlink" title="离在线资源并池"></a>离在线资源并池</h3><p>核心收益：降低物理资源成本，提供更多的弹性资源 –&gt; 合并在线池和离线池</p>
<p>在线业务的特点：</p>
<ul>
<li>IO 密集型为主</li>
<li>潮汐性，实时性</li>
</ul>
<p>离线业务的特点：</p>
<ul>
<li>计算密集型</li>
<li>非实时性</li>
</ul>
<h3 id="资源的扩缩容"><a href="#资源的扩缩容" class="headerlink" title="资源的扩缩容"></a>资源的扩缩容</h3><p>利用在线业务的潮汐性做自动扩缩容，结合离在线资源并池</p>
<h3 id="微服务的亲和性部署"><a href="#微服务的亲和性部署" class="headerlink" title="微服务的亲和性部署"></a>微服务的亲和性部署</h3><ul>
<li>将满足亲和性条件的容器调度到一台宿主机</li>
<li>微服务中间件和服务网格通过共享内存或IPC方式通信</li>
<li>服务网格控制面实施动态灵活的流量调度</li>
</ul>
<h3 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h3><ul>
<li>提高微服务的容错性</li>
<li>容灾</li>
<li>提高开发效率</li>
</ul>
<p>解决思路：基于微服务的中间件 &amp; 服务网格的流量治理</p>
<ul>
<li>熔断、重试</li>
<li>单元化</li>
<li>复杂环境(功能、预览)的流量调度</li>
</ul>
<h3 id="CPU水位负载均衡"><a href="#CPU水位负载均衡" class="headerlink" title="CPU水位负载均衡"></a>CPU水位负载均衡</h3><p>核心收益：</p>
<ul>
<li>异构环境算力差异</li>
<li>自动扩缩容</li>
</ul>
<p>解决思路：CPU水位负载均衡</p>
<ul>
<li>IaaS: 提供资源探针</li>
<li>服务网格: 动态负载均衡</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230130225126408.png" alt="image-20230130225126408"></p>
<h1 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h1>]]></content>
      <tags>
        <tag>System</tag>
      </tags>
  </entry>
  <entry>
    <title>gorm</title>
    <url>/2023/01/24/gorm/</url>
    <content><![CDATA[<h1 id="GORM"><a href="#GORM" class="headerlink" title="GORM"></a>GORM</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">APP --&gt; gorm --&gt; database/sql --&gt; 数据库</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="SQL生成"><a href="#SQL生成" class="headerlink" title="SQL生成"></a>SQL生成</h2><p>gorm statement: chain method(GORM Clauses) + finish method(决定类型&amp;执行)</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>对于finish method来说，调用一系列callback注册的方法</p>
<p>例如，对于Create方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:begin_transaction&quot;</span>, BeginTransaction)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:before_create&quot;</span>, BeforeCreate)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:save_before_associations&quot;</span>, SaveBeforeAssociations)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:create&quot;</span>, Create)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:save_after_associations&quot;</span>, SaveAfterAssociations)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:after_create&quot;</span>, AfterCreate)</span><br><span class="line">db.Callback().Create().Register(<span class="string">&quot;gorm:commit_or_rollback_transaction&quot;</span>, CommitOrRollbackTransaction)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// pseudo code</span></span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> db.callbacks.creates &#123;</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展插件系统：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Callback.Create().Register(<span class="string">&quot;&quot;</span>, fn)</span><br><span class="line"><span class="comment">// Remove</span></span><br><span class="line"><span class="comment">// Replace</span></span><br><span class="line"><span class="comment">// Get</span></span><br><span class="line"><span class="comment">// Before, After</span></span><br></pre></td></tr></table></figure>

<h2 id="ConnPool"><a href="#ConnPool" class="headerlink" title="ConnPool"></a>ConnPool</h2><h2 id="Dialector"><a href="#Dialector" class="headerlink" title="Dialector"></a>Dialector</h2>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd</title>
    <url>/2023/01/23/etcd/</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="etcd-简介"><a href="#etcd-简介" class="headerlink" title="etcd 简介"></a>etcd 简介</h2><p>A distributed, reliable key-value store for critical data of distributed systems</p>
<ul>
<li>分布式键值存储</li>
<li>配置共享</li>
<li>服务发现</li>
<li>分布式锁</li>
<li>分布式队列</li>
<li>分布式通知与协调</li>
<li>主备选举</li>
</ul>
<span id="more"></span>

<h2 id="etcd-架构"><a href="#etcd-架构" class="headerlink" title="etcd 架构"></a>etcd 架构</h2><p><img src="D:\Blog\source_images\image-20230123211311435.png" alt="image-20230123211311435"></p>
<h2 id="etcd-集群部署"><a href="#etcd-集群部署" class="headerlink" title="etcd 集群部署"></a>etcd 集群部署</h2><h3 id="单节点伪集群部署"><a href="#单节点伪集群部署" class="headerlink" title="单节点伪集群部署"></a>单节点伪集群部署</h3><p>etcd参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>–name</td>
<td>etcd节点名</td>
</tr>
<tr>
<td>–initial-cluster</td>
<td>etcd启动时，通过这个配置找到别的etcd节点的地址列表。格式“name&#x3D;<a href="http://ip:port,...”">http://ip:port,...”</a></td>
</tr>
<tr>
<td>–initial-cluster-state</td>
<td>初始化集群的时候，存在“new”和“existing”两种状态。new表示新建的集群，existing表示加入已存在的集群</td>
</tr>
<tr>
<td>–listen-client-urls</td>
<td>监听客户端请求的地址列表。格式“<a href="http://ip:port,...”">http://ip:port,...”</a></td>
</tr>
<tr>
<td>–advertise-client-urls</td>
<td>从多个listen-client-urls中选出一个建议的监听地址</td>
</tr>
<tr>
<td>-listen-peer-urls</td>
<td>服务端节点之间通信的监听地址。格式“<a href="http://ip:port”">http://ip:port”</a></td>
</tr>
<tr>
<td>–initial-listen-peer-urls</td>
<td>建议服务端之间通讯使用的地址列表</td>
</tr>
</tbody></table>
<h3 id="多节点集群部署"><a href="#多节点集群部署" class="headerlink" title="多节点集群部署"></a>多节点集群部署</h3><ul>
<li><p>静态配置</p>
<ul>
<li>节点数量已知</li>
<li>节点的ip地址已知</li>
</ul>
</li>
<li><p>etcd动态发现</p>
<ul>
<li>使用<code>curl https://discovery.etcd.io/new?size=3</code>获取三个节点的动态集群</li>
<li>使用<code>--discovery $&#123;DISCOVERY&#125;</code>添加集群节点</li>
<li>不需要指定<code>--initial-cluster</code></li>
</ul>
</li>
</ul>
<p><code>etcdctl --endpoints=$ENDPOINTS member list</code> 可以列出一个集群中所有的节点信息</p>
]]></content>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC</title>
    <url>/2023/01/22/gRPC/</url>
    <content><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><img src="D:\Blog\source_images\image-20230122215840994.png" alt="image-20230122215840994"></p>
<p>缺点：</p>
<ul>
<li>隔离性差，某个服务的宕机会导致所有服务不可用</li>
<li>伸缩性差，只能整体服务进行伸缩</li>
<li>代码耦合在一起，可维护性差</li>
</ul>
<p>解决方案：微服务</p>
<span id="more"></span>

<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="D:\Blog\source_images\image-20230122220029728.png" alt="image-20230122220029728"></p>
<p>微服务架构解决了单体架构的一些致命问题，但是又引入了新的问题：</p>
<ul>
<li>代码冗余，一些公共代码存在于多个服务集群中</li>
<li>服务与服务之间存在调用关系</li>
</ul>
<h3 id="代码冗余问题"><a href="#代码冗余问题" class="headerlink" title="代码冗余问题"></a>代码冗余问题</h3><p>服务未拆分以前，公共功能有统一的实现，如认证、限流、授权等，服务拆分以后，每个服务可能都需要实现一遍</p>
<p>解决方案：</p>
<ul>
<li>使用网关，保证对外的出口一致性，网关根据不同的请求，将其转发到不同的服务(路由)<ul>
<li>由于出口的一致性，可以在网关上实现一些公共功能</li>
</ul>
</li>
<li>可以将公共功能抽取出来，形成一个新的服务，如统一认证中心</li>
</ul>
<h3 id="服务之间的调用"><a href="#服务之间的调用" class="headerlink" title="服务之间的调用"></a>服务之间的调用</h3><p>使用RPC进行调用，但是存在一个问题：如何直到调用哪台机器上的服务，调用方可能需要维护被调用方的地址，等。因此需要引入<strong>服务治理</strong></p>
<p><img src="D:\Blog\source_images\image-20230122223050971.png" alt="image-20230122223050971"></p>
<p><code>服务注册</code>，服务方将服务注册到注册中心</p>
<p><code>服务发现</code>，向注册中心请求服务的地址</p>
<blockquote>
<p>服务与服务之间的调用会发生一些问题，为了避免连锁的雪崩反应，引入<code>服务容错</code></p>
<p>为了追踪调用经过的服务，需要引入<code>链路追踪</code></p>
</blockquote>
]]></content>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Protocol Buffer</title>
    <url>/2023/01/20/Protocol-Buffer/</url>
    <content><![CDATA[<h1 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Field-Numbers"><a href="#Field-Numbers" class="headerlink" title="Field Numbers"></a>Field Numbers</h3><ul>
<li>Field numbers in the range 1 through 15 take one byte to encode</li>
<li>Field numbers in the range 16 through 2047 take two bytes</li>
<li>Field numbers through 19000 to 19999 is reserved for implementation</li>
<li>Largest field number is $2^{29}-1$, or $536,870,911$</li>
</ul>
<span id="more"></span>

<h3 id="Field-Rules"><a href="#Field-Rules" class="headerlink" title="Field Rules"></a>Field Rules</h3><ul>
<li><code>singular</code>: a well-formed message can have zero or one of this field<ul>
<li>Whether or not it’s parsed from the wire cannot be determined</li>
<li>When set to default value, it will not be included when serializing</li>
</ul>
</li>
<li><code>optional</code>: the same as <code>singular</code>, except it check whether the value was explicitly set.<ul>
<li>If the field is set, and contains a value that was explicitly set or parsed from the wire. It will be serialized to the wire.</li>
<li>If the field is unset, it will return the default value, and will not be serialized to the wire.</li>
</ul>
</li>
<li><code>repeated</code>: this field type can be repeated zero or more times in a well-formed message.</li>
<li><code>map</code>: this is a paired key&#x2F;value field type.</li>
</ul>
<h3 id="Scalar-Value-Types"><a href="#Scalar-Value-Types" class="headerlink" title="Scalar Value Types"></a>Scalar Value Types</h3><table>
<thead>
<tr>
<th align="left">.proto Type</th>
<th align="left">Notes</th>
<th align="left">C++ Type</th>
<th align="left">Java&#x2F;Kotlin Type</th>
<th align="left">Python Type</th>
<th align="left">Go Type</th>
<th align="left">Ruby Type</th>
<th align="left">C# Type</th>
<th align="left">PHP Type</th>
<th align="left">Dart Type</th>
</tr>
</thead>
<tbody><tr>
<td align="left">double</td>
<td align="left"></td>
<td align="left">double</td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">float64</td>
<td align="left">Float</td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left"></td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">float32</td>
<td align="left">Float</td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">int32</td>
<td align="left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">int32</td>
<td align="left">Fixnum or Bignum (as required)</td>
<td align="left">int</td>
<td align="left">integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">int64</td>
<td align="left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long</td>
<td align="left">int64</td>
<td align="left">Bignum</td>
<td align="left">long</td>
<td align="left">integer&#x2F;string</td>
<td align="left">Int64</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">Uses variable-length encoding.</td>
<td align="left">uint32</td>
<td align="left">int</td>
<td align="left">int&#x2F;long</td>
<td align="left">uint32</td>
<td align="left">Fixnum or Bignum (as required)</td>
<td align="left">uint</td>
<td align="left">integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">Uses variable-length encoding.</td>
<td align="left">uint64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long</td>
<td align="left">uint64</td>
<td align="left">Bignum</td>
<td align="left">ulong</td>
<td align="left">integer&#x2F;string</td>
<td align="left">Int64</td>
</tr>
<tr>
<td align="left">sint32</td>
<td align="left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">int32</td>
<td align="left">Fixnum or Bignum (as required)</td>
<td align="left">int</td>
<td align="left">integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">sint64</td>
<td align="left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long</td>
<td align="left">int64</td>
<td align="left">Bignum</td>
<td align="left">long</td>
<td align="left">integer&#x2F;string</td>
<td align="left">Int64</td>
</tr>
<tr>
<td align="left">fixed32</td>
<td align="left">Always four bytes. More efficient than uint32 if values are often greater than 228.</td>
<td align="left">uint32</td>
<td align="left">int</td>
<td align="left">int&#x2F;long</td>
<td align="left">uint32</td>
<td align="left">Fixnum or Bignum (as required)</td>
<td align="left">uint</td>
<td align="left">integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">fixed64</td>
<td align="left">Always eight bytes. More efficient than uint64 if values are often greater than 256.</td>
<td align="left">uint64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long</td>
<td align="left">uint64</td>
<td align="left">Bignum</td>
<td align="left">ulong</td>
<td align="left">integer&#x2F;string</td>
<td align="left">Int64</td>
</tr>
<tr>
<td align="left">sfixed32</td>
<td align="left">Always four bytes.</td>
<td align="left">int32</td>
<td align="left">int</td>
<td align="left">int</td>
<td align="left">int32</td>
<td align="left">Fixnum or Bignum (as required)</td>
<td align="left">int</td>
<td align="left">integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">sfixed64</td>
<td align="left">Always eight bytes.</td>
<td align="left">int64</td>
<td align="left">long</td>
<td align="left">int&#x2F;long</td>
<td align="left">int64</td>
<td align="left">Bignum</td>
<td align="left">long</td>
<td align="left">integer&#x2F;string</td>
<td align="left">Int64</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left"></td>
<td align="left">bool</td>
<td align="left">boolean</td>
<td align="left">bool</td>
<td align="left">bool</td>
<td align="left">TrueClass&#x2F;FalseClass</td>
<td align="left">bool</td>
<td align="left">boolean</td>
<td align="left">bool</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.</td>
<td align="left">string</td>
<td align="left">String</td>
<td align="left">str&#x2F;unicode</td>
<td align="left">string</td>
<td align="left">String (UTF-8)</td>
<td align="left">string</td>
<td align="left">string</td>
<td align="left">String</td>
</tr>
<tr>
<td align="left">bytes</td>
<td align="left">May contain any arbitrary sequence of bytes no longer than 232.</td>
<td align="left">string</td>
<td align="left">ByteString</td>
<td align="left">str (Python 2) bytes (Python 3)</td>
<td align="left">[]byte</td>
<td align="left">String (ASCII-8BIT)</td>
<td align="left">ByteString</td>
<td align="left">string</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="Default-Values"><a href="#Default-Values" class="headerlink" title="Default Values"></a>Default Values</h3><p>The default value for repeated fields is empty</p>
<p>Default value for message type is dependent on languages</p>
<p>For scalar message fields, once a message is parsed there’s <strong>no way of telling whether a field was explicitly set to the default value</strong></p>
<h3 id="Enumerations"><a href="#Enumerations" class="headerlink" title="Enumerations"></a>Enumerations</h3><p>enum’s first constant must map to zero</p>
<p><code>option allow_alias = true;</code> can be used to define alias</p>
<h3 id="Importing-Definitions"><a href="#Importing-Definitions" class="headerlink" title="Importing Definitions"></a>Importing Definitions</h3><p><code>import public &quot;xx.proto&quot;</code> will allow proto files which import this proto file to use the definitions in xx.proto. </p>
<h2 id="Updating-a-Message-Type"><a href="#Updating-a-Message-Type" class="headerlink" title="Updating a Message Type"></a>Updating a Message Type</h2><p>Changing, adding, or removing fields:</p>
<ul>
<li><strong>Don’t change the field numbers</strong> for any existing fields.</li>
<li>When <strong>adding new fields</strong><ul>
<li>old message format can be parsed by new code (but new code should take care of default value)</li>
<li>new message format can be parsed by old code (old code just ignore the new fields)</li>
</ul>
</li>
<li>Fields can be removed when the fields are no longer used<ul>
<li>the field name and tag should be reserved</li>
<li>or add OBSELETE_ prefix to the field name</li>
</ul>
</li>
</ul>
<p>Compatible types:</p>
<ul>
<li><code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, and <code>bool</code> are all compatible</li>
<li><code>sint32</code> and <code>sint64</code> are compatible with each other</li>
<li><code>string</code> and <code>bytes</code> are compatible as long as the bytes are valid UTF-8</li>
<li><code>Embedded messages</code> are compatible with <code>bytes</code> if <strong>the bytes contain an encoded version of the message</strong></li>
<li><code>fixed32</code> is compatible with <code>sfixed32</code>, and <code>fixed64</code> with <code>sfixed64</code></li>
<li>For <code>string</code>, <code>bytes</code>, and <code>message fields</code>, <code>singular</code> fields are compatible with <code>repeated</code> fields<ul>
<li>For serialized repeated data as input, clients who expect singular field will take the last input.</li>
<li>not safe for numeric types, such as <code>int</code>, <code>bool</code>, and <code>enum</code>. Because repeated fields of numeric types can be serialized in the <a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">packed</a> format, which will not be parsed correctly when a singular field is expected.</li>
</ul>
</li>
</ul>
<p>Binary compatible but possibly API incompatible types:</p>
<ul>
<li><code>enum</code> is compatible with <code>int32</code>, <code>uint32</code>, <code>int64</code>, and <code>uint64</code> in terms of wire format<ul>
<li>But client code may treat them differently when the message is deserialized</li>
</ul>
</li>
<li>Changing a single <code>optional</code> field or extension into a member of a <strong>new</strong> <code>oneof</code> is binary compatible<ul>
<li>For Go, the API will change in incompatible ways</li>
</ul>
</li>
</ul>
<h2 id="Unknown-Fields"><a href="#Unknown-Fields" class="headerlink" title="Unknown Fields"></a>Unknown Fields</h2><ul>
<li>Before versions 3.5, unknown fields are <strong>discarded</strong></li>
<li>In versions 3.5 and later, unknown fields are <strong>retained</strong> and included in the serialized output.</li>
</ul>
<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p><code>Any</code> message type:</p>
<ul>
<li>allow using messages as embedded types without having their .proto definition</li>
<li>contains <code>bytes</code> and a <code>URL</code> which is unique identifier to that message’s type</li>
<li>to use <code>Any</code>, <code>&quot;google/protobuf/any.proto&quot;</code> should be imported</li>
<li>default type URL for a given message type is <code>type.googleapis.com/_packagename_._messagename_</code></li>
</ul>
<h2 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><p>When at most one field will be set at the same time, use oneof to enforce this behavior and save memory.</p>
<ul>
<li>Oneof fields are like regular fields</li>
<li>All the fields in a oneof share memory</li>
<li>At most one field in oneof can be set at the same time</li>
<li>if <em>multiple values are set, the last set value as determined by the order in the proto will overwrite all previous ones</em>.</li>
<li>Oneof fields can be any type except <code>map</code> and <code>repeated</code> fields</li>
<li>If you set a oneof field to the default value (such as setting an int32 oneof field to 0), the “case” of that oneof field will be set, and the value will be serialized on the wire.</li>
</ul>
<h3 id="Compatibility-Issue"><a href="#Compatibility-Issue" class="headerlink" title="Compatibility Issue"></a>Compatibility Issue</h3><p>Adding or Removing Fields:</p>
<ul>
<li>removing a field from a oneof is considered a <strong>backward incompatible</strong> change. <ul>
<li>new version binary cannot process old version message</li>
<li>the information that may be lost is whether the oneof was really set or not</li>
</ul>
</li>
<li>adding a field to a oneof is considered a <strong>forward incompatible</strong> change<ul>
<li>old version binary cannot process new version message, just reverse of removing a field</li>
</ul>
</li>
</ul>
<p>Moving Fields:</p>
<ul>
<li>Moving fields out of a oneof:<ul>
<li>move a single field into a new oneof –&gt; safe</li>
<li>move multiple fields into a new oneof<ul>
<li>considered backward incompatible</li>
<li>but it can be safe when it is known that only one of the fields will be set</li>
</ul>
</li>
<li>move fields into a oneof<ul>
<li>same as “move multiple fields into a new oneof”</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Deleting a Oneof Fields and Add It Back</p>
<ul>
<li>similar to Removing Fields, but this situation there are 3 versions</li>
</ul>
<p>Splitting or Merging a Oneof</p>
<ul>
<li>similar to Moving Existing Fields into Oneof, backward incompatible.</li>
</ul>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><h3 id="Features-1"><a href="#Features-1" class="headerlink" title="Features"></a>Features</h3><p><code>map&lt;key_type, value_type&gt; map_field = N;</code> will create a map field.</p>
<ul>
<li><code>key_type</code> can be <strong>integral type or string type</strong> (any scalar types except <strong>floating point</strong> and **bytes **type)</li>
<li><code>value_type</code> can be any type except another map type</li>
<li>map fields cannot be repeated</li>
<li>When parsing from wire, the last seen is used when there are duplicate keys</li>
</ul>
<h3 id="Backward-Compatibility"><a href="#Backward-Compatibility" class="headerlink" title="Backward Compatibility"></a>Backward Compatibility</h3><p>The map syntax is equivalent to the following on the wire</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">MapFieldEntry</span> &#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeated</span> MapFieldEntry map_field = N;</span><br></pre></td></tr></table></figure>

<h2 id="Defining-a-Service"><a href="#Defining-a-Service" class="headerlink" title="Defining a Service"></a>Defining a Service</h2><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Search(SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JSON-Mapping"><a href="#JSON-Mapping" class="headerlink" title="JSON Mapping"></a>JSON Mapping</h2><p>When parsing JSON-encoded data into a protocol buffer</p>
<ul>
<li>if a value is missing or if its value is <code>null</code>, it will be corresponding <a href="https://developers.google.com/protocol-buffers/docs/proto3#default">default value</a>.</li>
</ul>
<p>When generating JSON-encoded output from a protocol buffer</p>
<ul>
<li>if a protobuf field has a default value will be omitted</li>
<li>A field that is defined with the <code>optional</code> keyword supports field presence.</li>
</ul>
<table>
<thead>
<tr>
<th align="left">proto3</th>
<th align="left">JSON</th>
<th align="left">JSON example</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">message</td>
<td align="left">object</td>
<td align="left"><code>&#123;&quot;fooBar&quot;: v, &quot;g&quot;: null, …&#125;</code></td>
<td align="left">Generates JSON objects. Message field names are mapped to lowerCamelCase and become JSON object keys. If the <code>json_name</code> field option is specified, the specified value will be used as the key instead. Parsers accept both the lowerCamelCase name (or the one specified by the <code>json_name</code> option) and the original proto field name. <code>null</code> is an accepted value for all field types and treated as the default value of the corresponding field type.</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left">string</td>
<td align="left"><code>&quot;FOO_BAR&quot;</code></td>
<td align="left">The name of the enum value as specified in proto is used. Parsers accept both enum names and integer values.</td>
</tr>
<tr>
<td align="left">map&lt;K,V&gt;</td>
<td align="left">object</td>
<td align="left"><code>&#123;&quot;k&quot;: v, …&#125;</code></td>
<td align="left">All keys are converted to strings.</td>
</tr>
<tr>
<td align="left">repeated V</td>
<td align="left">array</td>
<td align="left"><code>[v, …]</code></td>
<td align="left"><code>null</code> is accepted as the empty list <code>[]</code>.</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left">true, false</td>
<td align="left"><code>true, false</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">string</td>
<td align="left"><code>&quot;Hello World!&quot;</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">bytes</td>
<td align="left">base64 string</td>
<td align="left"><code>&quot;YWJjMTIzIT8kKiYoKSctPUB+&quot;</code></td>
<td align="left">JSON value will be the data encoded as a string using standard base64 encoding with paddings. Either standard or URL-safe base64 encoding with&#x2F;without paddings are accepted.</td>
</tr>
<tr>
<td align="left">int32, fixed32, uint32</td>
<td align="left">number</td>
<td align="left"><code>1, -10, 0</code></td>
<td align="left">JSON value will be a decimal number. Either numbers or strings are accepted.</td>
</tr>
<tr>
<td align="left">int64, fixed64, uint64</td>
<td align="left">string</td>
<td align="left"><code>&quot;1&quot;, &quot;-10&quot;</code></td>
<td align="left">JSON value will be a decimal string. Either numbers or strings are accepted.</td>
</tr>
<tr>
<td align="left">float, double</td>
<td align="left">number</td>
<td align="left"><code>1.1, -10.0, 0, &quot;NaN&quot;, &quot;Infinity&quot;</code></td>
<td align="left">JSON value will be a number or one of the special string values “NaN”, “Infinity”, and “-Infinity”. Either numbers or strings are accepted. Exponent notation is also accepted. -0 is considered equivalent to 0.</td>
</tr>
<tr>
<td align="left">Any</td>
<td align="left"><code>object</code></td>
<td align="left"><code>&#123;&quot;@type&quot;: &quot;url&quot;, &quot;f&quot;: v, … &#125;</code></td>
<td align="left">If the <code>Any</code> contains a value that has a special JSON mapping, it will be converted as follows: <code>&#123;&quot;@type&quot;: xxx, &quot;value&quot;: yyy&#125;</code>. Otherwise, the value will be converted into a JSON object, and the <code>&quot;@type&quot;</code> field will be inserted to indicate the actual data type.</td>
</tr>
<tr>
<td align="left">Timestamp</td>
<td align="left">string</td>
<td align="left"><code>&quot;1972-01-01T10:00:20.021Z&quot;</code></td>
<td align="left">Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits. Offsets other than “Z” are also accepted.</td>
</tr>
<tr>
<td align="left">Duration</td>
<td align="left">string</td>
<td align="left"><code>&quot;1.000340012s&quot;, &quot;1s&quot;</code></td>
<td align="left">Generated output always contains 0, 3, 6, or 9 fractional digits, depending on required precision, followed by the suffix “s”. Accepted are any fractional digits (also none) as long as they fit into nano-seconds precision and the suffix “s” is required.</td>
</tr>
<tr>
<td align="left">Struct</td>
<td align="left"><code>object</code></td>
<td align="left"><code>&#123; … &#125;</code></td>
<td align="left">Any JSON object. See <code>struct.proto</code>.</td>
</tr>
<tr>
<td align="left">Wrapper types</td>
<td align="left">various types</td>
<td align="left"><code>2, &quot;2&quot;, &quot;foo&quot;, true, &quot;true&quot;, null, 0, …</code></td>
<td align="left">Wrappers use the same representation in JSON as the wrapped primitive type, except that <code>null</code> is allowed and preserved during data conversion and transfer.</td>
</tr>
<tr>
<td align="left">FieldMask</td>
<td align="left">string</td>
<td align="left"><code>&quot;f.fooBar,h&quot;</code></td>
<td align="left">See <code>field_mask.proto</code>.</td>
</tr>
<tr>
<td align="left">ListValue</td>
<td align="left">array</td>
<td align="left"><code>[foo, bar, …]</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Value</td>
<td align="left">value</td>
<td align="left"></td>
<td align="left">Any JSON value. Check <a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value">google.protobuf.Value</a> for details.</td>
</tr>
<tr>
<td align="left">NullValue</td>
<td align="left">null</td>
<td align="left"></td>
<td align="left">JSON null</td>
</tr>
<tr>
<td align="left">Empty</td>
<td align="left">object</td>
<td align="left"><code>&#123;&#125;</code></td>
<td align="left">An empty JSON object</td>
</tr>
</tbody></table>
<h1 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h1><h2 id="Principles"><a href="#Principles" class="headerlink" title="Principles"></a>Principles</h2><table>
<thead>
<tr>
<th align="left">ID</th>
<th align="left">Name</th>
<th align="left">Used For</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">VARINT</td>
<td align="left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">I64</td>
<td align="left">fixed64, sfixed64, double</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">LEN</td>
<td align="left">string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">SGROUP</td>
<td align="left">group start (deprecated)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">EGROUP</td>
<td align="left">group end (deprecated)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">I32</td>
<td align="left">fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message    := (tag value)*</span><br><span class="line"></span><br><span class="line">tag        := (field &lt;&lt; 3) bit-or wire_type;</span><br><span class="line">                encoded as varint</span><br><span class="line">value      := varint      for wire_type == VARINT,</span><br><span class="line">              i32         for wire_type == I32,</span><br><span class="line">              i64         for wire_type == I64,</span><br><span class="line">              len-prefix  for wire_type == LEN,</span><br><span class="line">              &lt;empty&gt;     for wire_type == SGROUP or EGROUP</span><br><span class="line"></span><br><span class="line">varint     := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64;</span><br><span class="line">                encoded as varints (sintN are ZigZag-encoded first)</span><br><span class="line">i32        := sfixed32 | fixed32 | float;</span><br><span class="line">                encoded as 4-byte little-endian;</span><br><span class="line">                memcpy of the equivalent C types (u?int32_t, float)</span><br><span class="line">i64        := sfixed64 | fixed64 | double;</span><br><span class="line">                encoded as 8-byte little-endian;</span><br><span class="line">                memcpy of the equivalent C types (u?int32_t, float)</span><br><span class="line"></span><br><span class="line">len-prefix := size (message | string | bytes | packed);</span><br><span class="line">                size encoded as varint</span><br><span class="line">string     := valid UTF-8 string (e.g. ASCII);</span><br><span class="line">                max 2GB of bytes</span><br><span class="line">bytes      := any sequence of 8-bit bytes;</span><br><span class="line">                max 2GB of bytes</span><br><span class="line">packed     := varint* | i32* | i64*,</span><br><span class="line">                consecutive values of the type specified in `.proto`</span><br></pre></td></tr></table></figure>

<h1 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h1><h2 id="Steaming-Multiple-Messages"><a href="#Steaming-Multiple-Messages" class="headerlink" title="Steaming Multiple Messages"></a>Steaming Multiple Messages</h2><p>Similar to HTTP &amp; TCP, </p>
<ul>
<li>use bytes to transfer data</li>
<li>define the format of data</li>
<li>extract information from the data according to the format.</li>
</ul>
<h2 id="Large-Data-Sets"><a href="#Large-Data-Sets" class="headerlink" title="Large Data Sets"></a>Large Data Sets</h2><p>divide large data structure to smaller ones</p>
<h2 id="Self-Describing-Messages"><a href="#Self-Describing-Messages" class="headerlink" title="Self-Describing Messages"></a>Self-Describing Messages</h2><p>use <code>import &quot;google/protobuf/descriptor.proto&quot;</code></p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/descriptor.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SelfDescribingMessage</span> &#123;</span><br><span class="line">  <span class="comment">// Set of FileDescriptorProtos which describe the type and its dependencies.</span></span><br><span class="line">  google.protobuf.FileDescriptorSet descriptor_set = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The message and its type, encoded as an Any message.</span></span><br><span class="line">  google.protobuf.Any message = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Fields-Presence"><a href="#Fields-Presence" class="headerlink" title="Fields Presence"></a>Fields Presence</h1><h2 id="Presence-Disciplines"><a href="#Presence-Disciplines" class="headerlink" title="Presence Disciplines"></a>Presence Disciplines</h2><p>Presence defines the <strong>semantics of translating</strong> between API representations and serialized representation</p>
<ul>
<li>The <em>no presence</em> discipline <strong>relies upon the field value</strong> to make decisions at (de)serialization time</li>
<li>The <em>explicit presence</em> discipline <strong>relies upon the explicit tracking state</strong></li>
</ul>
<h2 id="Presence-in-Wire-Format"><a href="#Presence-in-Wire-Format" class="headerlink" title="Presence in Wire Format"></a>Presence in Wire Format</h2><p>When serializing</p>
<ul>
<li>fields with <em>no presence</em> are not serialized if they contain their default value</li>
<li>fields with <em>presence</em> are serialized although they contain their default value</li>
</ul>
<p>When deserializing</p>
<ul>
<li>duplicate field values may be handled in different ways depending on the field definition<ul>
<li>Duplicate <code>repeated</code> fields are typically appended</li>
<li>Duplicate <code>optional</code> fields follows ‘the last one wins’ rules</li>
</ul>
</li>
<li>For enum fields, <em><strong>out-of-range values may be stored as unknown fields in the API</strong></em>, <strong>even though the wire-format tag was recognized</strong>.</li>
</ul>
<h2 id="Presence-in-Proto-3"><a href="#Presence-in-Proto-3" class="headerlink" title="Presence in Proto 3"></a>Presence in Proto 3</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Field type</td>
<td><code>optional</code></td>
<td>Explicit Presence</td>
</tr>
<tr>
<td>Singular numeric (integer or floating point)</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>Singular enum</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>Singular string or bytes</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>Singular numeric (integer or floating point)</td>
<td>Yes</td>
<td>✔️</td>
</tr>
<tr>
<td>Singular enum</td>
<td>Yes</td>
<td>✔️</td>
</tr>
<tr>
<td>Singular string or bytes</td>
<td>Yes</td>
<td>✔️</td>
</tr>
<tr>
<td>Singular message</td>
<td>Yes</td>
<td>✔️</td>
</tr>
<tr>
<td>Singular message</td>
<td>No</td>
<td>✔️</td>
</tr>
<tr>
<td>Repeated</td>
<td>N&#x2F;A</td>
<td></td>
</tr>
<tr>
<td>Oneofs</td>
<td>N&#x2F;A</td>
<td>✔️</td>
</tr>
<tr>
<td>Maps</td>
<td>N&#x2F;A</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Semantics-of-Presence"><a href="#Semantics-of-Presence" class="headerlink" title="Semantics of Presence"></a>Semantics of Presence</h2><h3 id="Merging"><a href="#Merging" class="headerlink" title="Merging"></a>Merging</h3><p>If field presence is not tracked, then an update patch alone cannot represent an update to the default value, because only non-default values are merged-from.</p>
<p>Updating to set a default value in this case requires some external mechanism, such as <code>FieldMask</code>.</p>
<h3 id="Compatibility"><a href="#Compatibility" class="headerlink" title="Compatibility"></a>Compatibility</h3><p>binary compatible, but logically, there may be problems.</p>
<p>i.e. round trip between optional fields and non-optional fields</p>
<h1 id="Styles"><a href="#Styles" class="headerlink" title="Styles"></a>Styles</h1><ul>
<li><p><strong>Don’t</strong> Go from Repeated to Scalar</p>
</li>
<li><p><strong>Do</strong> Include an Unspecified Value in an Enum</p>
</li>
<li><p><strong>Do</strong> Use Well-Known Types and Common Types</p>
<ul>
<li><p>Well-Known Types:</p>
<ul>
<li><p><a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/duration.proto">duration</a> is a signed, fixed-length span of time (for example, 42s).</p>
</li>
<li><p><a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/timestamp.proto">timestamp</a> is a point in time independent of any time zone or calendar (for example, 2017-01-15T01:30:15.01Z).</p>
</li>
<li><p><a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/field_mask.proto">field_mask</a> is a set of symbolic field paths (for example, f.b.d).</p>
</li>
</ul>
</li>
<li><p>Common Types:</p>
<ul>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/interval.proto">interval</a> is a time interval independent of time zone or calendar (for example, 2017-01-15T01:30:15.01Z - 2017-01-16T02:30:15.01Z).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/date.proto">date</a> is a whole calendar date (for example, 2005-09-19).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/dayofweek.proto">dayofweek</a> is a day of week (for example, Monday).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/timeofday.proto">timeofday</a> is a time of day (for example, 10:42:23).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/latlng.proto">latlng</a> is a latitude&#x2F;longitude pair (for example, 37.386051 latitude and -122.083855 longitude).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/money.proto">money</a> is an amount of money with its currency type (for example, 42 USD).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/postal_address.proto">postal_address</a> is a postal address (for example, 1600 Amphitheatre Parkway Mountain View, CA 94043 USA).</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/color.proto">color</a> is a color in the RGBA color space.</p>
</li>
<li><p><a href="https://github.com/googleapis/googleapis/blob/master/google/type/month.proto">month</a> is a month of year (for example, April).</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For extendible:</p>
<ul>
<li>Use different messages for storage and wire</li>
<li>Don’t Include Primitive Types in a Top-level Request or Response Proto</li>
<li>Never Use Booleans for Something That Has Two States Now, but Might Have More Later<ul>
<li>If you are using boolean for a field, make sure that the field is indeed describing just two possible states (for all time, not just now and the near future). </li>
<li>Often, the flexibility of an enum, int, or message turns out to be worth it.</li>
</ul>
</li>
<li>Rarely Use an Integer Field for an ID<ul>
<li>int64 is not as big as it used to be</li>
<li>can start with an internal message type</li>
</ul>
</li>
<li><em>Rarely</em> Define a Pagination API Without a Continuation Token</li>
</ul>
]]></content>
      <tags>
        <tag>Protobuf</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Compiler</title>
    <url>/2023/01/20/Go-Compiler/</url>
    <content><![CDATA[<h1 id="编译器和静态分析"><a href="#编译器和静态分析" class="headerlink" title="编译器和静态分析"></a>编译器和静态分析</h1><h2 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><p><img src="D:\Blog\source_images\image-20230120191244188.png" alt="img"></p>
<span id="more"></span>

<ul>
<li>分析部分 (front end)<ul>
<li>词法分析 –&gt; 词素(lexeme)</li>
<li>语法分析 –&gt; 抽象语法树(AST, Abstract Syntax Tree)</li>
<li>语义分析，收集类型信息，进行语义检查 –&gt; decorated AST</li>
<li>中间代码生成 –&gt; Intermediate Representation(IR) <ul>
<li>IR 是<strong>机器无关</strong>的</li>
</ul>
</li>
</ul>
</li>
<li>综合部分 (back end)<ul>
<li>代码优化(<strong>机器无关</strong>) –&gt; optimized IR</li>
<li>代码生成 –&gt; 目标代码</li>
</ul>
</li>
</ul>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>静态分析通常用于<strong>后端代码优化</strong></p>
<p>不执行程序代码，推导程序的行为，分析程序的性质，根据这些性质优化代码</p>
<ul>
<li>控制流分析 (Control Flow): 程序执行的流程</li>
<li>数据流分析 (Data Flow): 数据在控制流上的传递</li>
</ul>
<p>分析方式：</p>
<ul>
<li>过程内分析 (Intra-procedural analysis): 仅在函数内分析</li>
<li>过程间分析 (Inter-procedural analysis): 考虑函数调用时的参数传递和返回值的控制流和数据流<ul>
<li>过程间分析比较复杂，需要综合数据流和控制流</li>
</ul>
</li>
</ul>
<h1 id="Go-编译器优化"><a href="#Go-编译器优化" class="headerlink" title="Go 编译器优化"></a>Go 编译器优化</h1><p>Go 编译器为了追求编译的速度，编译器的优化较少</p>
<p>一些优化方向：</p>
<ul>
<li>函数内联</li>
<li>逃逸分析</li>
<li>默认栈大小调整</li>
<li>循环展开</li>
<li>边界检查消除</li>
</ul>
<h2 id="函数内联-Function-Inlining"><a href="#函数内联-Function-Inlining" class="headerlink" title="函数内联 (Function Inlining)"></a>函数内联 (Function Inlining)</h2><p>内联：将callee的副本替换到caller的位置，同时<strong>重写代码以反映参数的传递</strong></p>
<p>优点：</p>
<ul>
<li>消除调用开销，例如传参，保存寄存器等</li>
<li><strong>将过程间分析转化为过程内分析</strong>，帮助其他优化，例如<strong>逃逸分析</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>函数体变大，对 instruction cache (icache) 不友好</li>
<li>编译生成的 go 镜像变大</li>
</ul>
<p>函数内联大多数情况下是正优化</p>
<p>内联策略：调用和被调用函数的规模</p>
<h2 id="内联优化"><a href="#内联优化" class="headerlink" title="内联优化"></a>内联优化</h2><p>Go函数内联受到的限制多：interface，defer等语言特性限制了内联，内联策略非常保守</p>
<p>优化：调整函数内联的策略</p>
<h2 id="逃逸分析-Escape-Analysis"><a href="#逃逸分析-Escape-Analysis" class="headerlink" title="逃逸分析 (Escape Analysis)"></a>逃逸分析 (Escape Analysis)</h2><p>分析代码中指针的动态作用域：指针在何处能被访问</p>
<p>大致思路：</p>
<ul>
<li>从对象被分配处出发，沿着控制流观察对象的数据流：</li>
<li>若发现指针 p 在当前作用域 s 的时候：<ul>
<li>作为参数传递给别的函数</li>
<li>传递给全局变量</li>
<li>传递给其他goroutine</li>
<li>传递给已逃逸的指针指向的对象</li>
</ul>
</li>
<li>则指针 p 逃逸出了 s，反之没有逃逸出 s</li>
</ul>
<h2 id="逃逸优化"><a href="#逃逸优化" class="headerlink" title="逃逸优化"></a>逃逸优化</h2><p><strong>函数内联拓展了函数的边界，更多对象不逃逸</strong></p>
<p>未逃逸的对象可以栈上分配</p>
<ul>
<li>栈的分配和回收速度很快：移动sp</li>
<li>减少在heap上的分配，减轻GC的负担</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Memory</title>
    <url>/2023/01/20/Go-Memory/</url>
    <content><![CDATA[<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">业务代码 --&gt; SDK --&gt; 基础库 --&gt; 语言runtime --&gt; OS</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h2><p>业务优化，runtime优化，SDK优化</p>
<p>数据驱动</p>
<ul>
<li>自动化性能分析工具 – pprof</li>
<li>依靠数据而非猜测</li>
<li>首先优化最大瓶颈</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230120155529260.png" alt="image-20230120155529260"></p>
<p>性能优化和软件质量：</p>
<ul>
<li>保证<strong>接口稳定</strong>前提的情况下改进具体实现</li>
<li><strong>测试驱动开发</strong>：Test Driven Development</li>
<li><strong>文档</strong>：描述优化，做了什么，达到什么效果</li>
<li><strong>隔离性</strong>：通过选项控制是否开启优化</li>
<li><strong>可观测</strong>：必要的日志输出</li>
</ul>
<h1 id="Auto-Memory-Management"><a href="#Auto-Memory-Management" class="headerlink" title="Auto Memory Management"></a>Auto Memory Management</h1><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p><strong>自动内存管理</strong>管理的是<strong>动态内存</strong>(运行时根据需求动态分配的内存)： <code>malloc()</code></p>
<p>自动内存管理: 由程序语言的 runtime 系统管理动态内存</p>
<ul>
<li>保证内存使用的<em>正确性</em>和<em>安全性</em>: double-free problem, use-after-free problem</li>
<li>避免手动内存管理</li>
</ul>
<p>自动内存管理的三个任务：</p>
<ul>
<li>为对象分配新空间</li>
<li>找到存活的对象</li>
<li>回收死亡对象的内存空间</li>
</ul>
<p>线程类型</p>
<ul>
<li><p>Mutator thread: 业务线程，分配新对象，修改对象指向关系</p>
</li>
<li><p>Collector thread: GC线程，找到存活对象，回收死亡对象的内存空间</p>
</li>
</ul>
<p>GC分类：</p>
<ul>
<li>Serial GC: 只有一个Collector线程</li>
<li>Parallel GC: 支持多个Collector同时回收的GC算法</li>
<li>Concurrent GC: Mutators threads 和 Collector threads 可以同时执行<ul>
<li><strong>Collectors必须感知对象指向关系的改变</strong>，例如在GC过程中，Mutator线程修改了对象的指向关系</li>
</ul>
</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230120160944188.png" alt="image-20230120160944188"></p>
<p>GC算法的评价：</p>
<ul>
<li>安全性(safety)：不能回收存活的对象</li>
<li>吞吐率(throughput)：$1-\frac{time_{GC}}{time_{total}}$</li>
<li>暂停时间(pause time): stop the world(STW) 业务是否感知的到</li>
<li>内存开销(space overhead): GC metadata overhead</li>
</ul>
<h2 id="Tracing-Garbage-Collection"><a href="#Tracing-Garbage-Collection" class="headerlink" title="Tracing Garbage Collection"></a>Tracing Garbage Collection</h2><h3 id="Collection-Strategy"><a href="#Collection-Strategy" class="headerlink" title="Collection Strategy"></a>Collection Strategy</h3><p>对象回收的条件：指针指向不可达的对象可以被回收</p>
<p>回收过程：</p>
<ol>
<li><p>标记根对象</p>
<ul>
<li>根对象包括：静态变量、全局变量、常量、线程栈</li>
</ul>
</li>
<li><p>标记可达对象</p>
<ul>
<li>求指针指向关系的传递闭包，找到所有的可达对象</li>
</ul>
</li>
<li><p>清理不可达对象</p>
<ul>
<li><p>将存活对象复制到另外的内存空间 (<strong>Copying GC</strong>)</p>
<p><img src="D:\Blog\source_images\image-20230120162342068.png" alt="image-20230120162342068"></p>
</li>
<li><p>将死亡对象标记为可分配，用 free-list 管理 (<strong>Mark-Sweep GC</strong>)</p>
<p><img src="C:\Users\Anyu\AppData\Roaming\Typora\typora-user-images\image-20230120162436503.png" alt="image-20230120162436503"></p>
</li>
<li><p>移动并整理存活对象，根据一定的策略做压缩 (Mark-Compact GC)</p>
<p><img src="D:\Blog\source_images\image-20230120162602987.png" alt="image-20230120162602987"></p>
</li>
</ul>
</li>
<li><p>根据对象不同的生命周期，采取不同的回收策略</p>
</li>
</ol>
<h3 id="Generational-GC"><a href="#Generational-GC" class="headerlink" title="Generational GC"></a>Generational GC</h3><p>分代假说 (Generational Hypothesis): 很多对象很快就死亡了</p>
<ul>
<li>Intuition: 很多对象分配之后就很快不适用了</li>
</ul>
<p>每个对象都有年龄，年龄即为经历过GC的次数</p>
<ul>
<li>区别年轻代和老年的对象，使用不同的策略</li>
<li>年轻代 (Young Generation)<ul>
<li>常规的对象分配，存活对象很少</li>
<li>采用<strong>copying GC</strong></li>
<li>GC吞吐率高</li>
</ul>
</li>
<li>老年代 (Old Generation)<ul>
<li>对象趋向于一直活着，反复复制的开销很大</li>
<li>可以采用<strong>mark-sweep GC</strong></li>
</ul>
</li>
</ul>
<h2 id="Referencing-Counting"><a href="#Referencing-Counting" class="headerlink" title="Referencing Counting"></a>Referencing Counting</h2><p>基本思路：</p>
<ul>
<li>每个对象都有一个与之关联的引用计数</li>
<li>对象的存活条件：当且仅当引用计数大于0</li>
</ul>
<p>优点：</p>
<ul>
<li>内存管理操作被平摊到了程序执行过程中</li>
<li>内存管理不需要了解runtime的实现细节，例如 C++ 中的 smart pointer，Rust 中的 ownership 和 lifetime</li>
</ul>
<p>缺点：</p>
<ul>
<li>维护开销大，需要通过<strong>原子操作</strong>保证引用计数操作的唯一性和可见性</li>
<li>无法回收<strong>环形的不可达数据结构</strong> –&gt; 可通过 weak reference 解决</li>
<li>内存开销大，每个对象都需要额外的空间记录引用计数</li>
<li>回收内存时依然<strong>可能引入暂停</strong> –&gt; 例如回收一个很大的链表</li>
</ul>
<h1 id="Go-内存管理"><a href="#Go-内存管理" class="headerlink" title="Go 内存管理"></a>Go 内存管理</h1><h2 id="Go-内存分配"><a href="#Go-内存分配" class="headerlink" title="Go 内存分配"></a>Go 内存分配</h2><p>目标：为对象在 heap 上分配内存</p>
<h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><ul>
<li>提前为内存<strong>分块</strong>:<ol>
<li>调用 <code>mmap()</code> 向OS申请一大块内存，例如4MB</li>
<li>将内存分为大块，如 8KB，称为<em>mspan</em></li>
<li>再将mspan分为特定大小的小块，用于对象分配</li>
<li><strong>nonscan mspan</strong>: 不包含指针的对象 – <strong>GC不需要扫描</strong></li>
<li><strong>scan mspan</strong>: 包含指针的对象 – <strong>GC需要扫描</strong></li>
</ol>
</li>
<li>对象分配：根据块大小，分配最适合的块</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>TCMalloc: thread caching</li>
<li>每个p包含一个 mcache 用于快速分配，用于绑定于 p 上的 g 分配对象</li>
<li>mcache 管理一组 mspan</li>
<li>mcache 已满时，mcache 向 mcentral 申请带有未分配块的 mspan</li>
<li>当 mspan 没有对象的时候，mspan 会先被缓存在 mcentral 中，而不是立刻释放给 OS</li>
</ul>
<p><img src="D:\Blog\source_images\image-20230120165816117.png" alt="image-20230120165816117"></p>
<h2 id="内存分配的优化"><a href="#内存分配的优化" class="headerlink" title="内存分配的优化"></a>内存分配的优化</h2><h3 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h3><ol>
<li>对象分配是<strong>高频</strong>的操作: 每秒GB级别的对象分配</li>
<li><strong>小对象</strong>占比例比较高 –&gt; 对小对象可以进行特定的优化</li>
<li>Go内存分配比较耗时<ul>
<li>分配路径较长: <code>g -&gt; m -&gt; p -&gt; mcache -&gt; mspan -&gt; memory block -&gt; return pointer</code></li>
<li>pprof: 对象分配的函数是最频繁调用的函数之一</li>
</ul>
</li>
</ol>
<h3 id="小对象内存分配优化方案-–-Balanced-GC"><a href="#小对象内存分配优化方案-–-Balanced-GC" class="headerlink" title="小对象内存分配优化方案 – Balanced GC"></a>小对象内存分配优化方案 – Balanced GC</h3><ul>
<li>将 noscan 对象在 per-g allocation buffer (GAB) 上分配，并使用移动对象 GC 管理这部分内存，提高对象分配和回收效率<ul>
<li>每个 g 会附加一个较大的 allocation buffer (例如1KB) 用来分配小于128B的 nonscan 小对象</li>
</ul>
</li>
<li><strong>bump pointer 风格</strong>的对象分配。<ul>
<li>分配对象时，根据对象大小移动 <code>top</code> 指针并返回，快速完成一次对象分配</li>
<li>同原先调用 <code>mallocgc()</code> 进行对象分配的方式相比，balanced GC <strong>缩短了对象分配的路径</strong>，降低 CPU 使用</li>
</ul>
</li>
<li>从 Go runtime 内存管理模块的角度看，一个 allocation buffer 其实是一个大对象。本质上 balanced GC 是<strong>将多次小对象的分配合并成一次大对象的分配</strong>。<ul>
<li>存在问题：当 GAB 中哪怕只有一个小对象存活时，Go runtime 也会认为整个大对象（即 GAB）存活。</li>
<li>解决方案：balanced GC 会根据 GC 策略，<strong>将 GAB 中存活的对象移动到另外的 GAB 中</strong>，从而压缩并清理 GAB 的内存空间，原先的 GAB 空间由于不再有存活对象，可以全部释放，如下图所示。<img src="D:\Blog\source_images\image-20230120171942068.png" alt="img"></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-Style</title>
    <url>/2023/01/19/Go-Style/</url>
    <content><![CDATA[<h1 id="高质量编码"><a href="#高质量编码" class="headerlink" title="高质量编码"></a>高质量编码</h1><p>什么是高质量？</p>
<ul>
<li>考虑到edge case</li>
<li>异常状况处理，稳定性</li>
<li>易读易维护，易于重构</li>
</ul>
<span id="more"></span>

<p>编程原则？</p>
<ul>
<li>简单性 - 消除多余的复杂性，否则代码难以维护</li>
<li>可读性 - 保证代码的可维护性</li>
<li>生产力 - 团队的整体工作效率</li>
</ul>
<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><ul>
<li><p>gofmt</p>
</li>
<li><p>goimports</p>
</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>公共符号必须要使用注释</strong></p>
<ul>
<li>代码作用</li>
<li>代码如何做的</li>
<li>代码实现的原因</li>
<li>什么情况会出错</li>
</ul>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h3><ul>
<li>简洁胜于冗长</li>
<li>缩略词全大写，但位于变量开头的时候全小写<ul>
<li>例如ServeHTTP instead of ServeHttp</li>
<li>xmlHTTPRequest 或 XMLHTTPRequest</li>
</ul>
</li>
<li>变量距离使用的距离越远，则需要携带越多的上下文信息<ul>
<li>全局变量要在名字中体现出更多的上下文信息，使得可以辨别其含义</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; n; index++ &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> send(req *Request, t time.Time)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good, deadline has more semantics</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> send(req *Request, deadline time.Time)</span><br></pre></td></tr></table></figure>

<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul>
<li>函数名不需要携带包信息，因为包名和函数名总是成对出现的</li>
<li>函数名应该尽量简短</li>
<li>当包名和函数的返回类型一样时，可以省略类型信息</li>
<li>当包名和函数的返回类型不一样时，可以在函数名中加入类型信息</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(l net.Listener, handler Handler)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad, http.ServeHTTP when invoking, which is verbose</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(l net.Listener, handler Handler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h3><ul>
<li>小写字母组成，不包含大写字母和下划线</li>
<li>简短并包含上下文信息</li>
<li>不与标准库同名</li>
</ul>
<h3 id="其他规则"><a href="#其他规则" class="headerlink" title="其他规则"></a>其他规则</h3><ul>
<li>不使用常用变量作为包名，例如bufio而不是buf</li>
<li>使用单数而不使用复数，例如encoding而不是encodings</li>
<li>谨慎使用缩写</li>
</ul>
<h3 id="顶层变量声明"><a href="#顶层变量声明" class="headerlink" title="顶层变量声明"></a>顶层变量声明</h3><p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;error&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> myError &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _e <span class="type">error</span> = F()</span><br><span class="line"><span class="comment">// F 返回一个 myError 类型的实例，但是我们要 error 类型</span></span><br></pre></td></tr></table></figure>

<p><strong>对于未导出的顶层常量和变量，使用_作为前缀</strong></p>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><p>避免嵌套，保证正常流程清晰</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">if</span> foo &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good, 分支中包含多个return语句，可以去除冗余的分支</span></span><br><span class="line"><span class="keyword">if</span> foo &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>尽量保持正常代码路径为最小缩进</p>
<ul>
<li>优先处理错误和特殊情况，尽早返回或继续循环以减少嵌套</li>
<li>线性原理，逻辑尽量走直线，避免复杂的嵌套分支</li>
<li>正常流程代码沿屏幕往下流动</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OneFunc</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    err := DoSomething()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        err = DoAnotherThing()</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>	<span class="comment">// normal case</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OneFunc</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := DoSomething(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := DoAnotherThing(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误与异常处理"><a href="#错误与异常处理" class="headerlink" title="错误与异常处理"></a>错误与异常处理</h2><p>简单错误：</p>
<ul>
<li>指仅出现一次的错误，且<strong>其他地方不需要捕获该错误</strong></li>
<li>优先使用 <code>errors.New</code> 创建匿名变量来表示简单错误</li>
<li>如果有格式化需求可以使用 <code>fmt.Errorf</code></li>
</ul>
<p>错误的Wrap和Unwrap</p>
<ul>
<li>在 <code>fmt.Errorf</code> 中使用 <code>%w</code> 关键字来将一个错误 wrap 至其错误链中</li>
<li>错误的 wrap 实际上提供了一个 error 嵌套另一个 error 的功能，从而生成 error 的跟踪链条，以方便判断错误</li>
</ul>
<p>错误判定</p>
<ul>
<li>判断一个错误链是否包含一个特定的错误，使用 <code>errors.Is</code> 的方法</li>
<li>获取特定种类的错误，使用 <code>errors.As</code> 方法</li>
</ul>
<p>Panic：</p>
<ul>
<li>不建议在业务代码中使用 panic</li>
<li>建议使用 error 代替 panic</li>
<li>程序启动阶段发生不可逆转的作用的时候，可以在 init 或 main 中使用 panic， 尽早暴露错误</li>
</ul>
<p>Recovery：</p>
<ul>
<li>通常在recovery中打印出panic时的调用堆栈 <code>debug.Stack()</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treeFS)</span></span> Open(name <span class="type">string</span>) (f fs.File, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            f = <span class="literal">nil</span></span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;git fs panics: %v\n%s&quot;</span>, e, debug.Stack())</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>error 应提供上下文信息链，方便定位</li>
<li>panic用于定位真正异常的情况</li>
</ul>
<h2 id="Interface合理化验证"><a href="#Interface合理化验证" class="headerlink" title="Interface合理化验证"></a>Interface合理化验证</h2><p>将实现特定结构的导出类型进行检查。如果 <code>http.Handler</code> 和 <code>Handler</code> 类型不匹配，则 <code>var _ http.Handler = (*Handler)(nil)</code> 编译时就会出错。方便提早暴露问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">var</span> _ http.Handler = (*Handler)(<span class="literal">nil</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="零值-Mutex-是有效的"><a href="#零值-Mutex-是有效的" class="headerlink" title="零值 Mutex 是有效的"></a>零值 Mutex 是有效的</h2><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p>
<p><strong>不要把mutex嵌入到(导出或非导出)结构体中</strong>!</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">mu := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure>

<h2 id="Channel的size为1或0"><a href="#Channel的size为1或0" class="headerlink" title="Channel的size为1或0"></a>Channel的size为1或0</h2><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，<strong>考虑是什么阻止了 channel 在高负载下和阻塞写时的写入</strong>，以及当这种情况发生时系统逻辑有哪些变化</p>
<h2 id="枚举从1开始"><a href="#枚举从1开始" class="headerlink" title="枚举从1开始"></a>枚举从1开始</h2><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。<strong>由于变量的默认值为 0</strong>，因此通常应以非零值开头枚举。</p>
<p><strong>在某些情况下，使用零值是有意义的</strong>(枚举从零开始)，例如，<strong>当零值是理想的默认行为时</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">type</span> Opeartion <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Add Opeartion = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">	Subtract</span><br><span class="line">    Multiply</span><br><span class="line">    Divide</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good, default to stdout</span></span><br><span class="line"><span class="keyword">type</span> LogOutput <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	LogToStdout LogOutput = <span class="literal">iota</span></span><br><span class="line">    LogToFile</span><br><span class="line">    LogToRemote</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="使用-time-处理时间"><a href="#使用-time-处理时间" class="headerlink" title="使用 time 处理时间"></a>使用 time 处理时间</h2><h3 id="time-Time-瞬时时间"><a href="#time-Time-瞬时时间" class="headerlink" title="time.Time 瞬时时间"></a>time.Time 瞬时时间</h3><p>在<strong>比较、增加和减少</strong>时间的时候使用 <code>time.Time</code> 中的方法</p>
<ul>
<li>比较 Time.Before, Time.After, Time.Equal</li>
<li>增加 Time.Add, Time.AddDate</li>
<li>减少 Time.Sub</li>
</ul>
<h3 id="外部系统中的-time-Time-和-time-Duration"><a href="#外部系统中的-time-Time-和-time-Duration" class="headerlink" title="外部系统中的 time.Time 和 time.Duration"></a>外部系统中的 time.Time 和 time.Duration</h3><ul>
<li>Command-line 标志: <a href="https://golang.org/pkg/flag/"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></li>
<li>JSON: <a href="https://golang.org/pkg/encoding/json/"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON"><code>UnmarshalJSON</code></a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串</li>
<li>SQL: <a href="https://golang.org/pkg/database/sql/"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</li>
<li>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</li>
</ul>
<p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p>
<p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad, 单位未指定</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Interval <span class="type">int</span> <span class="string">`json:&quot;interval&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    IntervalMillis <span class="type">int</span> <span class="string">`json:&quot;intervalMillis&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="避免可变全局变量"><a href="#避免可变全局变量" class="headerlink" title="避免可变全局变量"></a>避免可变全局变量</h2><p>使用选择<strong>依赖注入方式避免改变全局变量</strong>。 既适用于函数指针又适用于其他值类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">var</span> _timeNow = time.Now</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  now := _timeNow()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good </span></span><br><span class="line"><span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;</span><br><span class="line">  now <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSigner</span><span class="params">()</span></span> *signer &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;signer&#123;</span><br><span class="line">    now: time.Now,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span></span> Sign(msg <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  now := s.now()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="避免在公共结构中嵌入类型"><a href="#避免在公共结构中嵌入类型" class="headerlink" title="避免在公共结构中嵌入类型"></a>避免在公共结构中嵌入类型</h2><p>这些嵌入的类型<strong>泄漏实现细节</strong>、<strong>不利于类型演化</strong>和<strong>导致文档模糊</strong>。</p>
<h3 id="类型演化"><a href="#类型演化" class="headerlink" title="类型演化"></a>类型演化</h3><p>结构获得与类型同名的字段。 所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p>
<ul>
<li>向嵌入接口添加方法是一个破坏性的改变。</li>
<li>从嵌入结构体删除方法是一个破坏性改变。</li>
<li>删除嵌入类型是一个破坏性的改变。</li>
<li>即使使用满足相同接口的类型替换嵌入类型，也是一个破坏性的改变。</li>
</ul>
<h2 id="避免使用-init"><a href="#避免使用-init" class="headerlink" title="避免使用 init()"></a>避免使用 <code>init()</code></h2><p>导入包尽可能要做到 <em>deterministic</em>，<strong>不能因为在不同地方导入包就造成不同的初始化行为</strong>。因此应该尽可能避免使用 <code>init()</code> 函数。如果必须要使用 <code>init()</code> 函数，则需要做到以下几点</p>
<ol>
<li>无论程序环境或调用如何，都要完全确定。</li>
<li>避免依赖于其他<code>init()</code>函数的顺序或副作用。虽然<code>init()</code>顺序是明确的，但代码可以更改， 因此<code>init()</code>函数之间的关系可能会使代码变得脆弱和容易出错。</li>
<li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数&#x2F;输入等。</li>
<li>避免<code>I/O</code>，包括文件系统、网络和系统调用。</li>
</ol>
<p>不能满足这些要求的代码可能属于要作为<code>main()</code>调用的一部分（或程序生命周期中的其他地方）， 或者作为<code>main()</code>本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性， 而不是执行“init magic”</p>
<p>考虑到上述情况，在某些情况下，<code>init()</code>可能更可取或是必要的，可能包括：</p>
<ul>
<li><strong>不能表示为单个赋值的复杂表达式</strong>。</li>
<li>可插入的钩子，如<code>database/sql</code>、编码类型注册表等。</li>
<li>对 <a href="https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations">Google Cloud Functions</a> 和其他形式的确定性预计算的优化。</li>
</ul>
<h2 id="主函数退出方式"><a href="#主函数退出方式" class="headerlink" title="主函数退出方式"></a>主函数退出方式</h2><p>使用 <strong>os.Exit</strong> 或 <strong>log.Fatal</strong> 退出，<strong>单一出口退出</strong>，例如将逻辑封装在 <code>run</code> 函数中，<code>run</code> 函数返回一个 error。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    args := Args[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;missing files&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    name := args[<span class="number">0</span>]</span><br><span class="line">    f, err := os.Open(name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;open file %s failed: %w&quot;</span>, name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    b, err := os.ReadAll(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read file %s failed: %w&quot;</span>, name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在序列化结构中使用字段标记"><a href="#在序列化结构中使用字段标记" class="headerlink" title="在序列化结构中使用字段标记"></a>在序列化结构中使用字段标记</h2><p>任何序列化到JSON、YAML，或其他支持基于标记的字段命名的格式应使用相关标记进行注释</p>
<p>这样后续就可以对字段名进行修改而不影响序列化和反序列化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">type</span> Stock <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="type">int</span></span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">type</span> Stock <span class="keyword">struct</span> &#123;</span><br><span class="line">    Price <span class="type">int</span> <span class="string">`json：“price”`</span></span><br><span class="line">    Name <span class="type">int</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Goroutine-泄露"><a href="#Goroutine-泄露" class="headerlink" title="Goroutine 泄露"></a>Goroutine 泄露</h2><p>不要在代码中泄漏 goroutine。 使用 <a href="https://pkg.go.dev/go.uber.org/goleak">go.uber.org&#x2F;goleak</a> 来测试可能产生 goroutine 的包内的 goroutine 泄漏。</p>
<p>一般来说，每个 goroutine:</p>
<ul>
<li>必须有一个可预测的停止运行时间；或者</li>
<li>必须有一种方法可以向 goroutine 发出信号它应该停止</li>
</ul>
<p><strong>不要在init函数中使用goroutine</strong></p>
<h2 id="nil是有效的Slice"><a href="#nil是有效的Slice" class="headerlink" title="nil是有效的Slice"></a>nil是有效的Slice</h2><p><code>nil</code> 是一个有效的长度为 0 的 slice。虽然 nil 切片是有效的切片，但它不等于长度为 0 的切片（一个为 nil，另一个不是），<strong>并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</strong></p>
<ul>
<li>不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</li>
<li>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</li>
<li>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</li>
</ul>
<h2 id="初始化规则"><a href="#初始化规则" class="headerlink" title="初始化规则"></a>初始化规则</h2><ul>
<li>字段名初始化结构体，除非结构体中的字段有3个或更少，或者有顺序意义</li>
<li>省略结构体中的零值字段，除了在表驱动测试中的测试用例</li>
<li>对零值结构使用 <code>var</code> 初始化</li>
<li>初始化零值结构体的引用使用 <code>&amp;User&#123;&#125;</code> 而不用 <code>new(User)</code></li>
<li>初始化Map<ul>
<li>在尽可能的情况下，请在初始化时提供 map 容量大小</li>
<li>如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</li>
<li>基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)。</li>
</ul>
</li>
</ul>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice预分配内存</p>
<ul>
<li>尽可能使用 <code>make()</code> 初始化切片时提供容量信息</li>
</ul>
<p>Slice大内存未释放</p>
<ul>
<li>在已有的切片上创建切片，不会创建新的底层数组，且原来的切片存在引用，不会被释放</li>
<li>可以使用 copy 代替 re-slice</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLastBySlice</span><span class="params">(origin []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> origin[<span class="built_in">len</span>(origin)<span class="number">-2</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLastBySlice</span><span class="params">(origin []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, origin[<span class="built_in">len</span>(origin)<span class="number">-2</span>:])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map预分配内存</p>
<ul>
<li>不断向 map 添加元素会触发map扩容</li>
<li>提前分配空间可以避免 re-hash 和扩容</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串处理：</p>
<ul>
<li>strings.Builder &gt; bytes.Buffer &gt; +</li>
<li>strings.Builder 和 bytes.Buffer 均使用了 []byte 类型作为底层存储结构</li>
<li>strings.Builder 直接将底层的 []byte 结构转化为了字符串类型返回，而 bytes.Buffer 在转换字符串的时候重新申请了一片空间因此 strings.Builder 比 bytes.Buffer 略快</li>
<li><strong>已知字符串长度的时候，可以通过 <code>Grow</code> 预分配空间更进一步提升性能</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preStrBuilder</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buidler strings.Builder</span><br><span class="line">    builder.Grow(n * <span class="built_in">len</span>(str))	<span class="comment">// similar to bytes.Buffer.Grow</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">        builder.WriteString(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Empty-Struct"><a href="#Empty-Struct" class="headerlink" title="Empty Struct"></a>Empty Struct</h2><p>使用空结构体节省内存</p>
<ul>
<li><code>struct&#123;&#125;&#123;&#125;</code> 不占内存空间</li>
<li>可以作为占位符使用，并且具有一定的语义</li>
</ul>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>使用 atomic 包</p>
<ul>
<li>锁通过系统调用实现，成本较高</li>
<li>atomic操作由硬件实现，性能较好</li>
<li>非数值操作可以使用 <code>atomic.Value</code>, 能承载一个 <code>interface&#123;&#125;</code></li>
</ul>
<h2 id="Type-Conversion"><a href="#Type-Conversion" class="headerlink" title="Type Conversion"></a>Type Conversion</h2><p>优先使用 <code>strconv</code> 而不是 <code>fmt</code> </p>
<p>避免字符串到字节切片的转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Good</span></span><br><span class="line">data := []<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">    w.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h1><h2 id="功能选项"><a href="#功能选项" class="headerlink" title="功能选项"></a>功能选项</h2><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p>
<p>将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">    apply(o *options) <span class="comment">//! unexported</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">    cache <span class="type">bool</span></span><br><span class="line">    logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cacheOption <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="type">bool</span>)</span></span> cacheOption &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheOption(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheOption)</span></span> apply(o *options) &#123;</span><br><span class="line">    o.cache = <span class="type">bool</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggerOption <span class="keyword">struct</span> &#123;</span><br><span class="line">    Log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span></span> loggerOption &#123;</span><br><span class="line">    <span class="keyword">return</span> loggerOption&#123;Log: log&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l logOption)</span></span> apply(o *options) &#123;</span><br><span class="line">    o.logger = l.Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(addr <span class="type">string</span>, opt ...Option)</span></span> &#123;</span><br><span class="line">    options := options&#123;</span><br><span class="line">        cache: defaultCache,</span><br><span class="line">        logger: zap.NewNop(),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opt &#123;</span><br><span class="line">        o.apply(&amp;options)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Self-referential-functions"><a href="#Self-referential-functions" class="headerlink" title="Self-referential functions"></a>Self-referential functions</h3><p>通过Option函数进行一系列的配置option，其中配置option由类似Verbosity等函数得到(返回闭包)，Option配置的返回值为配置之前的option，因此通过重新采用返回值的option，即可恢复到之前的配置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> option <span class="function"><span class="keyword">func</span><span class="params">(f *Foo)</span></span> option</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verbosity sets Foo&#x27;s verbosity level to v.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Verbosity</span><span class="params">(v <span class="type">int</span>)</span></span> option &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(f *Foo)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        previous := f.verbosity</span><br><span class="line">        f.verbosity = v</span><br><span class="line">        <span class="keyword">return</span> Verbosity(previous)	<span class="comment">//! recall the function in closure</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span></span> Option(opts ...option) option &#123;</span><br><span class="line">    <span class="keyword">var</span> prev option</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        prev = opt(f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomethingVerbosely</span><span class="params">(foo *Foo, verbosity <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    prev := foo.Option(Verbosity(verbosity))</span><br><span class="line">    <span class="keyword">defer</span> foo.Option(prev) <span class="comment">// cancel the option after this function</span></span><br><span class="line">    <span class="comment">// Do Something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Style</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-Profile</title>
    <url>/2023/01/19/Go-Profile/</url>
    <content><![CDATA[<h1 id="性能调优准则"><a href="#性能调优准则" class="headerlink" title="性能调优准则"></a>性能调优准则</h1><ul>
<li>要依靠<strong>数据</strong>而不是猜测</li>
<li>要定位到<strong>最大瓶颈</strong>，而不是细枝末节</li>
<li>不要过早优化</li>
<li>不要过度优化</li>
</ul>
<span id="more"></span>

<h1 id="性能分析工具pprof"><a href="#性能分析工具pprof" class="headerlink" title="性能分析工具pprof"></a>性能分析工具pprof</h1><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p><img src="D:\Blog\source_images\image-20230119214436210.png" alt="image-20230119214436210"></p>
<h2 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h2><p>使用命令 <code>go tool pprof &quot;localhost:6060/debug/pprof/profile?seconds=10&quot;</code> 采集10s的数据，并进入可交互的终端</p>
<ul>
<li><code>top[N]</code>: 查看占用资源最多的函数<ul>
<li>flat: 当前函数<strong>本身</strong>的执行耗时 </li>
<li>flat%: 执行耗时占的百分比</li>
<li>sum%: 该函数及其之上的函数占的总百分比</li>
<li>cum: 当前函数<strong>及其调用函数</strong>的总执行耗时</li>
<li>cum%: 总执行耗时的百分比</li>
<li>flat &#x3D;&#x3D; cum –&gt; 函数中没有调用其他函数</li>
<li>flat &#x3D;&#x3D; 0 –&gt; 函数中只有其他函数的调用</li>
</ul>
</li>
<li><code>list [regexp]</code>: 根据正则表达式查找代码行</li>
<li><code>web</code>: 调用关系可视化</li>
</ul>
<h2 id="堆分析"><a href="#堆分析" class="headerlink" title="堆分析"></a>堆分析</h2><p>使用 <code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/heap&quot;</code> 命令，在localhost:8080地址展示各种视图和工具进行分析</p>
<h2 id="其他分析"><a href="#其他分析" class="headerlink" title="其他分析"></a>其他分析</h2><p>协程分析：<code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/goroutine&quot;</code></p>
<p>锁分析：<code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/mutex&quot;</code></p>
<p>阻塞分析：<code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/block&quot;</code></p>
<h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p>通过 <code>go test</code> 命令可以指定生成测试程序的 profile，这些profile可以用来分析 cpu, block, mem 等性能</p>
<p>例如</p>
<ul>
<li>CPU分析<ul>
<li><code>go test -cpuprofile=cpu.log module/package</code> </li>
<li><code>go tool pprof -http=:8080 cpu.log</code></li>
</ul>
</li>
<li>block分析<ul>
<li><code>go test -blockprofile=block.log module/package</code></li>
<li><code>go tool pprof -http=:8080 block.log</code></li>
</ul>
</li>
<li>mem分析<ul>
<li><code>go test -memprofile=block.log module/package</code></li>
<li><code>go tool pprof -http=:8080 mem.log</code></li>
</ul>
</li>
</ul>
<h1 id="pprof原理和采样过程"><a href="#pprof原理和采样过程" class="headerlink" title="pprof原理和采样过程"></a>pprof原理和采样过程</h1><h2 id="CPU采样"><a href="#CPU采样" class="headerlink" title="CPU采样"></a>CPU采样</h2><ul>
<li>操作系统定时器：启动一个操作系统的定时器，每10ms发送一个SIGPROF信息给进程</li>
<li>进程堆栈：进程<strong>每次收到SIGPROF信号都记录调用堆栈</strong></li>
<li>写缓冲：每100ms读取记录的调用堆栈并写入到输出流</li>
</ul>
<h2 id="Heap采样"><a href="#Heap采样" class="headerlink" title="Heap采样"></a>Heap采样</h2><ul>
<li>采样程序通过<strong>内存分配器</strong>在堆上分配和释放的内存，<strong>记录分配&#x2F;释放的大小和数量</strong></li>
<li>采样率：<strong>每512KB采样一次</strong>，可在运行开头修改，1表示每次分配均记录</li>
<li>采样时间：程序开始运行时到采样时</li>
<li>采样指标：alloc_space, alloc_objects, inuse_space, inuse_objects</li>
<li>inuse&#x3D;alloc-free</li>
</ul>
<h2 id="Goroutine-amp-ThreadCreate-采样"><a href="#Goroutine-amp-ThreadCreate-采样" class="headerlink" title="Goroutine &amp; ThreadCreate 采样"></a>Goroutine &amp; ThreadCreate 采样</h2><ul>
<li>Goroutine<ul>
<li>记录所有用户发起的且在运行中的goroutine(<strong>即入口非runtime开头的goroutine</strong>)runtime.main的调用栈信息</li>
</ul>
</li>
<li>ThreadCreate<ul>
<li>记录程序创建的所有系统线程的信息</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">direction LR</span><br><span class="line">id1(stop the world) --&gt; id2(遍历allg切片) --&gt; id3(输出创建g的堆栈) --&gt; id4(start the world)</span><br></pre></td></tr></table></figure>

<h2 id="Block-amp-Mutex-采样"><a href="#Block-amp-Mutex-采样" class="headerlink" title="Block &amp; Mutex 采样"></a>Block &amp; Mutex 采样</h2><ul>
<li>Block采样<ul>
<li>采样阻塞操作的次数和耗时</li>
<li>采样率：阻塞耗时超过阈值才会被记录，也可以设置采样率，1表示每次都记录</li>
</ul>
</li>
<li>锁竞争<ul>
<li>采样争抢锁的次数和耗时</li>
<li>采样率：只记录固定比例的锁操作，也可以设置采样率，1表示每次都记录</li>
</ul>
</li>
</ul>
<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="业务服务优化"><a href="#业务服务优化" class="headerlink" title="业务服务优化"></a>业务服务优化</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>服务：能<strong>单独部署</strong>，承载<strong>一定功能</strong>的程序</p>
<p>依赖：Service A的功能实现依赖Service B的响应结果，则Service A依赖Service B</p>
<p>调用链路：支持一个接口的相关服务集合及其相互之间的依赖关系</p>
<p>基础库：公共的工具包，中间件</p>
<h3 id="单体Service优化流程"><a href="#单体Service优化流程" class="headerlink" title="单体Service优化流程"></a>单体Service优化流程</h3><ol>
<li>建立服务性能的<strong>评估手段</strong><ul>
<li>Benchmark</li>
<li>Others</li>
</ul>
</li>
<li>分析性能数据，定义<strong>性能瓶颈</strong></li>
<li>优化代码，消除瓶颈</li>
<li>验证优化效果</li>
</ol>
<h4 id="评估手段"><a href="#评估手段" class="headerlink" title="评估手段"></a>评估手段</h4><ul>
<li>不同负载性能表现有差异</li>
<li>不同请求参数覆盖的逻辑不同，请求流量不同</li>
<li>压测范围<ul>
<li>单机压测</li>
<li>集群压测</li>
</ul>
</li>
<li>性能数据采集<ul>
<li>单机性能数据</li>
<li>集群性能数据</li>
</ul>
</li>
</ul>
<h4 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h4><ul>
<li>使用库不规范</li>
<li>高并发场景优化不足，例如异步log</li>
</ul>
<h4 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h4><ul>
<li>正确性<ul>
<li><strong>确保正确性</strong></li>
<li>响应数据diff</li>
</ul>
</li>
<li>重复压测验证</li>
<li>上线后评估优化效果<ul>
<li>关注监控</li>
<li>收集性能数据</li>
<li>逐步放量</li>
</ul>
</li>
</ul>
<h3 id="服务链路性能优化"><a href="#服务链路性能优化" class="headerlink" title="服务链路性能优化"></a>服务链路性能优化</h3><p>分析链路</p>
<h2 id="基础库优化"><a href="#基础库优化" class="headerlink" title="基础库优化"></a>基础库优化</h2><ol>
<li>分析基础库核心逻辑和性能瓶颈<ul>
<li>设计完善的改造方案</li>
<li>数据按需获取</li>
<li>序列化反序列化优化</li>
</ul>
</li>
<li>内部压测验证</li>
<li>推广业务服务落地验证</li>
</ol>
<h2 id="Go语言优化"><a href="#Go语言优化" class="headerlink" title="Go语言优化"></a>Go语言优化</h2><p>编译器 &amp; 运行时优化</p>
<ul>
<li>优化<strong>内存分配策略</strong></li>
<li>优化代码<strong>编译流程</strong>，生成更高效的程序</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Profile</tag>
      </tags>
  </entry>
  <entry>
    <title>GFS</title>
    <url>/2022/12/17/GFS/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Big storage abstraction is important in distributed systems.</p>
<p>Why is it hard?</p>
<ul>
<li>Performance –&gt; Sharding</li>
<li>Faults –&gt; Tolerance</li>
<li>Tolerance –&gt; Replication</li>
<li>Replication –&gt; Consistency</li>
<li>Consistency –&gt; Low Performance</li>
</ul>
<span id="more"></span>

<p>Why we need GFS?</p>
<ul>
<li>A strawman replication design:</li>
</ul>
<p><img src="D:\Blog\source_images\repl.drawio.png" alt="repl.drawio"></p>
<ul>
<li>User1 write 1 to two machines, User2 write 2 to two machines</li>
<li>Due to the network, server1 see 2 first; server2 see 1 first.</li>
<li>Consistency is destroyed!</li>
</ul>
<p>How about GFS?</p>
<ul>
<li>Performance: Sharding, every file will be automatically sharded by GFS.</li>
<li>Performance: it has high aggregate performance to a large number of clients. </li>
<li>Fault Tolerance: Automatic failure recovery.</li>
<li>Designed for a single datacenter.</li>
<li>Designed for big sequential access.</li>
<li>Designed for data-intensive applications.</li>
</ul>
<p>What problem does GFS solve?</p>
<ul>
<li>Component failures are norm rather than exception<ul>
<li>Constant monitoring, error detection, fault tolerance, and automatic recovery are needed.</li>
</ul>
</li>
<li>Files are huge, so it’s unwieldy to manage billions of KB-sized files.<ul>
<li>Design choices of I&#x2F;O operation and block sizes have to be revisited.</li>
</ul>
</li>
<li>Appending and sequential reading are more common than write operation.<ul>
<li>Appending become the focus of optimization and atomicity guarantee instead of caching data blocks in the client (like what normal filesystems do).</li>
</ul>
</li>
<li>Co-designing the applications and the file system API, relaxing GFS’s consistency model, and designing an atomic append operation.</li>
</ul>
<h1 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h1><h2 id="Assumption"><a href="#Assumption" class="headerlink" title="Assumption"></a>Assumption</h2><ul>
<li>System is built from inexpensive components that <em>usually fails</em> –&gt; so it needs monitor and detect, tolerate and recovery from component failure.</li>
<li>System stores mostly large files. <em>Large files operations</em> should be efficient.</li>
<li>Two kinds of reads: <strong>large streaming read</strong> and <strong>small random reads</strong>.<ul>
<li>Performance-conscious applications often batch and sort small reads to advance steadily through the file rather than go back and forth.</li>
</ul>
</li>
<li>Two kinds of writes: <strong>large, sequential writes that append data to files</strong> (normal and need to be optimized) and <strong>small writes at random positions</strong> (rare and need not to be efficient).</li>
<li>Should support well-defined semantic of <em>appending files concurrently</em> –&gt; Atomicity with minimal synchronization overhead is needed.</li>
<li><strong>High sustained bandwidth</strong> is more important than low latency.</li>
</ul>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Files are <em>organized hierarchically</em> in directories and <em>identified by pathnames</em>.</p>
<p>support usual operations like <em>create, delete, open, close, read, write</em>.</p>
<p>GFS also has <em>snapshot</em> and <em>record append</em> operations</p>
<ul>
<li><strong>Snapshot</strong> creates a copy of a file or a directory tree at low cost. </li>
<li><strong>Record append</strong> –&gt; atomic append, allows multiple clients to append data to the same file concurrently.</li>
<li>Useful for implementing <strong>multi-way merging</strong> and <strong>producer-consumer queues</strong>.</li>
</ul>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="D:\Blog\source_images\image-20221221170828501.png" alt="image-20221221170828501"></p>
<p>GFS Clusters:</p>
<ul>
<li><p>single <em>master</em></p>
</li>
<li><p>multiple <em>chunkserver</em></p>
</li>
<li><p>multiple client (client and chunkserver can be run on same machine)</p>
</li>
<li><p>Each of these is typically a commodity Linux machine running a user-level server process.</p>
</li>
</ul>
<p>File Storage:</p>
<ul>
<li>Files are divided into <strong>fix-sized</strong> chunks.</li>
<li>Each <strong>chunks</strong> identified by an immutable and globally unique 64 bit chunk handle.</li>
<li><strong>Chunk handle</strong> is assigned by the master at the time of chunk creation.</li>
<li>Chunkservers store chunks on local disks as Linux files and read or write chunk data specified by a chunk handle and byte range.</li>
<li>Each chunk is replicated on multiple chunkservers.</li>
</ul>
<p>Single Master:</p>
<ul>
<li>Maintains all filesystem metadata.<ul>
<li>Namespace.</li>
<li>Access control information.</li>
<li>Mapping from file to chunks.</li>
<li>Current location of chunks.</li>
</ul>
</li>
<li>Control system-wide activities.<ul>
<li>Chunk lease management.</li>
<li>Garbage collection of orphaned chunks.</li>
<li>Chunk migration between chunkservers.</li>
</ul>
</li>
<li>Periodically communicate with chunkservers in <em>HeartBeat</em> messages to <em>give it instructions</em> and <em>collect its state</em>.</li>
</ul>
<p>Client:</p>
<ul>
<li>implement the filesystem API.</li>
<li>Communicate with master for metadata and chunkserver for data.</li>
<li>Neither client nor chunkserver cache the data.<ul>
<li>For Client, most app stream through the file, it’s too large to be cached.</li>
<li>it also eliminate cache coherence issues. (<strong>client cache metadata instead</strong>)</li>
<li>For Chunkserver, Linux’s buffer cache is enough.</li>
</ul>
</li>
</ul>
<h3 id="Single-Master"><a href="#Single-Master" class="headerlink" title="Single Master"></a>Single Master</h3><p>Benefit: simplify the design and enable master to make sophisticated chunk replacement and replication decisions by using global knowledge.</p>
<p>But we need to minimize the read and write on master so that it doesn’t become the bottleneck.</p>
<p>So Client only ask master for metadata, and caches this information for a limited time and interacts with the chunkservers directly for many subsequent operations.</p>
<hr>
<p>Simple read operation:</p>
<ol>
<li>Client translates file name and byte offset into chunk index within the file.</li>
<li>Client sends request to master containing chunk index and file name.</li>
<li>Master replies with the corresponding chunk handle and location of replicas.</li>
<li>Client caches the information using the fila name and chunk index as the key.</li>
<li>Client then sends the request to one of the replicas (mostly the closest one), the request specifies the chunk range and chunk handle<ul>
<li>In fact, the client typically asks for multiple chunks in the same request and the master can also include the informa- tion for chunks immediately following those requested</li>
</ul>
</li>
</ol>
<h3 id="Chunk-Size"><a href="#Chunk-Size" class="headerlink" title="Chunk Size"></a>Chunk Size</h3><p>Chunk Size, 64MB, is much larger than file system block sizes.</p>
<p>Each chunk is stored as plain Linux file and extended only as needed. This kind of lazy allocation avoids space wasting due to internal fragmentation.</p>
<p>Advantages of large chunk size:</p>
<ul>
<li>Reduce client’s needs to interact with master.</li>
<li>Since on a large chunk, a client is more likely to perform many operations on a given chunk.</li>
<li>Reduces the size of the metadata stored on the master. Thus we can keep the metadata in memory.</li>
</ul>
<p>Disadvantages of large chunk size:</p>
<ul>
<li>Small files consist a small number of chunks. The chunkservers storing those chunks may become hot spots if many clients are accessing the same file</li>
<li>In practice, hot spot is not a major problem. But hot spots did develop when GFS was first used by a batch-queue system.<ul>
<li>One solution: making the batch-queue system stagger application start times</li>
<li>A potential long-term solution: allow clients to read data from other clients in such situations.</li>
</ul>
</li>
</ul>
<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>All metadata is kept in memory, there are three kind of metadata:</p>
<ol>
<li>The file and chunk namespace.</li>
<li>The mapping from files to chunks.</li>
<li>location of each chunks’ replicas.</li>
</ol>
<p>First two kinds of metadata (namespaces and file-to-chunk mapping) is logged on local disk and replicated by a remote machine. The master doesn’t store chunk location information, instead, it ask each chunkserver about its chunks at master’s startup and whenever chunkserver joins the cluster.</p>
<hr>
<p>Why we want data structure in-memory?</p>
<ul>
<li>Since metadata is stored in memory, master can easily periodically scan the entire state <strong>in the background</strong>. This periodic scanning is used to implement <strong>chunk garbage collecting</strong>, <strong>re-replication in the presence of chunkserver failures</strong>, <strong>chunk migration between chunkservers for balance-loading and disk space usage</strong>.</li>
</ul>
<p>Why we don’t need to keep chunk location persistent in disk?</p>
<ul>
<li>The master can keep chunk location up-to-date thereafter because it controls all chunk placement and monitors chunkserver status <strong>with regular HeartBeat messages</strong>. This also eliminate the problem of <em>keeping the master and chunkservers in sync</em> as chunkservers <em>join and leave the cluster, change names, fail, restart, and so on</em>.</li>
</ul>
<p>What is operation log?</p>
<ul>
<li>It contains historical record of critical metadata changes.<ul>
<li>It is the only persistent record of metadata.</li>
<li>It serves as local timeline that defines the order of concurrent operations.</li>
<li>Files, chunks and their versions are identified by local time.</li>
</ul>
</li>
<li>Operation log must be stored reliably and we should not make changes visible to clients until metadata changes are made persistent.</li>
<li>We replicate it on multiple remote machines and respond to a client operation only after flushing the corresponding log record to disk both locally and remotely.</li>
<li>The master batches several log records together before flushing thereby reducing the impact of flushing and replication on overall system throughput.</li>
</ul>
<h3 id="Consistency-Model"><a href="#Consistency-Model" class="headerlink" title="Consistency Model"></a>Consistency Model</h3><p>GFS has a relaxed consistency model</p>
<p>What is guarantees by GFS?</p>
<ul>
<li><p><strong>File namespaces mutations are atomic</strong>, it’s handled by master using a namespace locking. And the global total order is defined by master’s operation log file.</p>
</li>
<li><p>File region state after mutation</p>
<ul>
<li>A file region is consistent if all clients will always see the same data, regardless of which replicas they read from.</li>
<li>A region is defined after a file data mutation if it is consistent and clients will see what the mutation writes in its entirety. </li>
<li>When a mutation succeeds without interference from concurrent writers, the affected region is defined.</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>write</th>
<th>record append</th>
</tr>
</thead>
<tbody><tr>
<td>Serial success</td>
<td>defined</td>
<td>defined, interspersed with inconsistent</td>
</tr>
<tr>
<td>Concurrent success</td>
<td>consistent but undefined</td>
<td>defined, interspersed with inconsistent</td>
</tr>
<tr>
<td>Failure</td>
<td>inconsistent</td>
<td>inconsistent</td>
</tr>
</tbody></table>
</li>
<li><p>Atomic append –&gt; data appended <em>at least once</em>, but at an offset of GFS’s choosing.</p>
<ul>
<li>The offset is returned to the client and marks the beginning of a defined region that contains the record.</li>
<li>GFS may insert padding or record duplicates in between.</li>
</ul>
</li>
<li><p>After a sequence of successful mutations, the mutated file region is guaranteed to be defined.</p>
<ul>
<li>By applying mutations to a chunk in same order on all replicas.</li>
<li>By using chunk version to detect stale replica.</li>
<li>Stale chunk will be garbage collected.</li>
</ul>
</li>
<li><p>Client cache the chunk locations, they may read from stale replicas.</p>
<ul>
<li>This window is limited by lease time</li>
<li>stale replica usually return premature end rather than outdated data since most files are append-only.</li>
</ul>
</li>
</ul>
<p>Implication of Applications</p>
<ul>
<li>append-only rather than writes</li>
<li>checkpointing</li>
<li>self-validating, e.g. record checksums</li>
<li>self-identifying, e.g. record identifier</li>
</ul>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="Lease-and-Mutation-Order"><a href="#Lease-and-Mutation-Order" class="headerlink" title="Lease and Mutation Order"></a>Lease and Mutation Order</h2><p>We use lease to maintain a consistent mutation order across replicas. The master grant a chunk lease to one of the replicas, called <em>primary</em>. A <em>primary</em> picks a mutation ordering for all replicas.</p>
<p>Lease mechanism is designed to <strong>minimize management overhead of master</strong>. It has timeout of 60s. </p>
<p><img src="D:\Blog\source_images\image-20221221223610132.png" alt="image-20221221223610132"></p>
<p>Write operation:</p>
<ol>
<li>Client asks Master who is the primary and other replica locations. If there is no primary, master then  grants one</li>
<li>Master replies the information, and client cache the data for future mutations. It needs to request master again only when primary becomes unreachable.</li>
<li>Client pushes data to all replicas. Chunkserver stores the data in local LRU buffer cache until the data is used or aged out.</li>
<li>Once the replicas have acknowledged the data, Client sends write request to primary. The primary assigns consecutive serial numbers to mutations.</li>
<li>The primary forward the write request to all replicas.</li>
<li>The secondary reply to primary when completed.</li>
<li>The primary replies to the client. <ul>
<li>If error happens at the secondary, primary sends error message to client; Then the client request is considered failed, and the modified region is left in an <strong>inconsistent state</strong>.</li>
<li>If it had failed at the primary, it would not have been assigned a serial number and forwarded.</li>
<li>Client code handles such errors by retrying the failed mutation.</li>
</ul>
</li>
</ol>
<p>If a write by the application is large or straddles a chunk boundary, GFS client code breaks it down into multiple write operations. Final result is consistent but maybe undefined because of interleave of other write operations.</p>
<h2 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h2><p>The control flow and data flow are decoupled, data is <strong>pushed linearly</strong> along a <strong>carefully picked chain</strong> of chunkservers <strong>in a pipelined fashion</strong> to fully <strong>utilize network bandwidth</strong> (so full outbound bandwidth is used to transfer data as fast as possible).</p>
<p>To <strong>avoid high-latency links</strong>, each machine forward data to “closest” machine in network that has not received the data.</p>
<h2 id="Atomic-Append"><a href="#Atomic-Append" class="headerlink" title="Atomic Append"></a>Atomic Append</h2><p>Difference between traditional write and record append?</p>
<ul>
<li>Traditional write: Client specify data and offset –&gt; the concurrent write is not serializable.</li>
<li>In record append (atomic append), Client only specify the data, GFS determine the offset and appends data to the file at least once atomically. And GFS returns the offset to the client.</li>
</ul>
<p>Why we need atomic append?</p>
<ul>
<li>Without atomic append, Clients would need more complicated and expensive synchronization, like through a lock manager.</li>
</ul>
<p>How does atomic append do?</p>
<ul>
<li><p>Record append is mutation that follows the control flow above with only a little extra logic at the primary. </p>
<ul>
<li><p>The primary checks to see if appending the record to the current chunk would cause the chunk to exceed the maximum size (64 MB). If so, it pads the chunk to the maximum size, tells secondaries to do the same, and replies to the client indicating that the operation should be retried on the next chunk.</p>
</li>
<li><p>Record append is restricted to be at most one-fourth of the maximum chunk size to keep worstcase fragmentation at an acceptable level.</p>
</li>
</ul>
</li>
</ul>
<p>How to deal with the inconsistency caused by atomic append?</p>
<ul>
<li>If a record append fails at any replica, the client retries the operation. </li>
<li>As a result, replicas of the same chunk may contain different data possibly including duplicates of the same record in whole or in part. GFS does not guarantee that all replicas are bytewise identical.</li>
<li>Record is written <em><strong>at least once</strong></em>!</li>
<li>Application is responsible for dealing with the inconsistency.</li>
</ul>
<h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>How to implement snapshot using a <strong>copy-on-write</strong> technique?</p>
<ol>
<li>Master receive a snapshot request and then revoke leases.</li>
<li>Master log the request to disk. Then create new files but pointing to same chunks as source files.</li>
<li>When Client want to write to chunk C in new files, It sends request to master to find lease holder, The Master noticed that the reference to C is greater than 1, It then asks each chunkserver that has a current replica of C to create a new chunk called C’. <ul>
<li>By creating the new chunk on the same chunkservers as the original, we ensure that the data can be copied locally, not over the network.</li>
</ul>
</li>
</ol>
<h1 id="Master-Operation"><a href="#Master-Operation" class="headerlink" title="Master Operation"></a>Master Operation</h1><p>Master manage namespace operations, manage chunk replicas throughout the system, make placement decisions, create new chunks, coordinate system-wide activities, balance load.</p>
<h2 id="Namespace-Management-and-Locking"><a href="#Namespace-Management-and-Locking" class="headerlink" title="Namespace Management and Locking"></a>Namespace Management and Locking</h2><p>Unlike traditional filesystems, GFS logically represent its namespace as lookup table mapping pathname to metadata. </p>
<p>Prefix compression –&gt; makes it suitable in memory. </p>
<p>Each node in lookup table has a read-write lock. </p>
<p>How to lock?</p>
<ul>
<li>Since the namespace can have many nodes, read-write lock objects are allocated lazily and deleted once they are not in use.</li>
<li>locks are acquired in a consistent total order to prevent deadlock: they are first ordered by level in the namespace tree and lexicographically within the same level.</li>
</ul>
<h2 id="Replica-Placement-Physically"><a href="#Replica-Placement-Physically" class="headerlink" title="Replica Placement (Physically)"></a>Replica Placement (Physically)</h2><p>Purpose of chunk replica placement policy:</p>
<ul>
<li>maximize data reliability and availability</li>
<li>maximize network bandwidth utilization</li>
</ul>
<p>Method: Spread chunk replicas across racks. This ensures that some replicas of a chunk will survive and remain available even if an entire rack is damaged or offline (such as network partitioning).</p>
<h2 id="Replicas-Management"><a href="#Replicas-Management" class="headerlink" title="Replicas Management"></a>Replicas Management</h2><p>Chunk replicas are created for three reasons: </p>
<ul>
<li>chunk creation</li>
<li>re-replication</li>
<li>rebalancing.</li>
</ul>
<p>Where to place initial empty replicas when creating a chunk?</p>
<ul>
<li>We want to place new replicas on chunkserver whose spare disk space is more than average.</li>
<li>We want to limit recent creation on chunkserver (to avoid heavy write on this chunkserver)</li>
<li>We want to spread chunk replicas across racks.</li>
</ul>
<p>The master re-replicates a chunk as soon as the number of available replicas falls below a user-specified goal. Similar to creating a chunk replica.</p>
<p>The master rebalances replicas periodically: it examines the current replica distribution and moves replicas for better disk space and load balancing.</p>
<h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><p>After a file is deleted, GFS does not immediately reclaim the available physical storage. It does so only lazily during regular garbage collection at both the file and chunk levels</p>
<p>How GFS do garbage collection?</p>
<ul>
<li><p>For Master</p>
<ul>
<li><p>When a file is deleted, it is logged by master immediately. But master rename it to a hidden name with  deletion timestamp.</p>
</li>
<li><p>During the master’s regular scan of the file system namespace, it removes any such hidden files if they have existed for more than three days.</p>
</li>
</ul>
</li>
<li><p>For Chunkserver</p>
<ul>
<li>In a similar regular scan of the chunk namespace, the master identifies orphaned chunks and erases the metadata for those chunks. </li>
<li>In a HeartBeat message regularly exchanged with the master, each chunkserver reports a subset of the chunks it has, and the master replies with the identity of all chunks that are no longer present in the master’s metadata. </li>
<li>Then the chunkserver is free to delete its replicas of such chunks.</li>
</ul>
</li>
</ul>
<p>Benefit:</p>
<ol>
<li>Simple and reliable for distributed system.</li>
<li>It merge storage reclamation into regular background activities.</li>
<li>The delay in reclaiming storage provides a safety net against accidental, irreversible deletion.</li>
</ol>
<p>Main disadvantage: frequently creation and deletion will cause the space tight.</p>
<p>Solution: expediting storage reclamation if a deleted file is explicitly deleted again.</p>
<h2 id="Stale-Replica-Detection"><a href="#Stale-Replica-Detection" class="headerlink" title="Stale Replica Detection"></a>Stale Replica Detection</h2><p>Master increase the chunk version number when it grant a new lease on a chunk. When a replica is not available at this time, its chunk version will not advanced. So when it restart and report its chunk version number to Master, Master will detect that it is a stale replica. </p>
<p>The master removes stale replicas in its regular garbage collection </p>
<h1 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h1><p>Two problems caused by <strong>component failure</strong>:</p>
<ul>
<li>unavailability</li>
<li>corrupted data</li>
</ul>
<h2 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a>Availability</h2><p>Two strategies for high availability:</p>
<ul>
<li>Fast Recovery<ul>
<li>Restore state and restart no matter how they terminated.</li>
</ul>
</li>
<li>Replication<ul>
<li>Chunk Replication</li>
<li>Master Replication</li>
</ul>
</li>
</ul>
<h2 id="Data-Integrity"><a href="#Data-Integrity" class="headerlink" title="Data Integrity"></a>Data Integrity</h2><p>Why we need checksum in chunkserver to detect corruption of stored data?</p>
<ul>
<li>Disks and machines failures are common, causing data corruption.</li>
<li>But it’s impractical to compare replicas to detect corruption. Besides, the semantic of record append doesn’t guarantee identical replicas.</li>
<li>Therefore, each chunkserver must independently verify the integrity of its own copy by maintaining checksums.</li>
</ul>
<p>What happens when reading corrupted data?</p>
<ul>
<li>For Reads, chunkserver verify checksum of data block before returning any data to requester.</li>
<li>If it doesn’t match the checksum, it returns a error to requester and report a mismatch to the master.</li>
<li>Master re-replicate the chunk.</li>
<li>Then master instruct deletion of the corrupted replica.</li>
</ul>
<p>How to calculate checksum when writing data?</p>
<ul>
<li>For appending, There is no need to read the data to checksum first. Because we can checksum later when reading this data.</li>
<li>For random writing, we must read the data and checksum first.</li>
</ul>
<p>Like other metadata, checksums are kept in memory and stored persistently with logging, separate from user data.</p>
<p>During idle periods, chunkservers can scan and verify the contents of inactive chunks.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>GFS structure:</p>
<ul>
<li>Master Data: two tables that matter<ul>
<li>file name –&gt; array of chunk handles</li>
<li>handle –&gt; list of chunk servers, version number, primary, lease expiration</li>
<li>Log and Checkpoint of the 2 above tables –&gt; disk</li>
</ul>
</li>
</ul>
<p>GFS read operation:</p>
<ol>
<li>Client sends file and offset to Master.</li>
<li>Master sends back chunk handles and list of servers back to Client.<ul>
<li>Client cache the map.</li>
</ul>
</li>
<li>Client talk to one of the chunk servers (maybe one closest to the Client)<ul>
<li>chunk server runs Linux filesystem, chunk is stored by file whose name is chunk handle.</li>
</ul>
</li>
<li>Chunk server sends back the chunk files to Client.</li>
</ol>
<p>GFS write(append) operation:</p>
<ul>
<li><p>No Primary</p>
<ol>
<li>Find up-to-date replicas (according to the version numbers in the master).</li>
<li>Pick a primary and a secondary.</li>
<li>Increase the version number.</li>
<li>Sends the primary and secondary with the updated version number and messages and <em>lease</em>.</li>
<li>Master write the version number to the disk.</li>
</ol>
</li>
<li><p>Primary</p>
<ol>
<li>Client sends message to Primary.</li>
<li>Primary sends message to Secondary.</li>
<li>If all Secondary replies ok, Primary sends ok to Client.</li>
<li>Else Primary sends not ok to Client.</li>
</ol>
</li>
</ul>
<p>why we need lease?</p>
<ul>
<li>to avoid “split brain” problem caused by network partition</li>
</ul>
]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Network</title>
    <url>/2022/12/16/Go-Network/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Network</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Current Limit</title>
    <url>/2022/12/15/Current-Limit/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce</title>
    <url>/2022/12/15/MapReduce/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>MapReduce: a <strong>programming model</strong> and <strong>associated implementation</strong> for <strong>processing and generating large datasets</strong>.</p>
<ul>
<li>Map: process key&#x2F;value pair to generate intermediate key&#x2F;value pairs.</li>
<li>Reduce: merges all intermediate values associated with the same intermediate key.</li>
</ul>
<span id="more"></span>

<p>runtime system responsibility:</p>
<ul>
<li>Partitioning the input data.</li>
<li>Scheduling the program’s execution across a set of machines.</li>
<li>Handling managed failures.</li>
<li>Managing inter-machine communication.</li>
</ul>
<p>Motivation:</p>
<ul>
<li>Special purpose coding on distributed systems is hard.</li>
<li>Hide the messy details of parallelization, fault-tolerance, data distribution and load balancing.</li>
</ul>
<h1 id="Programming-Model"><a href="#Programming-Model" class="headerlink" title="Programming Model"></a>Programming Model</h1><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>map and reduce functions are deterministic functions: always get the same output with same input.</p>
<p>map: (k1, v1) –&gt; list(k2, v2)</p>
<p>reduce: (k2, list(v2)) –&gt; list(v3)</p>
<p>Input keys and values are drawn from different domain than the output keys and values. But intermediate keys and values are from the same domain. </p>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul>
<li><p>Distributed Grep</p>
</li>
<li><p>Count of URL Access Frequency</p>
</li>
<li><p>Reverse Web-Link Graph: The map function outputs $&lt;target, source&gt;$ pairs for each link to a target URL found in a page named source. The reduce function concatenates the list of all source URLs associated with a given target URL and emits the pair $&lt;target, list(source)&gt;$</p>
</li>
<li><p>Term-Vector per Host</p>
</li>
<li><p>Inverted Index: The map function parses each document, and emits a sequence of $&lt;word, document ID&gt;$ pairs. The reduce function accepts all pairs for a given word, sorts the corresponding document IDs and emits a $&lt;word, list(document ID)&gt;$ pair. The set of all output pairs forms a simple inverted index. It is easy to augment this computation to keep track of word positions.</p>
</li>
<li><p>Distributed Sort: The map function extracts the key from each record, and emits a $&lt;key, record&gt;$ pair. The reduce function emits all pairs unchanged. This computation depends on the partitioning functions and the R files’ ordering properties.</p>
</li>
</ul>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>Implementation environment:</p>
<ul>
<li>Commodity computers are used.</li>
<li>Network (switched Ethernet) is the bottleneck.</li>
<li>Cluster of computers, thus <strong>machine failures are common</strong>.</li>
<li>Storage hardware is inexpensive; using a distributed file system (GFS) to manage data; replication is used.</li>
<li>Users submit jobs to a scheduling system. Each <strong>job</strong> consists of <strong>a set of tasks</strong>, and is <strong>mapped by the scheduler</strong> to a set of available machines within a cluster.</li>
</ul>
<h2 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h2><p><img src="D:\Blog\source_images\image-20221217145110248.png" alt="image-20221217145110248"></p>
<p>What happens when user call MapReduce:</p>
<ol>
<li>The MapReduce library first split input files into M pieces of typically 16 to 64 MB per pieces. It then starts up many copies of the user program on a cluster of machines.</li>
<li>The copied program on master is special. The rest are workers that are assigned work by the master. There are M map tasks and R reduce tasks to assign. The master picks idle workers and assigns each one a map task or a reduce task.</li>
<li>A worker who is assigned a map task reads the input split, and use user-defined map function to process the split. The <strong>intermediate keys and values are buffered in the memory</strong>.</li>
<li><strong>Periodically, the buffered pairs are written to disk</strong>, partitioned into R regions by partition function i.e. $hash(key)%R$. The locations of these buffered pairs on the local disk are passed back to the master, who is responsible for forwarding these locations to the reduce workers.</li>
<li>When a reducer worker is notified by master about the locations, it then uses remote procedure call (RPC) to remotely reads the intermediate keys and values from the map worker’s local disks.</li>
<li>When a reduce worker has read all intermediate data, it sorts it by the intermediate keys so that all occurrences of the same key are grouped together. The <em><strong>sorting is needed because typically many different keys map to the same reduce task</strong></em>. If the amount of intermediate data is too large to fit in memory, an <strong>external sort</strong> (i.e. external merge sort) is used.</li>
<li>The reduce worker iterate the sorted intermediate data, for each unique intermediate key encountered, it passed the key and the corresponding list of intermediate values to user’s reduce function. The output of Reduce function is appended to a final output file for this reduce partition.</li>
<li>When all map tasks and reduce tasks had been done, the master wakeup the user program.</li>
<li>After successful completion, the output is available in R output files. They can be used as input of another MapReduce call.</li>
</ol>
<h2 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h2><p>For each map task and reduce task, it stores:</p>
<ul>
<li>The state (idle, in-progress, or completed)</li>
<li>The identity of the worker machine (for non-idle tasks).</li>
</ul>
<p>master is like a conduit:</p>
<ul>
<li>it propagate the location of R regions on map tasks to reduce tasks</li>
<li>Therefore, for each completed map tasks, the master stores the locations and sizes of R regions.</li>
<li>Updates to this location and size information are received as map tasks are completed. The information is pushed incrementally to workers that have in-progress reduce tasks</li>
</ul>
<h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><h3 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h3><p>How to determine failure of worker?</p>
<ul>
<li>The master pings every worker periodically. If no response is received from a worker in a certain amount of time, the master marks the worker as failed.</li>
</ul>
<p>Which tasks to rollback when workers failed?</p>
<ul>
<li>Any map tasks completed by the failed worker are reset back to their initial idle state, and therefore become eligible for scheduling on other workers. </li>
<li>Similarly, any map task or reduce task in progress on a failed (map or reduce separately) worker is also reset to idle and becomes eligible for rescheduling.</li>
</ul>
<p> Why completed map tasks on failed worker should re-execute while completed reduce tasks don’t?</p>
<ul>
<li>Completed map tasks are re-executed on a failure because their <em>output is stored on the local disk(s)</em> of the failed machine and is therefore <strong>inaccessible</strong>. </li>
<li>Completed reduce tasks do not need to be re-executed since <strong>their output is stored in a global file system</strong>.</li>
</ul>
<p>What happens if map tasks are re-executed?</p>
<ul>
<li>When a map task is executed first by worker A and then later executed by worker B (because A failed), all workers executing reduce tasks are notified of the re-execution. Any reduce task that has not already read the data from worker A will read the data from worker B.</li>
</ul>
<h3 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h3><p>Can be solved with periodic checkpoints of master data structure.</p>
<p>But since there is only one master, it’s unlikely to fail.</p>
<p>So when master fails, we can just abort the computation.</p>
<h3 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h3><p>When user-supplied map and reduce functions are deterministic:</p>
<ul>
<li>MapReduce will produce the same output as non-faulting sequential execution of program.</li>
<li>That property relies on <em><strong>atomic commit</strong></em> of map and reduce tasks.<ul>
<li>For map tasks: when a map task completes, the worker sends a message to the master and includes the names of the R temporary files in the message. <em>If the master receives a completion message for an already completed map task, it ignores the message. Otherwise, it records the names of R files in a master data structure</em>.</li>
<li>For reduce tasks: when a reduce task completes, the <em>reduce worker atomically renames its temporary output file to the final output file</em>. If the same reduce task is executed on multiple machines, multiple rename calls will be executed for the same final output file. We rely on the atomic rename operation provided by the underlying file system to guarantee that the final file system state contains just the data produced by one execution of the reduce task.</li>
</ul>
</li>
</ul>
<p>When user-supplied map and reduce functions are non-deterministic:</p>
<ul>
<li>MapReduce will provide weaker but still reasonable semantics.</li>
<li>In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program. However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.</li>
<li>Consider map task M and reduce tasks $R_1$ and $R_2$. Let $e(R_i)$ be the execution of $R_i$ that committed (there is exactly one such execution). The weaker semantics arise because $e(R_1)$ may have read the output produced by one execution of M and $e(R_2)$ may have read the output produced by a different execution of M.</li>
</ul>
<h2 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h2><p>Since network bandwidth is the bottleneck, one optimization is that running GFS and MapReduce on the same set of machines. And master schedule map tasks to read input locally as possible.</p>
<h2 id="Task-Granularity"><a href="#Task-Granularity" class="headerlink" title="Task Granularity"></a>Task Granularity</h2><p>Ideally M and R should be much larger than number of workers</p>
<ul>
<li>Improves load balancing</li>
<li>Speeds up recovery</li>
</ul>
<p>Practical bounds of M and R:</p>
<ul>
<li>master must take $O(M+R)$ to do scheduling, and take $O(M*R)$ piece of state.</li>
<li>R is also constrained by users because the output of each reduce task ends up in a separate output file.</li>
<li>R is often a small multiple of the number of worker machines we expect to use.</li>
</ul>
<h2 id="Backup-Tasks"><a href="#Backup-Tasks" class="headerlink" title="Backup Tasks"></a>Backup Tasks</h2><p>What is a straggler?</p>
<ul>
<li>straggler is the machine that takes an unusually long time to compute the tasks, it’s often the bottleneck.</li>
</ul>
<p> Backup mechanism to deal with straggler</p>
<ul>
<li>When a <strong>MapReduce operation is close to completion</strong>, the master <strong>schedules backup executions of the remaining in-progress tasks</strong>.</li>
<li>The task is marked as completed whenever either the primary or the backup execution completes.</li>
</ul>
<h1 id="Refinement"><a href="#Refinement" class="headerlink" title="Refinement"></a>Refinement</h1><h2 id="Partition-Function"><a href="#Partition-Function" class="headerlink" title="Partition Function"></a>Partition Function</h2><p>Default partition function: $hash(key)%R$, this tends to generate well-balanced partitions.</p>
<p>But sometimes input are skewed, we need some special partition functions.</p>
<p>For example, when output keys are URLs, and we want all entries for a single host to end up in the same output file. We can then use $hash(Hostname(url))$.</p>
<h2 id="Ordering-Guarantees"><a href="#Ordering-Guarantees" class="headerlink" title="Ordering Guarantees"></a>Ordering Guarantees</h2><p>Within a given partition, the intermediate key&#x2F;value pairs are processed in increasing key order (because it is sorted by reduce). </p>
<p>This ordering makes it easy to <em><strong>generate a sorted output file per partition</strong></em>, which is useful when the output file format needs to support efficient <strong>random access lookups by key</strong> (hash + binary search, similar to hash join algorithm in database)</p>
<h2 id="Combiner-Functions"><a href="#Combiner-Functions" class="headerlink" title="Combiner Functions"></a>Combiner Functions</h2><p>Combiner functions is like a reduce function but runs on map workers.</p>
<p>It can reduce the network overhead by pre-processing (aggregating) the keys and values.</p>
<p>For some kind of tasks, it’s very useful.</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="Input-and-Output-Formats"><a href="#Input-and-Output-Formats" class="headerlink" title="Input and Output Formats"></a>Input and Output Formats</h3><p>Text mode: treat each line as key&#x2F;value pair</p>
<ul>
<li>key: offset in the file</li>
<li>value: content of the line</li>
</ul>
<p>Reader mode: user provide reader interface to split the range.</p>
<h3 id="Side-effects"><a href="#Side-effects" class="headerlink" title="Side effects"></a>Side effects</h3><p>It is useful to generate auxiliary files in map or reduce tasks, MapReduce don’t provide two-phase commit. Therefore, tasks that produce multiple output files with cross-file consistency requirements should be deterministic.</p>
<h3 id="Skipping-Bad-Records"><a href="#Skipping-Bad-Records" class="headerlink" title="Skipping Bad Records"></a>Skipping Bad Records</h3><p>Sometimes it is feasible to ignore some bad records caused by user program, for example doing a statistic analysis on a large dataset.</p>
<p>MapReduce provide some mode to detect records that caused deterministic crashes and skip these records.</p>
<h3 id="Local-Execution"><a href="#Local-Execution" class="headerlink" title="Local Execution"></a>Local Execution</h3><p>Debugging MapReduce is triky, so MapReduce provide tools of debugging, profiling, and small-scale testing, enabling sequentially execute all of the work for a MapReduce operation on the local machine.  </p>
<h3 id="Status-Information"><a href="#Status-Information" class="headerlink" title="Status Information"></a>Status Information</h3><p>The master runs an internal HTTP server and exports a set of status pages for human consumption. </p>
<h3 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h3><p>The MapReduce library provides a counter facility to count occurrences of various events. </p>
<p>To use this facility, <em>user code creates a named counter object</em> and then <em>increments the counter appropriately in the Map and&#x2F;or Reduce function</em>. For example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Counter *uppercase;</span><br><span class="line">uppercase = <span class="built_in">GetCounter</span>(<span class="string">&quot;uppercase&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(String name, String contents) &#123;</span><br><span class="line">    <span class="keyword">for</span> (w : contents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isCapitalized</span>(w)) &#123;</span><br><span class="line">            uppercase-&gt;<span class="built_in">Increment</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">EmitIntermediate</span>(w, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The counter values from individual worker machines are periodically propagated to the master (<em>piggybacked</em> on the ping response). </p>
<p>The master aggregates the counter values from successful map and reduce tasks and returns them to the user code when the MapReduce operation is completed. </p>
<p>The current counter values are also displayed on the master status page so that a human can watch the progress of the live computation. </p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Success of MapReduce</p>
<ol>
<li>Model is easy to use, it hides parallelism, load balance, locality, fault tolerance, etc.</li>
<li>Model is expressive, can be used to solve many problems.</li>
<li>It has scalability, fault tolerance, consistency.</li>
</ol>
<p>Some takeaways</p>
<ol>
<li>Restricting programming model makes it easy for parallelism and fault tolerance.</li>
<li>Network bandwidth is scarce resource. (locality optimization).</li>
<li>Redundant execution can be used to reduce the impact of slow machines.</li>
</ol>
]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Concurrency</title>
    <url>/2022/12/15/Go-Concurrency/</url>
    <content><![CDATA[<blockquote>
<p>Materials:</p>
<ul>
<li><a href="https://vimeo.com/49718712">concurrency is not parallelism</a></li>
<li><a href="https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view">rethinking classical concurrency patterns</a></li>
<li><a href="https://pkg.go.dev/sync#pkg-overview">go sync package</a></li>
<li><a href="https://go.dev/talks/2012/concurrency.slide#1">go concurrency patterns</a></li>
<li><a href="https://blogtitle.github.io/categories/concurrency/">go advanced concurrency patterns</a></li>
</ul>
</blockquote>
<span id="more"></span>

<h1 id="Concurrency-Overview"><a href="#Concurrency-Overview" class="headerlink" title="Concurrency Overview"></a>Concurrency Overview</h1><p>Why concurrency?</p>
<ul>
<li>I&#x2F;O concurrency (network capacity, disk capacity)</li>
<li>Parallelism (multi-core machine)</li>
<li>Convenience (periodic work)</li>
</ul>
<p>Distinctions between concurrency and parallelism?</p>
<ul>
<li>Parallelism: simultaneous executing of programs, which may be correlated, or not be.</li>
<li>Concurrency:  composition of independent executing programs. <em>it’s not same as parallelism, although it enables parallelism</em>!</li>
</ul>
<p>Essence of concurrency:</p>
<ul>
<li>A complex problem can be broken down into several easy-to-understand components.</li>
<li>The pieces can be composed concurrently.</li>
<li>The result is <strong>scalable, correct and maybe parallel</strong>.</li>
</ul>
<h1 id="Go-Concurrency-Features"><a href="#Go-Concurrency-Features" class="headerlink" title="Go Concurrency Features"></a>Go Concurrency Features</h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>Goroutines</p>
<ul>
<li>It’s independently executing program with its own stack which can shrink and grow automatically</li>
<li>Goroutines are multiplexed dynamically onto threads as needed</li>
</ul>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>Communicating in go?</p>
<ul>
<li>Communicating in golang is through channels, it’s more like via file descriptor;</li>
<li>While in original CSP (Communicating Sequential Processing) is through process name, it’s more like via file</li>
</ul>
<p>Synchronization and Communication:</p>
<ul>
<li>Both send and receive are synchronous</li>
<li>A sender and receiver must both be ready to play their part in the communication. Otherwise we wait until they are.</li>
<li>Thus <strong>channels both communicate and synchronize</strong>.</li>
</ul>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>Buffered channels remove synchronization</p>
<p>It seems like Erlang’s mailbox</p>
<h2 id="The-Go-Approach"><a href="#The-Go-Approach" class="headerlink" title="The Go Approach"></a>The Go Approach</h2><p>Principle: <strong>Don’t communicate by sharing memory (i.e. mutex, locks), share memory by communicating.</strong></p>
<p>Low level concurrency: lock, mutex, condition, waitgroup, pool.</p>
<p>high level concurrency: goroutine, channel.</p>
<p><strong>garbage collector, closure, channel, goroutine, select</strong> – these features just stitch together to make concurrency in go powerful and expressive.</p>
<h1 id="Go-Concurrency-Patterns"><a href="#Go-Concurrency-Patterns" class="headerlink" title="Go Concurrency Patterns"></a>Go Concurrency Patterns</h1><h2 id="Generator-Function-Returns-a-Channel"><a href="#Generator-Function-Returns-a-Channel" class="headerlink" title="Generator : Function Returns a Channel"></a>Generator : Function Returns a Channel</h2><h3 id="Normal-Generator-Model"><a href="#Normal-Generator-Model" class="headerlink" title="Normal Generator Model"></a>Normal Generator Model</h3><p>Channels are first-class values (so as functions).</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := boring(<span class="string">&quot;boring!&quot;</span>) <span class="comment">// Function returning a channel.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;You say: %q\n&quot;</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;You&#x27;re boring; I&#x27;m leaving.&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span><span class="params">(msg <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123; <span class="comment">// Returns receive-only channel of strings.</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// We launch the goroutine from inside the function.</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">            c &lt;- fmt.Sprintf(<span class="string">&quot;%s %d&quot;</span>, msg, i)</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c <span class="comment">// Return the channel to the caller.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channels-as-a-Handle-on-a-Service"><a href="#Channels-as-a-Handle-on-a-Service" class="headerlink" title="Channels as a Handle on a Service"></a>Channels as a Handle on a Service</h3><p>Our boring function above returns a channel that lets us communicate with the boring service it provides.</p>
<p>We can have more instances of the service.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    joe := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    ann := boring(<span class="string">&quot;Ann&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(&lt;-joe)</span><br><span class="line">        fmt.Println(&lt;-ann)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Multiplexing-Fan-In"><a href="#Multiplexing-Fan-In" class="headerlink" title="Multiplexing (Fan-In)"></a>Multiplexing (Fan-In)</h3><p>These programs make Joe and Ann count in lockstep.  </p>
<p>We can instead use a fan-in function to let whosoever is ready talk.</p>
<p>It uses multi-channels as input and output a channel that receive multi channels’ output in different goroutines.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(input1, input2 &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; c &lt;- &lt;-input1 &#125; &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; c &lt;- &lt;-input2 &#125; &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := fanIn(boring(<span class="string">&quot;Joe&quot;</span>), boring(<span class="string">&quot;Ann&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(&lt;-c)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">input1 --&gt; channel1 --&gt; channel3</span><br><span class="line">input2 --&gt; channel2 --&gt; channel3</span><br><span class="line">channel3 --&gt; output</span><br></pre></td></tr></table></figure>

<h3 id="Restoring-Sequencing"><a href="#Restoring-Sequencing" class="headerlink" title="Restoring Sequencing"></a>Restoring Sequencing</h3><p>Fan-In is useful, but sometimes we want restoring the sequencing of two services.</p>
<p>Idea is <strong>sending a channel on a channel, making goroutines wait its turn</strong></p>
<p>So, first we define a struct that contains a channel for the reply</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    str <span class="type">string</span></span><br><span class="line">    wait <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For receiver who receives message:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    msg1 := &lt;-c</span><br><span class="line">    fmt.Println(msg1)</span><br><span class="line">    msg2 := &lt;-c</span><br><span class="line">    fmt.Println(msg2)</span><br><span class="line">    msg1.wait &lt;- <span class="literal">true</span>	<span class="comment">// unlock the sender which is stalled on &lt;-WaitForIt</span></span><br><span class="line">    msg2.wait &lt;- <span class="literal">true</span>	<span class="comment">// unlock the sender which is stalled on &lt;-WaitForIt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For Sender who sends message:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">WaitForIt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> ExistUnsentMessage() &#123;</span><br><span class="line">    c &lt;- message&#123;<span class="string">&quot;message&quot;</span>, WaitForIt&#125;</span><br><span class="line">    time.Sleep(time.Duration(rand.Intn(<span class="number">2e3</span>)) * time.Millisecond)</span><br><span class="line">    &lt;-WaitForIt		<span class="comment">// get stalled when </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The technique above can restore the sequence of message: for the fact that Sender cannot send message twice to channel <code>c</code> because it will get stalled in <code>&lt;-WaitForIt</code> statement</p>
<blockquote>
<p>Assume sender1 sends on msg1, then it will get stalled on <code>&lt;-WaitForIt</code>, sender2 then can send on msg2, and also get stalled on <code>&lt;-WaitForIt</code>, and because sender1 sent first, so sender1 get stalled on <code>c &lt;- message&#123;...&#125;</code> first, so msg1 is still sender1</p>
</blockquote>
<blockquote>
<p> Assume sender1 sends on msg2, then sender2 sends on msg1, so the same situation as above  </p>
</blockquote>
<h2 id="Select-Statement"><a href="#Select-Statement" class="headerlink" title="Select Statement"></a>Select Statement</h2><h3 id="Fan-In-Using-Select"><a href="#Fan-In-Using-Select" class="headerlink" title="Fan-In Using Select"></a>Fan-In Using Select</h3><p>By using select statement, we only need to start one goroutine to fan-in channels.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(input1, input2 &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input1:  c &lt;- s</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input2:  c &lt;- s</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Timeout-Using-Select"><a href="#Timeout-Using-Select" class="headerlink" title="Timeout Using Select"></a>Timeout Using Select</h3><p>The time.After function returns a channel that blocks for the specified duration.<br>After the interval, the channel delivers the current time, once.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">            fmt.Println(<span class="string">&quot;You&#x27;re too slow.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Timeout-for-Whole-Conversation-Using-Select"><a href="#Timeout-for-Whole-Conversation-Using-Select" class="headerlink" title="Timeout for Whole Conversation Using Select"></a>Timeout for Whole Conversation Using Select</h3><p>Create the timer once, outside the loop, to time out the entire conversation.<br>While in the previous program, we had a timeout for each message.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := boring(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    timeout := time.After(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">            fmt.Println(<span class="string">&quot;You talk too much.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Receive-on-quit-channel"><a href="#Receive-on-quit-channel" class="headerlink" title="Receive on quit channel"></a>Receive on quit channel</h3><p>When it want to quit a goroutine, send message on quit channel</p>
<p><code>case &lt;-quit</code> will do cleanup (like remove a temporary file), and tell back that it had quit (<strong>round-trip quit, in case that main goroutine quit before cleanup had been done</strong>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">c := boring(<span class="string">&quot;Joe&quot;</span>, quit)</span><br><span class="line"><span class="keyword">for</span> i := rand.Intn(<span class="number">10</span>); i &gt;= <span class="number">0</span>; i-- &#123; fmt.Println(&lt;-c) &#125;</span><br><span class="line">quit &lt;- <span class="string">&quot;Bye!&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Joe says: %q\n&quot;</span>, &lt;-quit)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- fmt.Sprintf(<span class="string">&quot;%s: %d&quot;</span>, msg, i):</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">    cleanup()</span><br><span class="line">    quit &lt;- <span class="string">&quot;See you!&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Daisy-Chain"><a href="#Daisy-Chain" class="headerlink" title="Daisy Chain"></a>Daisy Chain</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	routine1 --&gt; routine2 --left channel--&gt; routine3 --right channel--&gt; routine4 --&gt; routine5 --&gt; routine...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(left, right <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    left &lt;- <span class="number">1</span> + &lt;-right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="number">10000</span></span><br><span class="line">    leftmost := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    right := leftmost</span><br><span class="line">    left := leftmost</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        right = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> f(left, right)</span><br><span class="line">        left = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123; c &lt;- <span class="number">1</span> &#125;(right)</span><br><span class="line">    fmt.Println(&lt;-leftmost)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Rethinking-Classical-Concurrent-Patterns"><a href="#Rethinking-Classical-Concurrent-Patterns" class="headerlink" title="Rethinking Classical Concurrent Patterns"></a>Rethinking Classical Concurrent Patterns</h1><p>Two principles in go:</p>
<ol>
<li>Start goroutines when you have concurrent work</li>
<li>Share by communicating</li>
</ol>
<p>Other principles in go:</p>
<ol>
<li>Make concurrency internal detail.</li>
<li>Add concurrency on the caller side of the API.</li>
<li>Concurrency is not asynchronicity.</li>
</ol>
<h2 id="Asynchronous-API"><a href="#Asynchronous-API" class="headerlink" title="Asynchronous API"></a>Asynchronous API</h2><p>Concurrency is not asynchronicity.</p>
<p>An asynchronous API returns to the caller <strong>before its result is ready</strong>.</p>
<p>An asynchronous program is not necessarily concurrent: a program could call an asynchronous function and then sit idle waiting for the results.</p>
<p>There are several asynchronous patterns:</p>
<ul>
<li>asynchronous callback (deprecated)</li>
<li>future</li>
<li>producer-consumer queue</li>
</ul>
<h3 id="Asynchronous-Callback"><a href="#Asynchronous-Callback" class="headerlink" title="Asynchronous Callback"></a>Asynchronous Callback</h3><p>A callback is a simple function that’s passed as a value to another function, and will only be executed when the event happens.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetch immediately returns, then fetches the item and </span></span><br><span class="line"><span class="comment">// invokes f in a goroutine when the item is available. </span></span><br><span class="line"><span class="comment">// If the item does not exist,</span></span><br><span class="line"><span class="comment">// Fetch invokes f on the zero Item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>, f <span class="keyword">func</span>(Item)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        […]</span><br><span class="line">        f(item)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>In the Future pattern, instead of returning the result, the function returns a proxy object that allows the caller to wait for the result at some later point.</p>
<p>The Go analogue to a <strong>Future</strong> is a <strong>single-element buffered channel</strong>.</p>
<p>To use Futures for concurrency, the caller must <strong>set up concurrent work before retrieving results</strong>.</p>
<p>If they retrieve the results too early, the program executes <em>sequentially instead of concurrently</em>.</p>
<p>the channel pattern seems to be more common than the function-based alternative</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: API, channel-based</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch immediately returns a channel, then fetches </span></span><br><span class="line"><span class="comment">// the requested item and sends it on the channel. </span></span><br><span class="line"><span class="comment">// If the item does not exist,</span></span><br><span class="line"><span class="comment">// Fetch closes the channel without sending.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        […]</span><br><span class="line">        c &lt;- item</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: The precise way, function-based</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">()</span></span> Item) &#123;</span><br><span class="line">    item := <span class="built_in">new</span>(Item)</span><br><span class="line">    ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    […]</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> Item &#123;</span><br><span class="line">        &lt;-ready</span><br><span class="line">        <span class="keyword">return</span> *item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future: caller side</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Right</span></span><br><span class="line">a := Fetch(<span class="string">&quot;a&quot;</span>) </span><br><span class="line">b := Fetch(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">consume(&lt;-a, &lt;-b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// False</span></span><br><span class="line">a := &lt;-Fetch(<span class="string">&quot;a&quot;</span>) <span class="comment">// routine get stalled on this line, so will lose concurrency</span></span><br><span class="line">b := &lt;-Fetch(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">consume(a, b)</span><br></pre></td></tr></table></figure>

<h3 id="Producer–Consumer-Queue"><a href="#Producer–Consumer-Queue" class="headerlink" title="Producer–Consumer Queue"></a>Producer–Consumer Queue</h3><p>A producer–consumer queue also returns a channel, but the <strong>channel receives any number of results and is typically unbuffered</strong>.</p>
<p>A channel fed by one goroutine and read by another <strong>acts as a queue</strong>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Glob finds all items with names matching pattern</span></span><br><span class="line"><span class="comment">// and sends them on the returned channel.</span></span><br><span class="line"><span class="comment">// It closes the channel when all items have been sent. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(pattern <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">        <span class="keyword">for</span> […] &#123;</span><br><span class="line">            […]</span><br><span class="line">            c &lt;- item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Producer-Consumer Queue: caller side</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> Glob(<span class="string">&quot;[ab]*&quot;</span>) &#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Analysis-of-Asynchronous-API"><a href="#Analysis-of-Asynchronous-API" class="headerlink" title="Analysis of Asynchronous API"></a>Analysis of Asynchronous API</h3><p>Classical Benefit:</p>
<ul>
<li>Responsiveness : Avoid blocking UI and network threads<ul>
<li>Most other languages don’t multiplex across OS threads, and kernel schedulers can be unpredictable. So some popular languages and frameworks keep all of the UI or network logic on a single thread. If that thread makes a call that blocks for too long, the UI becomes choppy, or network latency spikes.</li>
<li>Since calls to asynchronous APIs by definition don’t block, they help to keep single-threaded programs responsive.</li>
<li>For go, goroutines are managed by go-runtime, not by kernel scheduler, so the first benefit doesn’t apply to go.</li>
</ul>
</li>
<li>Efficiency : Reduce  idle threads<ul>
<li>Threads are expensive</li>
<li>Languages that don’t multiplex over threads can use asynchronous APIs to keep threads busy, reducing the total number of threads — and context-switches</li>
<li>For go, goroutine is lightweight, it doesn’t spend too much on context switch.</li>
</ul>
</li>
<li>Efficiency : Reclaim stack frames<ul>
<li>Save frame space for other purpose.</li>
<li>For go, runtime resize and reallocate stack as needed. Besides, <strong>the storage location chosen by implementation is irrelevant to the semantics of the language</strong>.</li>
</ul>
</li>
<li>Concurrency : Initiate concurrent work<ul>
<li>Can be important for network RPCs</li>
</ul>
</li>
</ul>
<p>Classical Problems:</p>
<ul>
<li>Caller-Side Ambiguity</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	kind <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = <span class="keyword">map</span>[<span class="type">string</span>]Item&#123;</span><br><span class="line">	<span class="string">&quot;a&quot;</span>: Item&#123;<span class="string">&quot;gopher&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;b&quot;</span>: Item&#123;<span class="string">&quot;rabbit&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSlowThing</span><span class="params">()</span></span> &#123; time.Sleep(<span class="number">10</span> * time.Millisecond) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(a, b Item)</span></span> &#123;</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fetch</span><span class="params">(name <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		item := items[name]</span><br><span class="line">		c &lt;- item</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glob finds all items with names matching pattern</span></span><br><span class="line"><span class="comment">// and sends them on the returned channel.</span></span><br><span class="line"><span class="comment">// It closes the channel when all items have been sent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(pattern <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Item &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Item)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">		<span class="keyword">for</span> name, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">			<span class="keyword">if</span> ok, _ := filepath.Match(pattern, name); !ok &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			c &lt;- item</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> Glob(<span class="string">&quot;[ab]*&quot;</span>) &#123;</span><br><span class="line">		fmt.Println(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Condition-Variable"><a href="#Condition-Variable" class="headerlink" title="Condition Variable"></a>Condition Variable</h2><h3 id="Condition-Variable-Analysis"><a href="#Condition-Variable-Analysis" class="headerlink" title="Condition Variable Analysis"></a>Condition Variable Analysis</h3><p>Problems:</p>
<ul>
<li>Spurious wakeups: Signal some or the threads are hard.</li>
<li>Forgotten signals: Forget to signal some threads when programming.</li>
<li>Starvation: long-running threads will get starved.</li>
<li>Unresponsive cancellation: While waiting for a condition, it may miss other event.</li>
</ul>
<p>Fundamentally, <strong>condition variables rely on communicating by sharing memory</strong>: they signal that a change has occurred, but leave it up to the signalled goroutine to check other shared variables to figure out what. On the other hand, the <strong>Go approach is to share by communicating</strong>.</p>
<h3 id="Semaphore-Sharing-by-Communicating"><a href="#Semaphore-Sharing-by-Communicating" class="headerlink" title="Semaphore : Sharing by Communicating"></a>Semaphore : Sharing by Communicating</h3><p>Go Benefits:</p>
<ul>
<li>Indicate the existence of new data.</li>
<li>Share data by communicating data.</li>
<li>Share things by communicating things.</li>
<li>Metadata are data too!</li>
<li>Mark transitions: mark that a broadcast by close a channel.</li>
</ul>
<p>Buffered channels –&gt; Semaphore pattern</p>
<h2 id="Worker-Pool"><a href="#Worker-Pool" class="headerlink" title="Worker Pool"></a>Worker Pool</h2><p>Benefits:</p>
<ul>
<li>Distribute work across threads<ul>
<li>Threads are heavyweight, worker pool allow reusing threads</li>
<li>Goroutines are lightweight, so it doesn’t apply to go</li>
</ul>
</li>
<li>Limit work in flight</li>
</ul>
<p>Principles:</p>
<ul>
<li><p>Start your goroutine only when you have concurrent work to do now</p>
</li>
<li><p>WaitGroup is enough –&gt; semaphore patterns</p>
</li>
</ul>
<h1 id="Go-Advanced-Concurrency-Patterns"><a href="#Go-Advanced-Concurrency-Patterns" class="headerlink" title="Go Advanced Concurrency Patterns"></a>Go Advanced Concurrency Patterns</h1><h2 id="Timeout-and-Multi-channels"><a href="#Timeout-and-Multi-channels" class="headerlink" title="Timeout and Multi-channels"></a>Timeout and Multi-channels</h2><h3 id="Timed-Channel-Operations"><a href="#Timed-Channel-Operations" class="headerlink" title="Timed Channel Operations"></a>Timed Channel Operations</h3><p>Keep trying doing something, but drop the ball when timeout</p>
<ul>
<li><code>context</code> implementation (more idiomatic)</li>
<li><code>time</code> implementation</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// context impl.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChanTimedContext</span><span class="params">(ctx context.Context, d time.Duration, message Type, c <span class="keyword">chan</span>&lt;- Type)</span></span> (written <span class="type">bool</span>) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(ctx, d)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// time impl.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChanTimedTimer</span><span class="params">(d time.Duration, message Type, c <span class="keyword">chan</span>&lt;- Type)</span></span> (written <span class="type">bool</span>) &#123;</span><br><span class="line">	t := time.NewTimer(d)</span><br><span class="line">	<span class="keyword">defer</span> t.Stop()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="First-in-First-Served"><a href="#First-in-First-Served" class="headerlink" title="First in First Served"></a>First in First Served</h3><p>Sometimes you want to write the same message to many channels, writing to whichever is available first, but <strong>never writing the same message twice</strong> on the same channel.</p>
<ul>
<li>Use <code>select</code> statement to achieve so.</li>
<li>Use goroutines and waits</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// select statement</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServeSelect</span><span class="params">(message Type, a, b <span class="keyword">chan</span> Type)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> a &lt;- message:</span><br><span class="line">            a = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> b &lt;- message:</span><br><span class="line">            b = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// goroutine</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServeGoroutine</span><span class="params">(message Type, a, b <span class="keyword">chan</span> Type)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a &lt;- message; wg.Done() &#125; ()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; b &lt;- message; wg.Done() &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this case performance might matter, and at the time of writing the solution that spawns goroutines takes almost 4 times more than the one with <code>select</code>.</p>
<p>If the amount of channels is not known at compile time, the first solution becomes trickier, but it is still possible, while the second one stays basically unchanged.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServedGoroutinesVariadic</span><span class="params">(message Type, chs ...<span class="keyword">chan</span>&lt;- Type)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(chs))</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> chs &#123;</span><br><span class="line">		c := c</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- message; wg.Done() &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstComeFirstServedSelectVariadic</span><span class="params">(message Type, chs ...<span class="keyword">chan</span>&lt;- Type)</span></span> &#123;</span><br><span class="line">	cases := <span class="built_in">make</span>([]reflect.SelectCase, <span class="built_in">len</span>(chs))</span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> chs &#123;</span><br><span class="line">		cases[i] = reflect.SelectCase&#123;</span><br><span class="line">			Dir:  reflect.SelectSend,</span><br><span class="line">			Chan: reflect.ValueOf(ch),</span><br><span class="line">			Send: reflect.ValueOf(message),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(chs); i++ &#123;</span><br><span class="line">		chosen, _, _ := reflect.Select(cases)</span><br><span class="line">		cases[chosen].Chan = reflect.ValueOf(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The solution using reflection is almost two orders of magnitude slower than the one with goroutines and unreadable.</p>
<h3 id="First-in-First-Serve-with-Timeout"><a href="#First-in-First-Serve-with-Timeout" class="headerlink" title="First in First Serve with Timeout"></a>First in First Serve with Timeout</h3><p>There are two solutions in case you want to try a several sends and abort if it takes too long.</p>
<ul>
<li><code>time + select</code> : better if account of channels are known at compile time.</li>
<li><code>context + go</code> : channels are unknown at compile time.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// time + select</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChansTimedTimerSelect</span><span class="params">(d time.Duration, message Type, a, b <span class="keyword">chan</span> Type)</span></span> (written <span class="type">int</span>) &#123;</span><br><span class="line">	t := time.NewTimer(d)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> a &lt;- message:</span><br><span class="line">			a = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> b &lt;- message:</span><br><span class="line">			b = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t.Stop()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// context + go</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToChansTimedContextGoroutines</span><span class="params">(ctx context.Context, d time.Duration, message Type, ch ...<span class="keyword">chan</span> Type)</span></span> (written <span class="type">int</span>) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(ctx, d)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		wr <span class="type">int32</span></span><br><span class="line">		wg sync.WaitGroup</span><br><span class="line">	)</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(ch))</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		c := c</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> c &lt;- message:</span><br><span class="line">				atomic.AddInt32(&amp;wr, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(wr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><h3 id="time-Ticker"><a href="#time-Ticker" class="headerlink" title="time.Ticker"></a>time.Ticker</h3><p>NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. </p>
<p>The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. </p>
<p>Stop the ticker to release associated resources.</p>
<p>Some caveats:</p>
<ul>
<li><strong>Sends will drop all unread values if <code>C</code> already has one message in it</strong>.</li>
<li>It <strong>must be stopped</strong>: the GC will not collect it otherwise.</li>
<li>Setting <code>C</code> is useless: <strong>messages will still be sent on the original channel</strong>.</li>
</ul>
<h3 id="time-Tick"><a href="#time-Tick" class="headerlink" title="time.Tick"></a>time.Tick</h3><p>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only.</p>
<p>But this is something that should never be used unless you plan to carry the returned <code>chan</code> around and keep using it for the <strong>entire lifetime of the program</strong>.</p>
<p><strong>Because the underlying Ticker cannot be recovered by the garbage collector; it “leaks”</strong>.</p>
<h3 id="time-Timer"><a href="#time-Timer" class="headerlink" title="time.Timer"></a>time.Timer</h3><p>The Timer type represents a single event. <em>When the Timer expires, the current time will be sent on C</em>, unless the Timer was created by AfterFunc. <em><strong>A Timer must be created with NewTimer or AfterFunc</strong></em>.</p>
<p><code>Reset</code> changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.</p>
<p><em><strong>For a Timer created with NewTimer, Reset should be invoked only on stopped or expired timers with drained channels</strong></em>.</p>
<p>Some caveat:</p>
<ul>
<li><code>C</code> cannot be set by user although it is exported.</li>
<li><code>Timer</code> returned by <code>AfterFunc</code> doesn’t use <code>C</code> at all.</li>
<li><code>C</code> will not be closed even after Stop the Timer</li>
<li><code>Stop</code> is safe only after <code>New</code> and <code>Reset</code>.</li>
<li><code>Reset</code> is only valid after <code>Stop</code>.</li>
<li>Received value is valid only if channel is drained after each <code>Stop</code>.</li>
<li>The channel should be drained if and only if the channel has not been read yet.</li>
</ul>
<p><code>time.Afterfunc</code>:</p>
<ul>
<li>AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that <strong>can be used to cancel the call using its Stop method</strong>.</li>
<li>when calling <code>Stop</code>, if <code>false</code> is returned, it means that stopping failed and the function was already started.</li>
</ul>
<p><code>time.NewTimer</code>:</p>
<ul>
<li><p>NewTimer creates a new Timer that will send the current time on its channel after at least duration d.</p>
</li>
<li><p>This means that there is no way to construct a valid <code>Timer</code> without starting it. If you need to construct one for future re-use, you either do it lazily or you have to create and stop it, which can be done with this code:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.NewTimer(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> !t.Stop() &#123;</span><br><span class="line">	&lt;-t.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>time.Stop</code>:</p>
<ul>
<li><p>Stop prevents the Timer from firing. It returns <strong>true</strong> if the <strong>call stops the timer</strong>, <strong>false</strong> if the timer has <em><strong>already expired</strong></em> <strong>or</strong> <em><strong>been stopped</strong></em>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//* not thread safe</span></span><br><span class="line"><span class="keyword">if</span> !t.Stop() &#123;</span><br><span class="line">	&lt;-t.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>time.Reset</code>:</p>
<ul>
<li>Note that it is not possible to use Reset’s return value correctly, as there is a race condition between draining the channel and the new timer expiring. <strong>Reset should always be invoked on stopped or expired channels</strong>.</li>
<li>You cannot use <code>Stop</code> nor <code>Reset</code> concurrently <em>with other receives from the channel</em>, and in order for the value sent on <code>C</code> to be valid, <strong><code>C</code> should be drained exactly once before each <code>Reset</code></strong>.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Timer API</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">	C &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span></span>) *Timer</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span></span> *Timer</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Timer)</span></span> Stop(<span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Timer)</span></span> Reset(d Duration) <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\Blog\source_images\image-20221216234927956.png" alt="image-20221216234927956"></p>
<h3 id="time-After"><a href="#time-After" class="headerlink" title="time.After"></a>time.After</h3><p>This is basically the same concept of <code>Tick</code> but instead of hiding a <code>Ticker</code>, hides a <code>Timer</code>. This is slightly better because once the timer will fire, it will be collected. Please note that timers use 1-buffered channels, so they can fire even if no one is receiving.</p>
<p>But if you care about performance and you want to be able to cancel the call, you should not use <code>After</code>.</p>
<h2 id="Some-Tricks"><a href="#Some-Tricks" class="headerlink" title="Some Tricks"></a>Some Tricks</h2><ul>
<li>For-select loop</li>
<li>Service channel, reply channels (channel of channel)</li>
<li><code>nil</code> channel for select cases</li>
</ul>
<h1 id="Example-Search-Engine"><a href="#Example-Search-Engine" class="headerlink" title="Example : Search Engine"></a>Example : Search Engine</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	res <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Search <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FakeSearch</span><span class="params">(kind <span class="type">string</span>)</span></span> Search &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line">		<span class="keyword">return</span> Result&#123;fmt.Sprintf(<span class="string">&quot;%v returns %v&quot;</span>, kind, query)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	Web    = FakeSearch(<span class="string">&quot;Web&quot;</span>)</span><br><span class="line">	Image  = FakeSearch(<span class="string">&quot;Image&quot;</span>)</span><br><span class="line">	Video  = FakeSearch(<span class="string">&quot;Video&quot;</span>)</span><br><span class="line">	Web1   = FakeSearch(<span class="string">&quot;Web&quot;</span>)</span><br><span class="line">	Image1 = FakeSearch(<span class="string">&quot;Image&quot;</span>)</span><br><span class="line">	Video1 = FakeSearch(<span class="string">&quot;Video&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Generator</span><span class="params">(query <span class="type">string</span>)</span></span> <span class="keyword">chan</span> Result &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Web(query) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Image(query) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- Video(query) &#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">timeout edition of google search engine</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoogleTimeout</span><span class="params">(query <span class="type">string</span>)</span></span> []Result &#123;</span><br><span class="line">	results := <span class="built_in">make</span>([]Result, <span class="number">0</span>)</span><br><span class="line">	ch := Generator(query)</span><br><span class="line">	timeout := time.After(<span class="number">80</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">			results = <span class="built_in">append</span>(results, res)</span><br><span class="line">			fmt.Println(res)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">			<span class="keyword">return</span> results</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchWithReplicas</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">for</span> _, search := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(search <span class="keyword">func</span>(query <span class="type">string</span>)</span></span> Result) &#123;</span><br><span class="line">			ch &lt;- search(query)</span><br><span class="line">		&#125;(search)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Google</span><span class="params">(query <span class="type">string</span>)</span></span> []Result &#123;</span><br><span class="line">	<span class="keyword">var</span> results []Result</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Web, Web1) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Image, Image1) &#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- SearchWithReplicas(query, Video, Video1) &#125;()</span><br><span class="line">	timeout := time.After(time.Duration(<span class="number">80</span>) * time.Millisecond)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">			results = <span class="built_in">append</span>(results, res)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">			<span class="comment">// return results</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	start := time.Now()</span><br><span class="line">	results := Google(<span class="string">&quot;who are you?&quot;</span>)</span><br><span class="line">	elapsed := time.Since(start)</span><br><span class="line">	fmt.Println(elapsed)</span><br><span class="line">	fmt.Println(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Example-Load-Balancer"><a href="#Example-Load-Balancer" class="headerlink" title="Example : Load Balancer"></a>Example : Load Balancer</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">this is a pseudo code for load balancer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Requester</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> <span class="comment">// the operation to perform</span></span><br><span class="line">	c  <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// the channel to return results</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requester</span><span class="params">(works <span class="keyword">chan</span> Request)</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(<span class="number">80</span>)) * time.Millisecond) <span class="comment">//* to emulate load time</span></span><br><span class="line">		works &lt;- Request&#123;workFn, c&#125;</span><br><span class="line">		result := &lt;-c</span><br><span class="line">		futherProcess(result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Worker</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	requests <span class="keyword">chan</span> Request</span><br><span class="line">	pending  <span class="type">int</span></span><br><span class="line">	index    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> work(done <span class="keyword">chan</span> *Worker) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		req := &lt;-w.requests</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(req Request)</span></span> &#123;</span><br><span class="line">			req.c &lt;- req.fn()</span><br><span class="line">			done &lt;- w</span><br><span class="line">		&#125;(req)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Balacer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool []*Worker</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Balancer <span class="keyword">struct</span> &#123;</span><br><span class="line">	pool Pool</span><br><span class="line">	done <span class="keyword">chan</span> *Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> balancer(work <span class="keyword">chan</span> Request) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> req := &lt;-work:</span><br><span class="line">			b.dispatch(req)</span><br><span class="line">		<span class="keyword">case</span> w := &lt;-b.done:</span><br><span class="line">			b.complete(w)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> dispatch(req Request) &#123;</span><br><span class="line">	w := heap.Pop(&amp;b.pool).(*Worker)</span><br><span class="line">	w.requests &lt;- req</span><br><span class="line">	w.pending++</span><br><span class="line">	heap.Push(&amp;b.pool, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Balancer)</span></span> complete(w *Worker) &#123;</span><br><span class="line">	w.pending--</span><br><span class="line">	heap.Remove(&amp;b.pool, w.index)</span><br><span class="line">	heap.Push(&amp;b.pool, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> poolSize = <span class="number">30</span></span><br><span class="line">	<span class="keyword">var</span> requests <span class="keyword">chan</span> Request = <span class="built_in">make</span>(<span class="keyword">chan</span> Request)</span><br><span class="line">	<span class="keyword">go</span> requester(requests) <span class="comment">//* load request and generate work</span></span><br><span class="line">	<span class="keyword">var</span> b Balancer = Balancer&#123;<span class="built_in">make</span>(Pool, <span class="number">0</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> *Worker)&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; poolSize; i++ &#123;</span><br><span class="line">		b.pool = <span class="built_in">append</span>(b.pool, &amp;Worker&#123;requests, <span class="number">0</span>, i&#125;)</span><br><span class="line">		<span class="keyword">go</span> b.pool[i].work(b.done)</span><br><span class="line">	&#125; <span class="comment">//* generate workers</span></span><br><span class="line"></span><br><span class="line">	b.balancer(requests) <span class="comment">//* do load balance things</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>RISC-V</title>
    <url>/2022/11/17/RISC-V/</url>
    <content><![CDATA[<p>CSR (Control and Status Registers) : 64bits</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>register</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>mscratch</td>
<td>Machine Scratch。保存机器模式的栈顶指针，这一点在离开机器模式进入低特权级模式（如监管模式）时非常重要，因为一旦在低特权级模式发生异常，将可能会回到机器模式处理，这时机器模式需要有自己的栈来保存M模式下的执行所调用的函数参数和返回地址。</td>
</tr>
<tr>
<td>mstatus</td>
<td>Machine Status。保存机器状态的寄存器。</td>
</tr>
<tr>
<td>mtvec</td>
<td>Machine Trap Vector。指向中断处理函数的入口地址。</td>
</tr>
<tr>
<td>mepc</td>
<td>Machine Exception PC。指向发生异常的那条指令的地址。</td>
</tr>
<tr>
<td>mcause</td>
<td>Machine Cause。发生中断的原因，如果发生的中断是异常，其最高位为0，低位为异常编号；如果发生的是其他类型的中断，则其最高位为1，低位为中断编号。</td>
</tr>
<tr>
<td>mtval</td>
<td>Machine Trap Value。异常发生时，附带的参数值。例如，当缺页异常发生时，mtval的值就是程序想要访问的虚地址。</td>
</tr>
<tr>
<td>mie</td>
<td>Machine Interrupt Enable。中断开启寄存器。</td>
</tr>
<tr>
<td>mip</td>
<td>Machine Interrupt Pending。中断等待寄存器。</td>
</tr>
<tr>
<td>mideleg</td>
<td>Machine Interrupt Delegation Registers。中断代理寄存器。</td>
</tr>
<tr>
<td>medeleg</td>
<td>Machine Exception Delegation Registers。异常代理寄存器。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>sscratch</td>
<td>Supervisor Scratch。保存监管模式的栈顶指针，这一点在离开机器模式进入低特权级模式（如用户模式）时非常重要，因为一旦在低特权级模式发生异常，将可能会回到监管模式处理（假设已通过异常授权），这时监管模式需要用自己的栈保存程序执行的返回地址等。</td>
</tr>
<tr>
<td>sstatus</td>
<td>Supervisor Status。保存监管状态的寄存器。</td>
</tr>
<tr>
<td>stvec</td>
<td>Supervisor Trap Vector。指向监管模式中断处理函数的入口地址。</td>
</tr>
<tr>
<td>sepc</td>
<td>Supervisor Exception PC。指向发生异常的那条指令的地址。</td>
</tr>
<tr>
<td>scause</td>
<td>Supervisor Cause。发生中断的原因，如果发生的中断是异常，其最高位为0，低位为异常编号；如果发生的是其他中断其最高位为1，低位为中断编号。</td>
</tr>
<tr>
<td>stval</td>
<td>Supervisor Trap Value。异常发生时，附带的参数值。例如，当缺页异常发生时，mtval的值就是程序想要访问的虚地址。</td>
</tr>
<tr>
<td>sie</td>
<td>Supervisor Interrupt Enable。中断开启寄存器。</td>
</tr>
<tr>
<td>sip</td>
<td>Supervisor Interrupt Pending。中断等待寄存器。</td>
</tr>
<tr>
<td>sideleg</td>
<td>Supervisor Interrupt Delegation Registers。中断代理寄存器。</td>
</tr>
<tr>
<td>sedeleg</td>
<td>Supervisor Exception Delegation Registers。异常代理寄存器。</td>
</tr>
</tbody></table>
<p>CSR 读写指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>csrr rd, csr</td>
<td>Control and Status Register Read，<strong>读</strong>CSR指令。 把csr寄存器中的值写入到rd寄存器中。</td>
</tr>
<tr>
<td>csrw csr, rs1</td>
<td>Control and Status Register Write，<strong>写</strong>CSR指令。 把rs1的值写到csr寄存器中。</td>
</tr>
<tr>
<td>csrs csr, rs1</td>
<td>Control and Status Register Set，<strong>设置</strong>CSR指令。 对于rs1中每一个为1的位，将csr寄存器中对应位置位。</td>
</tr>
<tr>
<td>csrc csr, rs1</td>
<td>Control and Status Register Clear，<strong>清除</strong>CSR指令。 对于rs1中每一个为1的位，将csr寄存器中对应位清零。</td>
</tr>
<tr>
<td>csrrs rd, csr, rs1</td>
<td>Control and Status Register Read and Set，<strong>读后置位</strong>CSR指令。 记控制寄存器中的值为t，把t和寄存器rs1按位或的结果写入csr寄存器，再把t写入rd寄存器。</td>
</tr>
<tr>
<td>csrrc rd, csr, rs1</td>
<td>Control and Status Register Read and Clear，<strong>读后清除</strong>CSR指令。 记控制寄存器中的值为t，把t和寄存器rs1中的值按位与的结果写入csr寄存器，再把t写入rd寄存器。</td>
</tr>
<tr>
<td>csrrw rd, csr, rs1</td>
<td>Control and Status Register Read and Write，<strong>读后写</strong>CSR指令。 记控制寄存器中的值为t，把寄存器rs1的值写入csr寄存器，再把t写入rd寄存器。</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>RISC-V</tag>
      </tags>
  </entry>
</search>
